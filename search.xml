<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Spring IoC容器高级特性]]></title>
      <url>http://yoursite.com/2017/08/05/Spring-IoC%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring-IoC依赖注入]]></title>
      <url>http://yoursite.com/2017/08/03/Spring-IoC%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<h1 id="IoC依赖注入发生的时间"><a href="#IoC依赖注入发生的时间" class="headerlink" title="IoC依赖注入发生的时间"></a>IoC依赖注入发生的时间</h1><p>首先需要明确的是在IoC容器初始化之后，IoC容器已经开始管理Bean了，但是这时还不一定对管理的Bean进行了依赖注入</p>
<ul>
<li>第一次通过getBean()方法向IoC容器所要bean时，IoC容器触发依赖注入</li>
<li>当Bean配置文件的<bean>标签设置了<code>lazy-init</code>属性时，IoC容器在解析Bean定义时进行预实例化，触发依赖注入，也即是随着ApplicationContext文件的加载而触发依赖注入，这是默认情况</bean></li>
</ul>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>依赖注入发生的时间似乎可早可晚，这就不免让人思考一个问题，Spring中bean对象的生命周期问题，因为Spring的ApplicationContext容器在启动时会自动实例化所有singleton的Bean实例并缓存到容器中，那么这就开始了，接下来呢？</p>
<p>其实这是一个好坑</p>
<h1 id="依赖注入的步骤"><a href="#依赖注入的步骤" class="headerlink" title="依赖注入的步骤"></a>依赖注入的步骤</h1><p>像上一篇IoC容器的初始化过程一样，涉及到了很多源码，这里只粘出总结出的步骤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">IoC容器初始化完成</div><div class="line">			↓</div><div class="line">AbstractBeanFactory通过getBean像IoC容器中获取bean，实际上是使用不同的模式来createBean：单例模式就是singleton的bean，原型模式就是不同的bean</div><div class="line">			↓</div><div class="line">createBeanInstance()生成bean的Java对象实例；populateBean()对bean属性的依赖关系进行注入</div><div class="line">			↓</div><div class="line">bean对象使用工厂方法和自动装配特性来进行bean实例化：</div><div class="line">  参数匹配的构造方法或者相应的工厂方法进行实例化</div><div class="line">  默认无参的构造方法使用反射和CGLIB进行实例化，bean中的方法被覆盖了就使用反射，反之就是CGLIB</div><div class="line">			↓</div><div class="line">populateBean()方法对bean的属性开始注入</div><div class="line">  属性值类型不需要转换的直接调用set方法</div><div class="line">  属性值类型需要转换的，先解析在注入</div><div class="line">			↓</div><div class="line">解析属性，各种List、Set、Map属性，解析成目标属性</div><div class="line">			↓</div><div class="line">对于集合类型的属性，解析后注入属性；非集合类型的属性，使用大量反射和内省机制（缺省办法），使用get获取旧值，再使用set赋予新值</div></pre></td></tr></table></figure></p>
<p>至此，完成了IoC依赖注入</p>
<h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><p>再看很多博客时会注意到，大家对于IoC容器的初始化完成这个一点有不同的定义，有的是认为IoC容器加载解析注册完Bean配置之后就是完成了IoC容器的初始化，有的则还会包括接下来的Bean对象的依赖注入之后才是真正的完成了IoC容器的初始化<br>从源码上来看，我个人更愿意倾向于第一种，Bean对象的依赖注入的代码与IoC加载解析注册的代码有明显的分为不同阶段，这里就统一一下</p>
]]></content>
      
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyCat多重规则哈希分片]]></title>
      <url>http://yoursite.com/2017/08/03/MyCat%E5%A4%9A%E9%87%8D%E8%A7%84%E5%88%99%E5%93%88%E5%B8%8C%E5%88%86%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="MyCat分片规则"><a href="#MyCat分片规则" class="headerlink" title="MyCat分片规则"></a>MyCat分片规则</h1><p>MyCat自带的分片规则有很多种，而且支持自定义分片规则，灰常好用啊<br><a href="http://blog.csdn.net/zhxdick/article/details/50619328" target="_blank" rel="external">感觉巨佬整理的很细，容易理解</a></p>
<ul>
<li>哈希取模分片：常见的分片方式，根据分片字段（一般是主键）的哈希值，再对分片个数取模运算，决定记录到哪个分片上；分片个数最好是2的n次方</li>
<li>路由约定分片：维护一个properties文件，针对不同的值设置不同的分片</li>
<li>范围路由约定分片：针对不同范围的值约定一个分片</li>
<li>哈希范围约定分片：分片字段值哈希取模后的范围约定分片</li>
<li>部分字段分片：截取某个字段的一部分作为分片依据，配合全局id生成器使用</li>
<li>多重规则分片：设置多种分片规则，比如一部分采用路由分片，一部分采用哈希范围分片</li>
</ul>
<h1 id="自定义分片规则"><a href="#自定义分片规则" class="headerlink" title="自定义分片规则"></a>自定义分片规则</h1><p>MyCat支持自定义分片规则，自定义类需要继承<code>AbstractPartitionAlgorithm</code>类，然后实现<code>calculate()</code>或<code>calculateRange()</code>方法</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>这是看到了<a href="http://blog.csdn.net/zhxdick/article/details/50674026" target="_blank" rel="external">巨佬整理的博客</a>，所幸自己也读懂了代码，忍不住自己也整理一下收获</p>
<ul>
<li><p><code>AbstractPartitionAlgorithm</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPartitionAlgorithm</span> <span class="keyword">implements</span> <span class="title">RuleAlgorithm</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回所有被路由到的节点的编号</div><div class="line">     * 返回长度为0的数组表示所有节点都被路由（默认）</div><div class="line">     * 返回null表示没有节点被路由到</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Integer[] calculateRange(String beginValue, String endValue) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对于存储数据按顺序存放的字段做范围路由，可以使用这个函数</div><div class="line">     * <span class="doctag">@param</span> algorithm</div><div class="line">     * <span class="doctag">@param</span> beginValue</div><div class="line">     * <span class="doctag">@param</span> endValue</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] calculateSequenceRange(AbstractPartitionAlgorithm algorithm, String beginValue, String endValue) &#123;</div><div class="line">        Integer begin = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">        begin = algorithm.calculate(beginValue);</div><div class="line">        end = algorithm.calculate(endValue);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(begin == <span class="keyword">null</span> || end == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end &gt;= begin) &#123;</div><div class="line">            <span class="keyword">int</span> len = end-begin+<span class="number">1</span>;</div><div class="line">            Integer [] re = <span class="keyword">new</span> Integer[len];</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                re[i]=begin+i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> re;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>PartitionByMod</code>源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.count = count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(String columnValue)</span> </span>&#123;</div><div class="line">    BigInteger bigNum = <span class="keyword">new</span> BigInteger(columnValue).abs();</div><div class="line">    <span class="comment">// 简单的对分片个数取模</span></div><div class="line">    <span class="comment">// x mod (2^n) = x&amp;(2^n-1)</span></div><div class="line">    <span class="keyword">return</span> (bigNum.mod(BigInteger.valueOf(count))).intValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不带范围约定的符合规则分片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 首先实现不带范围约定的复合规则，即配置文件中为：</div><div class="line">* 北京=0，1，2,3,4</div><div class="line">* 上海=10,11</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionByRouteHash</span> <span class="keyword">extends</span> <span class="title">AbstractPartitionAlgorithm</span> <span class="keyword">implements</span> <span class="title">RuleAlgorithm</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> String routeFile;</div><div class="line">    <span class="comment">// 注意使用map存储分片规则对应关系</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Integer&gt;&gt; routeNodeMap;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NODE = <span class="string">"DEFAULT_NODE"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> keyStartIndex;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> keyEndIndex;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> valueStartIndex;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> valueEndIndex;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyStartIndex</span><span class="params">(<span class="keyword">int</span> keyStartIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.keyStartIndex = keyStartIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyEndIndex</span><span class="params">(<span class="keyword">int</span> keyEndIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.keyEndIndex = keyEndIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValueStartIndex</span><span class="params">(<span class="keyword">int</span> valueStartIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.valueStartIndex = valueStartIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValueEndIndex</span><span class="params">(<span class="keyword">int</span> valueEndIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.valueEndIndex = valueEndIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRouteFile</span><span class="params">(String routeFile)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.routeFile = routeFile;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        initialize();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">// 参数值一般就是等号的左值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(String columnValue)</span> </span>&#123;</div><div class="line">        String key = columnValue.substring(keyStartIndex,keyEndIndex);</div><div class="line">        String value = columnValue.substring(valueStartIndex,valueEndIndex);</div><div class="line">        List&lt;Integer&gt; nodes = routeNodeMap.get(key);</div><div class="line">        <span class="keyword">if</span>(nodes == <span class="keyword">null</span>)</div><div class="line">            nodes = routeNodeMap.get(DEFAULT_NODE);</div><div class="line">        <span class="comment">// 先进性哈希</span></div><div class="line">        BigInteger bigNum = <span class="keyword">new</span> BigInteger(<span class="string">""</span>+value.hashCode());</div><div class="line">        <span class="comment">// 再对分片个数取模</span></div><div class="line">        <span class="keyword">return</span> nodes.get((bigNum.mod(BigInteger.valueOf(nodes.size()))).intValue());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 读取文件，创建哈希表保存对应关系</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">        BufferedReader in = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream fin = <span class="keyword">this</span>.getClass().getClassLoader()</div><div class="line">                    .getResourceAsStream(routeFile);</div><div class="line">            <span class="keyword">if</span> (fin == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't find class resource file "</span></div><div class="line">                        + routeFile);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 准备逐行读取</span></div><div class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fin));</div><div class="line"></div><div class="line">            routeNodeMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (String line = <span class="keyword">null</span>; (line = in.readLine()) != <span class="keyword">null</span>;) &#123;</div><div class="line">                line = line.trim();</div><div class="line">                <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.startsWith(<span class="string">"//"</span>))</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> ind = line.indexOf(<span class="string">'='</span>);</div><div class="line">                <span class="keyword">if</span> (ind &lt; <span class="number">0</span>)</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String key = line.substring(<span class="number">0</span>, ind).trim();</div><div class="line">                    String value = line.substring(ind+<span class="number">1</span>).trim();</div><div class="line">                    String []nodes = value.split(<span class="string">","</span>);</div><div class="line">                    <span class="comment">// values是各个分片节点，采用整型队列存储</span></div><div class="line">                    List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; nodes.length ; i++)&#123;</div><div class="line">                        values.add(Integer.parseInt(nodes[i].trim()));</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 将对应关系存储下来</span></div><div class="line">                    routeNodeMap.put(key,values);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    System.out.println(<span class="string">"something wrong in the route hash configuration!"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">                <span class="keyword">throw</span> (RuntimeException) e;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                in.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>带范围约定的复合规则分片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 实现范围约定的复合规则</div><div class="line">* 上海（A00000-A100000）= 2,5,6</div><div class="line">* 北京（B00000-B100000）= 3,8,9</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionByScalableRouteHash</span> <span class="keyword">extends</span> <span class="title">PartitionByRouteHash</span> </span>&#123;</div><div class="line">    <span class="comment">// 注意使用字段值的左半部分当作routeNodeMap的key，右半部分当作value的key，分片节点存储的队列当作value的value</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String,Map&lt;String[],List&lt;Integer&gt;&gt;&gt; routeNodeMap;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        initialize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(String columnValue)</span> </span>&#123;</div><div class="line">        String key = columnValue.substring(keyStartIndex,keyEndIndex);</div><div class="line">        String value = columnValue.substring(valueStartIndex,valueEndIndex);</div><div class="line">        Map&lt;String[],List&lt;Integer&gt;&gt; scaleMap = routeNodeMap.get(key);</div><div class="line">        <span class="keyword">if</span>(scaleMap==<span class="keyword">null</span>)&#123;</div><div class="line">            scaleMap = routeNodeMap.get(<span class="keyword">this</span>.DEFAULT_NODE);</div><div class="line">        &#125;</div><div class="line">        String []ranges = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line">        <span class="comment">// 遍历routerMap的value的key，取得范围的上下界的值，进行比对</span></div><div class="line">        <span class="keyword">for</span>(String []range:scaleMap.keySet())&#123;</div><div class="line">            <span class="keyword">if</span>(range[<span class="number">0</span>].equals(<span class="keyword">this</span>.DEFAULT_NODE))</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(range[<span class="number">0</span>].compareTo(value)&lt;<span class="number">0</span>&amp;&amp;range[<span class="number">1</span>].compareTo(value)&gt;<span class="number">0</span>)</div><div class="line">                ranges = range;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(ranges.length==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">for</span>(String []range:scaleMap.keySet())&#123;</div><div class="line">                <span class="keyword">if</span>(range[<span class="number">0</span>].equals(<span class="keyword">this</span>.DEFAULT_NODE))&#123;</div><div class="line">                    ranges = range;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; nodes = scaleMap.get(ranges);</div><div class="line">        <span class="comment">// 这里的value是传入的字段值中的范围，进行哈希</span></div><div class="line">        BigInteger bigNum = <span class="keyword">new</span> BigInteger(<span class="string">""</span>+value.hashCode());</div><div class="line">        <span class="comment">// 将范围在进行取模</span></div><div class="line">        <span class="keyword">return</span> nodes.get((bigNum.mod(BigInteger.valueOf(nodes.size()))).intValue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</div><div class="line">        BufferedReader in = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream fin = <span class="keyword">this</span>.getClass().getClassLoader()</div><div class="line">                    .getResourceAsStream(routeFile);</div><div class="line">            <span class="keyword">if</span> (fin == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't find class resource file "</span></div><div class="line">                        + routeFile);</div><div class="line">            &#125;</div><div class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fin));</div><div class="line"></div><div class="line">            routeNodeMap = <span class="keyword">new</span> HashMap&lt;String, Map&lt;String[], List&lt;Integer&gt;&gt;&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (String line = <span class="keyword">null</span>; (line = in.readLine()) != <span class="keyword">null</span>;) &#123;</div><div class="line">                line = line.trim();</div><div class="line">                <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.startsWith(<span class="string">"//"</span>))</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">int</span> lb = line.indexOf(<span class="string">'('</span>),rb = line.indexOf(<span class="string">')'</span>),mb = line.indexOf(<span class="string">':'</span>);</div><div class="line"></div><div class="line">                <span class="keyword">int</span> ind = line.indexOf(<span class="string">'='</span>);</div><div class="line">                <span class="keyword">if</span>((lb!=-<span class="number">1</span>&amp;&amp;rb!=-<span class="number">1</span>&amp;&amp;mb!=-<span class="number">1</span>)&amp;&amp;(mb&lt;lb||mb&gt;rb||lb&gt;rb||rb&gt;ind))&#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Wrong format! Error use of (),:,=!"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (ind &lt; <span class="number">0</span>)</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    String key = line.substring(<span class="number">0</span>, lb&lt;<span class="number">0</span>?ind:lb).trim();</div><div class="line">                    Map&lt;String[],List&lt;Integer&gt;&gt; scaleMap = routeNodeMap.get(key);</div><div class="line">                    <span class="keyword">if</span>(scaleMap == <span class="keyword">null</span>)&#123;</div><div class="line">                        scaleMap = <span class="keyword">new</span> HashMap&lt;String[],List&lt;Integer&gt;&gt;();</div><div class="line">                        routeNodeMap.put(key,scaleMap);</div><div class="line">                    &#125;</div><div class="line">                    String[] valueRange = <span class="keyword">new</span> String[<span class="number">2</span>];</div><div class="line">                    <span class="keyword">if</span>(lb!=-<span class="number">1</span>&amp;&amp;rb!=-<span class="number">1</span>&amp;&amp;mb!=-<span class="number">1</span>) &#123;</div><div class="line">                    <span class="comment">// 解析范围的上下届值，使用String数组存储</span></div><div class="line">                        String minValue = line.substring(lb + <span class="number">1</span>, mb).trim();</div><div class="line">                        String maxValue = line.substring(mb + <span class="number">1</span>, rb).trim();</div><div class="line">                        <span class="keyword">if</span> (minValue.length() != maxValue.length() || minValue.compareTo(maxValue) &gt;= <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Wrong value range! "</span>);</div><div class="line">                        &#125;</div><div class="line">                        valueRange[<span class="number">0</span>] = minValue;</div><div class="line">                        valueRange[<span class="number">1</span>] = maxValue;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        valueRange[<span class="number">0</span>] = <span class="keyword">this</span>.DEFAULT_NODE;</div><div class="line">                    &#125;</div><div class="line">                    String value = line.substring(ind+<span class="number">1</span>).trim();</div><div class="line">                    String []nodes = value.split(<span class="string">","</span>);</div><div class="line">                    List&lt;Integer&gt; node = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; nodes.length ; i++)&#123;</div><div class="line">                        node.add(Integer.parseInt(nodes[i].trim()));</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 存储范围与分片节点的对应关系</span></div><div class="line">                    scaleMap.put(valueRange,node);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    System.out.println(<span class="string">"something wrong in the route hash configuration!"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">                <span class="keyword">throw</span> (RuntimeException) e;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                in.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当然上述的两个方法是需要设置<code>rule.xml</code>配置文件的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"scalable-route-hash"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>scalable-route-hash<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"scalable-route-hash"</span> <span class="attr">class</span>=<span class="string">"org.opencloudb.route.function.PartitionByRouteHash"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"routeFile"</span>&gt;</span>scalable-route-hash.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keyStartIndex"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keyEndIndex"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueStartIndex"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueEndIndex"</span>&gt;</span>11<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">function</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> MyCat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring配置Mybatis执行原生SQL语句]]></title>
      <url>http://yoursite.com/2017/08/03/Spring%E9%85%8D%E7%BD%AEMybatis%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="为什么要怎么做"><a href="#为什么要怎么做" class="headerlink" title="为什么要怎么做"></a>为什么要怎么做</h1><p>有这么一个应用场景：需要在Mybatis框架上进行多个连接池的配置，然后进行多种SQL语句的测试，因为有些SQL语句的结构比较复杂，有些会涉及到很多<code>group by</code>、<code>join</code>操作还有一些聚集函数的使用，同时数据量又较大。<br>在这种情况下，常规的Mybatis面对对象进行操作的办法就不再试适用，查看Mybatis官方手册，提供了SQL构造器的办法也会有较的工作量，所以选择直接执行SQL语句（那为啥不用JDBC呢？笑）</p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>凭我记忆中对Mybatis的用法，似乎并没有这么用的，去网上搜，居然真的存在这种用法，但是讲的大多含糊其辞，晕了一下午也没让我找到正确的做法（真心给跪）</p>
<ul>
<li><a href="http://blog.csdn.net/binyao02123202/article/details/8573352" target="_blank" rel="external">将SQL当作SqlSession执行的参数</a>：使用SqlSession的<code>selectList()</code>方法，传入的参数是SQL，当然需要在Bean的mapper xml配置文件中修改<code>parameterType</code>类型为String，同时因为String不支持getter和setter操作，手动封装一个包装类SQLAdapter</li>
</ul>
<p>虽然看起来似乎可以，但是还是会存在坑的，即“SqlSession对象如何调用selectList()方法来传入SQL语句？”。一开始是直接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sql 是原生SQL语句</span></div><div class="line">list = sqlSession.selectList(<span class="string">"selectList"</span>,sql);</div></pre></td></tr></table></figure></p>
<p>这样还是会提示String没有setter方法而报出异常</p>
<ul>
<li>其实还有一个坑是关于在xml映射文件中 <code>&lt;select&gt;</code> 语句的返回值问题，有的查询语句是返回集合，而有的是返回整型值，直接设置<code>resultType = &quot;XXX&quot;</code>肯定是会报错的</li>
<li>第三个坑是解决了上述问题后报出的<code>org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()</code>异常，上网一搜，是<code>mybatis-spring</code>的版本问题</li>
</ul>
<h1 id="成功的做法"><a href="#成功的做法" class="headerlink" title="成功的做法"></a>成功的做法</h1><p>试了整整一上午，反复踩坑跳坑，终于让我找到了一条正确的道路</p>
<ul>
<li>按照上面提到的解决步骤先进行设置，重点放在执行查询的时候，sqlSession执行方法时传入的参数要注意<strong>不能是String类型的SQL，而需要是封装类SQLAdapter对象</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list = sqlSession.selectList(<span class="string">"selectList"</span>,<span class="keyword">new</span> SQLAdapter(sql));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即可解决第一个问题，可以执行部分语句</p>
<ul>
<li>第二个问题说白了就是针对查询的返回值类型要有合适的“容器”来接收，不能是某个具体的类型，那么直接采用超类<code>java.lang.Object</code>来最为resultType的值</li>
<li>最后一个问题就好解决了，mybatis-spring的版本设置为3.4.0即可（原来是3.2.2），总之版本要高一些</li>
</ul>
<h1 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h1><p>其实自己学东西的时候肯定会遇到很多坑，有时比问题还坑的是网上的某些“指导”，总是会经历过心态崩溃的时候，只是希望自己不要成为误导别人的人<br>ps：遇到不会的还是要多关注官方文档啊</p>
]]></content>
      
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring-IoC容器初始化]]></title>
      <url>http://yoursite.com/2017/08/02/Spring-IoC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="Spring-Ioc容器"><a href="#Spring-Ioc容器" class="headerlink" title="Spring Ioc容器"></a>Spring Ioc容器</h1><p>IoC容器最主要是对Bean对象的创建和依赖管里注入，是整个Spring IoC功能的核心</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>Spring IoC结构很复杂，多个类继承实现关系混乱，但最基础的有三个</p>
<ul>
<li><code>BeanFactory</code>，对IoC容器的基本行为做出了定义<br><img src="/2017/08/02/Spring-IoC容器初始化/beanfactory.png" alt="beanFactory"></li>
<li><code>BeanDefinition</code>，在IOC中可识别Bean资源文件的描述<br><img src="/2017/08/02/Spring-IoC容器初始化/beandefinition.png" alt="beandefinition"></li>
<li><code>BeanDefinitionReader</code>，加载Bean资源文件<br><img src="/2017/08/02/Spring-IoC容器初始化/xmlprase.png" alt="xmlprase"></li>
</ul>
<h1 id="Ioc容器初始化过程"><a href="#Ioc容器初始化过程" class="headerlink" title="Ioc容器初始化过程"></a>Ioc容器初始化过程</h1><p>这里举两个简单的例子</p>
<h2 id="XmlBeanFactory容器"><a href="#XmlBeanFactory容器" class="headerlink" title="XmlBeanFactory容器"></a>XmlBeanFactory容器</h2><p>一个较为低级的IoC容器，实现了最基本的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息</span></div><div class="line"> ClassPathResource resource =<span class="keyword">new</span> ClassPathResource(<span class="string">"application-context.xml"</span>);</div><div class="line"><span class="comment">//创建DefaultListableBeanFactory</span></div><div class="line"> DefaultListableBeanFactory factory =<span class="keyword">new</span> DefaultListableBeanFactory();</div><div class="line"><span class="comment">//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory</span></div><div class="line"> XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</div><div class="line"><span class="comment">//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用</span></div><div class="line"> reader.loadBeanDefinitions(resource);</div></pre></td></tr></table></figure></p>
<h2 id="ApplicationContext容器"><a href="#ApplicationContext容器" class="headerlink" title="ApplicationContext容器"></a>ApplicationContext容器</h2><p>更为高级的IoC容器，除基本功能外，还支持信息源，可以实现国际化、访问资源和支持应用事件<br>因具体涉及的源代码很多，原理也较难解释清除，故只列出最基本的流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ApplicationContext application = <span class="keyword">new</span> FileSystemXmlApplicationContext(xmlPath);</div><div class="line">			↓</div><div class="line">父类AbastractRefreshableConfigApplicationContext为容器设置Bean资源加载器</div><div class="line">			↓</div><div class="line">资源加载器resourceLoader被赋值，设置资源文件路径，然后对资源文件路径进行解析</div><div class="line">			↓</div><div class="line">调用refresh()方法，这是IoC容器初始化的入口</div><div class="line">			↓</div><div class="line">创建IoC容器，子类启动载入过程；ConfigurableListableBeanFactory beanFactory = obtainBeanFactory();</div><div class="line">			↓</div><div class="line">创建DefaultListableBeanFactory对象，装载beanFactory对象loadBeanDefinitions(beanFactory)</div><div class="line">			↓</div><div class="line">新建Xml Bean读取器XmlBeanDefinitionReader对象，加载Bean资源文件</div><div class="line">			↓</div><div class="line">resourceLoader.getSource(Location)获取资源</div><div class="line">			↓</div><div class="line">加载Bean配置文件，对xml进行解析成Document对象</div><div class="line">			↓</div><div class="line">按照Spring IoC识别的Bean规则在DefaultDefinitionDocumentReader中对Document对象进行解析</div><div class="line">			↓</div><div class="line">解析文件的&lt;Import&gt;、&lt;Alias&gt;、&lt;property&gt;、&lt;List&gt;、&lt;Set&gt;等元素，Bean资源文件最终被解析成BeanDefinition对象，是资源原件在IoC中的映射</div><div class="line">			↓</div><div class="line">BeanDefinition在IoC容器中进行注册</div></pre></td></tr></table></figure>
<p>至此，Bean资源文件中配置的bean被解析成可以被IoC容器识别的对象且被注册管理起来，IoC容器可以进行索引、查询以及操作；被IoC容器管理起来后，也真正完成了IoC容器的初始化</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>IoC容器中的注册就是维护了一个HashMap，保存了BeanDefinition对象，方便了后续的管理</p>
<h1 id="困了Orz"><a href="#困了Orz" class="headerlink" title="困了Orz"></a>困了Orz</h1><p>从开始看到现在，四个多小时了，中间还喝了半瓶红葡萄酒，算是对Spring IoC容器的初始化了解了，明天再看AOP，现在真是困了…<br>睡觉</p>
]]></content>
      
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程池与数据库连接池区别]]></title>
      <url>http://yoursite.com/2017/08/02/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="线程池与数据库连接池的区别"><a href="#线程池与数据库连接池的区别" class="headerlink" title="线程池与数据库连接池的区别"></a>线程池与数据库连接池的区别</h1><p>看到了MyCat参数设置时注意到了连接池的设置，突然发现好几个池化的概念，就顺手搜了一下，这里附上<a href="http://bepatient.iteye.com/blog/688353" target="_blank" rel="external">原文链接</a></p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote>
<p>其实线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p>
</blockquote>
<p>当然为每一个请求单独的创建线程是很方便的，但是并发量很大时，如果为每一个请求都创建新的线程，那么耗费CPU时间和内存是很惊人的，同时反复创建、销毁线程带来的结果将是一场灾难</p>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><blockquote>
<p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。    一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。<br>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。<br>1) 最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；<br>2) 最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p>
</blockquote>
<p>注意到还有一个概念是空闲连接，说的就是长连接时，有一个最大保持时间，目的是在达到一定时间不工作后对资源进行的回收</p>
<h1 id="以我看来"><a href="#以我看来" class="headerlink" title="以我看来"></a>以我看来</h1><p>记得还有一个博客提到了<strong>对象池</strong>的概念，ta理解的数据路连接池就是保存了很多数据库连接对象的对象池。</p>
<p>我也觉得有道理，其实说白了，池化（缓冲）的作用就是在系统初始化时预先准备好资源，有请求时分配对象去使用，空闲时就进行回收但不销毁；这样做的目的是减少了对象反复创建、销毁所花费的时间，这在并发量很大的情况下是很吃资源的</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring加载方式及原理]]></title>
      <url>http://yoursite.com/2017/08/02/Spring%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h1><p>因为这个是更早建立的，当时没有想到这个部分深入到源码时会这么的多，后面只能分开来看，当然了，也就分开总结吧，这里给出链接</p>
<h1 id="Spring-IoC容器初始化"><a href="#Spring-IoC容器初始化" class="headerlink" title="Spring IoC容器初始化"></a>Spring IoC容器初始化</h1><h1 id="Spring-IoC依赖注入"><a href="#Spring-IoC依赖注入" class="headerlink" title="Spring IoC依赖注入"></a>Spring IoC依赖注入</h1><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>这个部分差不多花了好几个夜晚，从摸索着研究到开始上手，整理清除思路之后又做笔记写博客，感觉Spring的代码写的很棒，运用到了Java的特性非常之多以及如此精准，同时运用了大量的设计模式，确实是含金量很高的框架，值得我们去看看学学它的源码</p>
]]></content>
      
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM内存分配与GC]]></title>
      <url>http://yoursite.com/2017/05/29/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8EGC/</url>
      <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="=_="></a>=_=</h1><p>本来这部分是不想写的，后面想想还是算了，毕竟是最早开始研究又算是相对了解的地方，这次就顺便总结一下看书的心得吧</p>
<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>JVM提程序员管理了内存区域，免去了不少麻烦，但我们还是需要去了解的。这个内存区域分为了两大类五个区：方法区与Java堆、虚拟机栈与本地方法栈与程序计数器。具体的解释在很久之前研究<a href="http://zpcheng.me/2017/03/29/JVM-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/" target="_blank" rel="external">String常量池的位置</a>时已经有解释过了，不再赘述</p>
<h1 id="JVM内存分配"><a href="#JVM内存分配" class="headerlink" title="JVM内存分配"></a>JVM内存分配</h1><p>说到内存分配，还是得先了解一下JVM内存的<strong>分代管理</strong>，很久之前的一次面试有提到过这个分代机制，不过当时是懵逼的。</p>
<h2 id="JVM的分代机制"><a href="#JVM的分代机制" class="headerlink" title="JVM的分代机制"></a>JVM的分代机制</h2><p>为了方便管理Java内存中的对象，JVM采用了分代管理的机制，即把整个内存区分为了<strong>年轻代、年老代和永久代</strong></p>
<ul>
<li>年轻代（young gen）：这里的Java对象存活时间非常短，属于经常发生GC的区域</li>
<li>年老代（old gen）：这里的对象是占用内存较大或者是存活时间很长的，一般这里发生的GC就是内存空间真的不足了</li>
<li>永久代（perm gen）：其实这部分内存空间就是JVM内存区域中的<strong>方法区</strong>，里面存放了类的加载信息、静态变量、常量以及代码等信息，这里一般不会发生GC（不代表没有），一般我们所说的GC是不考虑这个区域的</li>
</ul>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收，这部分是JVM关键又重要的一个部分，虽然不需要我们直接参与管理，但一个Java程序员不懂垃圾回收是说不过去的，况且我们可以自由的设置JVM的GC来更好的提高程序运行的性能</p>
<h2 id="什么时候开始GC"><a href="#什么时候开始GC" class="headerlink" title="什么时候开始GC"></a>什么时候开始GC</h2><p>如何开始GC是我刚开始了解GC到一定程度时考虑的东西，毕竟说是说当内存空间不足时JVM便自动开始GC并回收内存区域，但如何得知JVM内存空间够不够呢？<br>查阅资料得知原来JVM对每个对象都有监视对象的监视器，用来监视对象的地址、大小以及使用情况，当该对象已死后，便会对该对象进行回收<br>呐，总结一下发生GC的条件：</p>
<ul>
<li>内存空间不足，又创建新对象并分配内存时</li>
<li>主动调用方法来控制GC</li>
<li>系统配置的某些参数改变，例如系统内存空间不足</li>
</ul>
<h3 id="主动触发GC的方法"><a href="#主动触发GC的方法" class="headerlink" title="主动触发GC的方法"></a>主动触发GC的方法</h3><ul>
<li>对象调用finalize()方法，不保证该方法一定会执行，且最多执行一次</li>
<li>调用System.gc()方法，会触发Full GC</li>
<li>Runtime.gc()</li>
</ul>
<h2 id="如何判断对象“已死”"><a href="#如何判断对象“已死”" class="headerlink" title="如何判断对象“已死”"></a>如何判断对象“已死”</h2><p>如何判断对象“已死”是一个值得说道的地方，正确判断对象是否存货是开始GC的关键。按照常规定义，我们认为一个没有引用指向的对象便是一个已经死去的对象。这里一般有两种方法来判断对象是否还有引用指向：</p>
<ul>
<li>引用计数法：每有一个引用指向该对象，则其引用计数就加一</li>
<li>可达性分析：从GC Roots为起始点开始向下遍历，从引用链搜索引用对象（由JVM自己的监视器来负责）</li>
</ul>
<p>主流的商用语言都采用可达性分析的方法来判断对象是否存活，其实这有一个相对详细的过程，JVM会在对象被会收前进行两次标记，两次标记完成后，该对象才是真正意义上的死亡。</p>
<h3 id="两次标记与对象的复活"><a href="#两次标记与对象的复活" class="headerlink" title="两次标记与对象的复活"></a>两次标记与对象的复活</h3><p>JVM宣告一个对象真正死亡是需要对其进行两次标记的：如果对象经历过可达性分析后没有与GC Roots相连接的引用链，便会对其进行第一次标记，并根据其是否需要执行finalize()方法为条件进行筛选，如果需要执行便会调用finalize()方法，便会被放到一个F-Queue队列中，排队准备执行；如果不需要执行，直接进行第二次标记。</p>
<p>说到执行finalize()方法，这就是对象复活的最后一个机会，只要在执行的方法中重新建立一个引用关联即可。否则会被当作死亡对象进行第二次标记。但JVM不保证finalize()方法执行完毕，所以最好不用这个方法来进行GC，交给JVM管理就好</p>
<p>综上猜想，finalize()方法就是给该对象进行第二次标记并通知JVM回收</p>
<h3 id="可作为GC-Roots的对象"><a href="#可作为GC-Roots的对象" class="headerlink" title="可作为GC Roots的对象"></a>可作为GC Roots的对象</h3><p>阿里的一次面试问到了这里，但当时没有记清楚，所有没有答好</p>
<ul>
<li>虚拟机栈（线程私有栈）中引用的对象</li>
<li>方法区中类的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h3 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h3><p>这个地方也是面试时提到了，但是当时把它跟GC Roots的知识点记混了，尴尬，小哥很nice的说那我们不说这个了（尬笑</p>
<p>HotSot在使用GC Roots的理念时，采用了新的实现方式，因为原来的方式一是任务量大而是GC时间长，因而使用OopMap数据结构来记录栈上不同位置上对象的情况，其本身不存在与栈中，但是保有栈中对象的使用信息。JVM通过查询OopMap就可以得知对象的存活情况</p>
<h2 id="GC使用的算法"><a href="#GC使用的算法" class="headerlink" title="GC使用的算法"></a>GC使用的算法</h2><p>简单说就三种：标记-清理、复制算法和标记-整理算法</p>
<h2 id="GC的回收器"><a href="#GC的回收器" class="headerlink" title="GC的回收器"></a>GC的回收器</h2><p>年轻代：Serial、ParNew和Parallel Scavenge<br>年老代：Serial Old、Parallel Old和CMS<br>JDK1.8正式投入商用的G1</p>
<h1 id="GC的种类"><a href="#GC的种类" class="headerlink" title="GC的种类"></a>GC的种类</h1><p>上面讲过的JVM内存分配机制只是泛泛而谈，算是一个引入，这里再结合内存分配机制与GC来看一下更为具体的内存分配机制</p>
<ul>
<li><strong>monitor GC</strong>：发生在新生代长的GC，（具体的GC过程日后再补</li>
<li><strong>Full GC</strong>：发生在新生代和年老代中的GC，算是对整个活动内存的清理</li>
</ul>
<h2 id="发生Full-GC的条件"><a href="#发生Full-GC的条件" class="headerlink" title="发生Full GC的条件"></a>发生Full GC的条件</h2><h1 id="In-The-End"><a href="#In-The-End" class="headerlink" title="In The End"></a>In The End</h1><p>处理完这个，JVM的垃圾回收机制和内存分配机制就差不多了，本来这个是很久之前就应该写的，现在才补上，主要是觉得blog中JVM这个板块的东西有点少且有一点细节记混了，趁着端午放假，正好把JVM剩下的类加载和并发也都处理处理吧</p>
]]></content>
      
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8新特性]]></title>
      <url>http://yoursite.com/2017/05/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="听说这是一次振奋人心的更新？"><a href="#听说这是一次振奋人心的更新？" class="headerlink" title="听说这是一次振奋人心的更新？"></a>听说这是一次振奋人心的更新？</h1><p>看的某评价，Java8是自Java5以来一次重大的更新，很多细节的东西发生了改变或者是增加了新的特性。那看起来有点棒棒啊</p>
<h1 id="滑稽啊滑稽"><a href="#滑稽啊滑稽" class="headerlink" title="滑稽啊滑稽"></a>滑稽啊滑稽</h1><h1 id="关于Flag"><a href="#关于Flag" class="headerlink" title="关于Flag"></a>关于Flag</h1><p>挖好新坑，函数式编程</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小识字符编码]]></title>
      <url>http://yoursite.com/2017/05/17/%E5%B0%8F%E8%AF%86%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="罗罗嗦的复制粘贴"><a href="#罗罗嗦的复制粘贴" class="headerlink" title="罗罗嗦的复制粘贴"></a>罗罗嗦的复制粘贴</h1><p>以下内容全部来自百度百科</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>字符编码也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），<strong>以便文本在计算机中存储和通过通信网络的传递</strong>。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。</p>
<h1 id="ASCII码："><a href="#ASCII码：" class="headerlink" title="ASCII码："></a>ASCII码：</h1><p>美国(国家)信息交换标准(代)码，一种使用7个或8个二进制位进行编码的方案，最多可以给256个字符(包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值。西文字符集。基本的ASCII 字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。ASCII码使用7位2进制数表示一个字符，7位2进制数可以表示出2的7次方个字符，共128个字符。后期扩展的ASCII码使用8位二进制码，最高位为1。</p>
<h1 id="MBCS码："><a href="#MBCS码：" class="headerlink" title="MBCS码："></a>MBCS码：</h1><p>为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码。</p>
<p>#GB2312码：<br>ANSI编码里的一种，GB 2312是一个简体中文字符集，由6763个常用汉字和682个全角的非汉字字符组成。GB2312编码用两个字节(8位2进制)表示一个汉字，所以理论上最多可以表示256×256=65536个汉字。</p>
<h1 id="GBK码："><a href="#GBK码：" class="headerlink" title="GBK码："></a>GBK码：</h1><p>GBK即汉字内码扩展规范，K为扩展的汉语拼音中“扩”字的声母。GBK编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。GB2312码是中华人民共和国国家汉字信息交换用编码，全称《信息交换用汉字编码字符集——基本集》，采用<strong>双字节编码</strong>。</p>
<h1 id="Unicode码："><a href="#Unicode码：" class="headerlink" title="Unicode码："></a>Unicode码：</h1><p>将世界上所有的符号都纳入其中，无论是英文、日文、还是中文等，大家都使用这个编码表，就不会出现编码不匹配现象。每个符号对应一个唯一的编码，乱码问题就不存在了。这就是Unicode编码。现在的规模可以容纳100多万个符号。有的Unicode编码衍生码使用<strong>四字节编码</strong>，很浪费资源。</p>
<h1 id="UTF-8码："><a href="#UTF-8码：" class="headerlink" title="UTF-8码："></a>UTF-8码：</h1><p>为了提高Unicode的编码效率，于是就出现了UTF-8编码。UTF-8可以根据不同的符号<strong>自动选择编码的长短</strong>。英文字母只需要一个字节即可。</p>
<h1 id="Based64码："><a href="#Based64码：" class="headerlink" title="Based64码："></a>Based64码：</h1><p>电子邮件系统中对于汉字的传输有时候会有乱码问题，为了能让邮件系统正常的收发邮件，需要把由其他编码存储的符号转换成ASCII码来传输，最后接收者也通过转换得到了没有乱码的邮件。比如，在一端发送GB2312编码－&gt;根据Base64规则－&gt;转换成ASCII码，接收端收到ASCII码－&gt;根据Base64规则－&gt;还原到GB2312编码。</p>
<p>PS：Java8正式引入Base64编码作为类库的标准</p>
]]></content>
      
        
        <tags>
            
            <tag> Unicode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zpencheng]]></title>
      <url>http://yoursite.com/2017/05/15/zpencheng/</url>
      <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>这是一篇关于PengCheng的自省，如果是误打误撞的就不用看了，基本是废话，以及一些醉话，或者是不知所言的胡言乱语</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="什么叫做“有趣”"><a href="#什么叫做“有趣”" class="headerlink" title="什么叫做“有趣”"></a>什么叫做“有趣”</h1><h1 id="我想成为什么样的人？"><a href="#我想成为什么样的人？" class="headerlink" title="我想成为什么样的人？"></a>我想成为什么样的人？</h1><h1 id="我想过什么样的生活？"><a href="#我想过什么样的生活？" class="headerlink" title="我想过什么样的生活？"></a>我想过什么样的生活？</h1><p>好吧我错了，我真的真的真的真的真的真的真的真的很想很想很想很想变的牛逼，变得引起别人的注意再装作丝毫不在意的样子去说这不是我想要的，但我现在真的真的真的真的真的很像变强，变的更强，变得更牛逼。至于在那之前说出的我不愿意我不想，都是lowB的我自作矫情而又自我安慰自欺欺人的吱呀。那是我的目标。</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的throw和throws]]></title>
      <url>http://yoursite.com/2017/05/15/Java%E4%B8%AD%E7%9A%84throw%E5%92%8Cthrows/</url>
      <content type="html"><![CDATA[<h1 id="一些稀松平常的操作"><a href="#一些稀松平常的操作" class="headerlink" title="一些稀松平常的操作"></a>一些稀松平常的操作</h1><p>ok，一般每隔一段时间就会清清缓存，或者是拖的有点多了……</p>
<h1 id="Java中的异常"><a href="#Java中的异常" class="headerlink" title="Java中的异常"></a>Java中的异常</h1><p>这是一个要开也能开的坑，但是不是很想操作，一般情况下会使用异常，找出异常并调试bug就行了，当然了有些场景是需要自己自定义适合场景的bug的，这就需要了解一些异常的基本知识</p>
<p>异常的出现多是一些外部原因，比如一些代码中没有注意到的会影响程序运行的细节</p>
<blockquote>
<p>发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
</blockquote>
<p>这里有Java异常类层次结构图：↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/05/15/Java中的throw和throws/exception.jpg" alt="exception"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><code>Thorwable</code>是类不是接口，当初有搞混</li>
<li><code>Error</code>类是程序无法处理的错误，表示运行应用中出现了很严重的问题，不过一般是因为JVM内容出现了问题，这些问题是不需要try-catch的。一般出现了Error，JVM会自动停止运行，然后通过Error的子类来描述出错的类型，比如：<strong>OutOfMemoryError和NoClassDefFoundError</strong></li>
<li><code>Exception</code>类是程序本身（JVM）可以处理的异常，有一个重要的子类<code>RuntimeException</code>及其子类，表示JVM常用操作引发的异常，比如：<strong>空值对象的应用、除数为0和数组越界</strong></li>
<li>错误和异常的区别是：<strong>异常能被程序本身处理，错误是无法处理的</strong></li>
</ul>
<h3 id="可查异常和不可查异常"><a href="#可查异常和不可查异常" class="headerlink" title="可查异常和不可查异常"></a>可查异常和不可查异常</h3><p>这里拓展Exception的一些知识，因为算是难重点易混点</p>
<ul>
<li>可查异常：是编译器要求必须处理的异常，即必须使用<code>try{}catch{}</code>进行捕捉处理。除<code>RuntimeException</code>及其子类外，其它的Exception类及其子类都属于可查异常</li>
<li>不可查异常：包括运行时异常（及其子类）和错误，这里不要求使用<code>try{}catch{}</code>捕捉处理，当然可以选择捕捉处理</li>
</ul>
<h3 id="运行时异常和非运行时异常"><a href="#运行时异常和非运行时异常" class="headerlink" title="运行时异常和非运行时异常"></a>运行时异常和非运行时异常</h3><p>这算是另一种异常的分类方式</p>
<ul>
<li>运行时异常：RuntimeException，顾名思义，运行时才会发生的异常，在敲代码阶段编译阶段是无法发现的，所以即便没有<code>try{}catch{}</code>捕捉处理也会编译通过，比如：<strong>空指针异常和数组下标越界</strong></li>
<li>非运行时异常：也叫编译异常，这个就必须使用<code>try{}catch{}</code>来让程序自行捕捉处理了，否则会不予通过</li>
</ul>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>使用<code>throw</code>和<code>throws</code>来抛出异常</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>其实不过异常有两种，一种是自己编程处理，一种是交给JVM来处理</p>
<ul>
<li>使用<code>try{}catch{}</code>来捕获异常</li>
<li>直接使用<code>throws</code>来不断向上抛出异常，直到抛给JVM执行</li>
</ul>
<h1 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h1><p>其实是从网上瞄来的（滑稽<br>语法是<code>throw(异常对象)</code>，一般用于方法体中，抛出特定类型的异常</p>
<h1 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h1><p>感觉diaodiao的，这个用的做多<br>语法是<code>public void function(var) throws &lt;异常类&gt;</code>，一般跟在方法名的声明后面，直接抛出异常类，然后把异常处理交给上层调用它的程序处理</p>
<h1 id="它们的区别"><a href="#它们的区别" class="headerlink" title="它们的区别"></a>它们的区别</h1><p>卧槽我本来只是看到了两者什么区别，结果又扯了别的。说到区别，一个常用一个基本不用算不算区别（滑稽</p>
<ul>
<li><code>throws</code>出现在方法函数头，而<code>throw</code>出现在方法体中</li>
<li><code>throws</code>表示出现异常的一种可能，实际并不一定会出现异常；而<code>throw</code>则是抛出异常，只要是运行到了这里，就一定会抛出异常</li>
<li>两者都是消极处理异常的方式，只是做到了抛出或肯能抛出异常，真正对异常进行处理还是在上层调用的地方</li>
</ul>
<p><a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">其实这里有更多详细的内容，随用随取</a><br><a href="http://blog.csdn.net/luoweifu/article/details/10721543" target="_blank" rel="external">还有这些，感谢前辈</a></p>
<h1 id="一种熟悉的节奏？"><a href="#一种熟悉的节奏？" class="headerlink" title="一种熟悉的节奏？"></a>一种熟悉的节奏？</h1><p>不知道什么时候起，已经想把自己看到学到的东西通过某种方式记录下来了，或许是自己的记性越来越不好了，又或许真的是已经变成了一种习惯。</p>
<p>没有遇到很多像自己一样喜欢搞一搞Java很底层很细节的东西，（或许自己本身也是被外在事物所影响，但现在确实真心的想搞清楚）每次看到一些很细枝末节的东西而自己又不知道，就会有莫名的兴奋感，细细研究左右对比仔细斟酌。良久，一句“原来是这样”，痛快的拍一下桌子，随口吐槽一句，然后再嚣张的把博文传到网上，整个过程是这么熟悉而又畅快。日后装作随意的点开一看，点击的人数比上次又多了几个，顺便暗爽原来我当时写出这样的东西，但这是发自内心的开心。</p>
<p>啧，话又多了，自己也不明所以。话说，我要去洗袜子了</p>
<p>PS：其实每次问题的出发点都是一个小小的线头，怪我太贪心想要它后面的毛线球？</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring学习笔记-基础]]></title>
      <url>http://yoursite.com/2017/05/08/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="Spring介绍"><a href="#Spring介绍" class="headerlink" title="Spring介绍"></a>Spring介绍</h1><p>spring是一个开源的轻量级JavaEE框架，使用分层架构，主要部分是面向切面编程（AOP）和控制反转（IOC）容器代码的实现。提高复用性和松耦合，具有动态可扩展性</p>
<h1 id="Eclipse和IDEA的项目构建"><a href="#Eclipse和IDEA的项目构建" class="headerlink" title="Eclipse和IDEA的项目构建"></a>Eclipse和IDEA的项目构建</h1><p>Eclipse普遍比Idea要好配置的多</p>
<h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><ul>
<li>新建一个Project，都可以</li>
<li>导入外部的Jar包，组成新的Libraries</li>
<li>如果是Java Web项目还需要把所有的Jar包复制进<code>web/WEB-INF/lib</code>目录下</li>
<li>在<code>src</code>目录下创建<code>applicationContext.xml</code>文件</li>
</ul>
<h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><ul>
<li>创建Java项目，从右边栏中选择Spring4，然后勾上对号</li>
<li>在下方选择Use Libraries，然后选择所需要的Jar包导入成Libraries</li>
<li>一路自由设置</li>
<li>进入项目后在<code>src</code>目录下创建<code>applicationContext.xml</code>文件</li>
<li>为项目配置合适的<code>Artifact</code>、<code>Facets</code>和<code>Modules</code>，就是选选文件配置路径什么的，如果哪里不对或缺失，右下方会有提示，点击<code>fixed</code>就会自动调整了</li>
</ul>
<h1 id="配置文件的组装"><a href="#配置文件的组装" class="headerlink" title="配置文件的组装"></a>配置文件的组装</h1><p>一般来说，xml文件内容配置成这样就通用了<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></div><div class="line">	<span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">	http://www.springframework.org/schema/beans</div><div class="line">	http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</div><div class="line">	http://www.springframework.org/schema/aop</div><div class="line">	http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</div><div class="line">	http://www.springframework.org/schema/tx</div><div class="line">	http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</div><div class="line">	http://www.springframework.org/schema/context</div><div class="line">	http://www.springframework.org/schema/context/spring-context-3.0.xsd</div><div class="line">	http://www.springframework.org/schema/mvc</div><div class="line">	http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd</div><div class="line">	http://www.springframework.org/schema/task</div><div class="line">	http://www.springframework.org/schema/task/spring-task-3.1.xsd"&gt;</div><div class="line">	 </div><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC/DI"></a>IOC/DI</h1><p>IOC：控制反转，有的时候也称为DI，也即依赖注入。可以这样理解：</p>
<blockquote>
<p>IOC容器就是为了管理Bean，创建Bean的一个内存区，在这个内存区中可以将操作Bean的代码以面向接口的方式进行开发。<br>这样基于接口的多态性，程序结构的分层就更加灵活化，维护和扩展也很方便。IOC概念从技术上来讲就是将接口和实现相分离</p>
</blockquote>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p>通过IOC容器可以完全管理JavaBean，包括创建、销毁，还可以对数据库的JavaBean进行自动化的事务处理，还支持一些企业级的应用。Spring的IOC容器完全脱离了平台，用最简单的JavaBean技术实现接口与实现的分离，并对组件的调配提供很好的支持</p>
<p>下面开始操作：</p>
<h2 id="先准备一个JavaBean"><a href="#先准备一个JavaBean" class="headerlink" title="先准备一个JavaBean"></a>先准备一个JavaBean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>经过实验发现，如果变量的getter和setter方法命名不规范，在程序运行时会出错。所以建议遵守<br><code>set+Variale_name</code>和<code>get+Variable_name</code>来命名getter和setter方法</p>
<h2 id="再在applicationContext-xml文件中添加Bean配置"><a href="#再在applicationContext-xml文件中添加Bean配置" class="headerlink" title="再在applicationContext.xml文件中添加Bean配置"></a>再在applicationContext.xml文件中添加Bean配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">....</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"cate"</span> <span class="attr">class</span>=<span class="string">"pojo.Category"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"hellosocra"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里需要讲解一下配置的细节：</p>
<ul>
<li>首先是<bean>标签中的<code>name</code>属性，这里就是创建一个名为cate的CategoryBean对象</bean></li>
<li>xml配置文件中<bean>标签的id属性和name属性基本上没有什么区别，但是使用id会更加符合规范，因为xml中id要求是唯一的</bean></li>
<li><code>class</code>属性的值就是CategoryBean.java的路径，要加上包名</li>
<li><property>标签是为了给对象cate中的属性赋值的，这里会自动调用变量的getter和setter方法进行赋值，如果命名不规范，就无法赋值</property></li>
<li><code>name</code>对应着cate的属性名，<code>value</code>就是赋值，本例赋予了name属性的值是hellosocra</li>
<li><property>中还可以使用<code>ref</code>来给属性值进行链接，然后使用链接处的值，这也是注入值的过程</property></li>
</ul>
<h2 id="使用注入的对象"><a href="#使用注入的对象" class="headerlink" title="使用注入的对象"></a>使用注入的对象</h2><p>既然已经添加了注入对象的配置，现在看看如何使用注入的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1.必备的语句，可以定义为全局变量 </span></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</div><div class="line">                <span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</div><div class="line"> 		</div><div class="line"> 		<span class="comment">// 2.开始使用IOC的getBean()方法来获取对象，但要主要强制类型转换</span></div><div class="line">        Category cate = (Category) context.getBean(<span class="string">"cate"</span>);</div><div class="line">        <span class="comment">// 3.使用Bean对象的方法</span></div><div class="line">        System.out.println(cate.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="注解方式配置IOC"><a href="#注解方式配置IOC" class="headerlink" title="注解方式配置IOC"></a>注解方式配置IOC</h2><p>如同在学习Servlet时使用注解配置一样，这里也可使用注解配置，有下面两种</p>
<h3 id="针对“注入对象行为”的注解"><a href="#针对“注入对象行为”的注解" class="headerlink" title="针对“注入对象行为”的注解"></a>针对“注入对象行为”的注解</h3><p>下面说的这种方式都是主要针对其中一个JavaBean是另一个JavaBean的属性时的注入</p>
<ul>
<li>注释之前对对象的属性的注入的配置（配置对象是注入，给对象的属性赋值同样是注入）</li>
<li>添加<code>&lt;context:annotation-config/&gt;</code>表示spring要采用注解的方式进行配置</li>
<li>在要注入对象的对应属性前加上<code>@Autowired</code>注解，或者在对应属性的setter方法前加上<code>@Autowired</code>注解</li>
<li>在要注入对象中的属性（另外的JavaBean充当该bean的属性）前加上<code>@Resource(xxx=xxx)</code>注解，举个例子<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABean</span></span>&#123;</div><div class="line">  String name ;</div><div class="line">  <span class="keyword">int</span> id;</div><div class="line">  <span class="comment">// ....getter和setter方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBean</span></span>&#123;</div><div class="line">  <span class="meta">@Resource</span>(name=<span class="string">"socra"</span>,id=<span class="number">5</span>)</div><div class="line">  A a; <span class="comment">// A作为B的属性</span></div><div class="line">  <span class="keyword">int</span> no;</div><div class="line">  <span class="comment">// ....getter和setter方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="针对“Bean”的注解"><a href="#针对“Bean”的注解" class="headerlink" title="针对“Bean”的注解"></a>针对“Bean”的注解</h3><p>同样的，下面说的这种方式都是主要针对其中一个JavaBean是另一个JavaBean的属性时的注入</p>
<ul>
<li>在xml文件中把<beans>标签中所有的<bean>标签都注释掉</bean></beans></li>
<li>添加<code>&lt;context:componment-scan base-backage=&quot;JavaBean所在的包以及Bean名&quot;&gt;</code>，表示spring所需要的Bean都在该路径下</li>
<li>再在该包下所有的Bean类定义之前加上<code>@Compent(&quot;name&quot;)</code>，表名该类是Bean，<code>name</code>是要被注入的该Bean类的对象名</li>
<li>若有一个类是另一个类的属性，则在该属性前加上<code>@Autowired</code>注解</li>
<li>其余的属性可以自由赋值</li>
</ul>
<h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><p>传统的创建对象的方式：通过new关键字来创建一个对象<br>IOC方式：对象的声明周期由Spring来管理，直接从Spring那里获取一个对对象。IOC是反转控制，意即本来对象的控制权在使用者手里，现在反过来交给了Spring</p>
<blockquote>
<p>打个比喻：<br>传统方式：相当于你自己去菜市场new 了一直鸡，但是是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。<br>IOC：相当于去馆子(Spring)点了一直 鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。</p>
</blockquote>
<p>解释的生动传神，（滑稽<br><img src="/2017/05/08/Spring学习笔记-基础/ioc.png" alt="ioc"></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP：面向切面编程，意即面向一小段代码编程。AOP把功能分为核心功能和周边功能，而周边功能在Spring的AOP思想里就被定义为切面Aspect。这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程。<br>所谓AOP思想就是两种功能分别独立开发，然后再“编织”在一起</p>
<blockquote>
<p>AOP可以在不改变原始代码的基础上做一些功能性的增强</p>
</blockquote>
<p>需要额外的Jar包：<code>aspect.jar</code>和<code>aopliance.jar</code></p>
<h2 id="准备一个核心业务Bean和切面辅助Bean"><a href="#准备一个核心业务Bean和切面辅助Bean" class="headerlink" title="准备一个核心业务Bean和切面辅助Bean"></a>准备一个核心业务Bean和切面辅助Bean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 作为核心业务Bean</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span></span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomeService</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"dosomeService"</span>);</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 作为切面辅助Bean</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerAspect</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">log</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</div><div class="line">		Object obj = <span class="keyword">null</span>;</div><div class="line">		System.out.println(<span class="string">"start log: "</span> + joinPoint.getSignature().getName());</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			obj = joinPoint.proceed();<span class="comment">// 继续执行，本例指执行dosomeService()</span></div><div class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"end log: "</span> + joinPoint.getSignature().getName());</div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">....</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 1.声明核心业务对象 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"s"</span> <span class="attr">class</span>=<span class="string">"service.ProductService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 2.声明辅助日志切面 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loggerAspect"</span> <span class="attr">class</span>=<span class="string">"aspect.LoggerAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 5.通过aop:config把业务对象与辅助功能编制在一起 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- 3.指定核心业务功能 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"loggerCutpoint"</span></span></div><div class="line">			<span class="attr">expression</span>=</div><div class="line">			<span class="string">"execution(* service.ProductService.*(..))"</span>/&gt;</div><div class="line">		<span class="comment">&lt;!-- 4.指定辅助功能 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAspect"</span> <span class="attr">ref</span>=<span class="string">"loggerAspect"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">"loggerCutpoint"</span> <span class="attr">method</span>=<span class="string">"log"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>首先要规定好核心业务Bean还有切面辅助Bean，设置好它们的对象名以及路径</li>
<li><aop>标签有指定好核心业务和切面辅助入口，<code>id</code>属性都是对象名</aop></li>
<li><aop:point>中的<code>expression</code>属性的一般值为<code>execution(* package_name.Bean_name.*(..))</code>，表示核心业务Bean中的方法入口（核心业务中可以不止一个方法）</aop:point></li>
<li><aop:aspect>标签中<code>id</code>被注入了值，<code>pointcut-ref</code>属性指定了辅助切面辅助的对象，<code>method</code>是调用辅助切面中的辅助方法</aop:aspect></li>
</ul>
<p>至此已经设置好了切面辅助，当从上到下，先执行核心业务功能后执行辅助业务</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>因为使用AOP，使用时和没有加入切面时的步骤是一样的，正因为如此也体现了AOP的优越特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		ApplicationContext apc = <span class="keyword">new</span> </div><div class="line">				ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</div><div class="line">		</div><div class="line">		ProductService s = (ProductService)apc.getBean(<span class="string">"s"</span>);</div><div class="line">		s.dosomeService();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AOP更高级的用法"><a href="#AOP更高级的用法" class="headerlink" title="AOP更高级的用法"></a>AOP更高级的用法</h2><p>本来是想直接在这次写上的，但是，还是下次和IOC的高级用法写在一起吧，算偷个懒挖个坑。<br>哦，当然了，AOP的注释写法也下次再写好了233333</p>
<h1 id="久违了"><a href="#久违了" class="headerlink" title="久违了"></a>久违了</h1><p>准备了很久的JavaEE学习，现在终于提上了日程，随便也要把之前遗漏的Servlet和Jsp准备准备填坑了</p>
<p>呐现在挖坑：Servlet学习总结笔记、Jsp总结笔记、Spring更为高级的用法etc</p>
<p>PS：首先还是总结这几个框架任意组合的配置方法，idea配置起来真的麻烦啊….F__k</p>
]]></content>
      
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java泛型详解]]></title>
      <url>http://yoursite.com/2017/05/07/Java%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="为什么要来再详究一遍泛型"><a href="#为什么要来再详究一遍泛型" class="headerlink" title="为什么要来再详究一遍泛型"></a>为什么要来再详究一遍泛型</h1><p>当初学习Java时并没有觉得这个有多重要，又不像C++，我有现成的集合框架可以使用，我管你泛型干吗，（滑稽<br>现在慢慢的学到了JavaEE的一些知识，所起来，框架中的原理知识除了有<a href="http://zpcheng.me/2017/03/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/#more" target="_blank" rel="external">Java的反射机制</a>，还大量的用到了泛型的知识，随便点开一个方法的源码，很容易发现有泛型的痕迹。但是仔细一想，这点似乎并没有搞清楚，所以</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>RT，本次讨论的主要目标，泛型。为了节省时间，一下的研究主要内容来自<a href="http://www.cnblogs.com/lwbqqyumidi/p/3837629.html" target="_blank" rel="external">先驱者的博文指导</a>，所以可以算是转载，侵删</p>
<h1 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h1><p>这个探讨的节奏深得我心啊，先说是不是，再问为什么（滑稽<br>先看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 主要是为了深入了解学习 泛型</div><div class="line"> * NewPrint类是写的简化输出的工具类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> <span class="keyword">extends</span> <span class="title">NewPrint</span></span>&#123;</div><div class="line">	List list = <span class="keyword">new</span> ArrayList();</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">		list.add(<span class="string">"hello"</span>);</div><div class="line">		list.add(<span class="number">100</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</div><div class="line">			<span class="comment">// 再取第二个值时会出异常 java.lang.ClassCastException</span></div><div class="line">			String name = (String)list.get(i);</div><div class="line">			println(<span class="string">"name: "</span>+name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试运行时会报出异常<code>java.lang.ClassCastException</code>，这是类型不匹配的异常。List默认的类型是Object类型的，什么类型的对象都可以往里面装。装入时是<code>Integer</code>类型的然后强制转为String类型自然会出错<br>从上面可以看出两个问题：</p>
<ul>
<li>当一个对象放入集合中时，集合并不会记住这个对象本来的类型；当该对象从集合中取出时，它的编译类型就变成了Object类型，但运行时还是会按照其本来的类型运算（这就是为什么编译时不会报错，允许强制转换，运行时却出异常的原因）</li>
<li>当从一个集合中取出对象时，因为可能不知道其真实类型而去强制转换，这是很容易触发<code>java.lang.ClassCastException</code></li>
</ul>
<p>所以就有了这么 一个需求：<strong>如何可以使集合“记住”元素的类型，并在运行时不会出现java.lang.ClassCastException的异常呢？</strong></p>
<h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><blockquote>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
</blockquote>
<p>简单说就是<strong>将一个类型当作参数传入另一个接口/类/方法的参数</strong></p>
<p>于是将上面代码改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> <span class="keyword">extends</span> <span class="title">NewPrint</span></span>&#123;</div><div class="line">	List&lt;String&gt; newl = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNewList</span><span class="params">()</span></span>&#123;</div><div class="line">		newl.add(<span class="string">"hello"</span>);</div><div class="line">		<span class="comment">// 这里会直接拒绝加入Integer类型的元素</span></div><div class="line">		<span class="comment">//newl.add(100);</span></div><div class="line">		newl.add(<span class="string">"scora"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newl.size();i++)&#123;</div><div class="line">			<span class="comment">// 再取第二个值时会出异常 java.lang.ClassCastException</span></div><div class="line">			String name = newl.get(i);</div><div class="line">			println(<span class="string">"name: "</span>+name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用泛型写法后，当想插入非String类型的对象时就会直接提示出错，同时当从集合中取值时也没有必要强制类型转换。<br>可以得知在List<string>中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。<br>看一看List的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    Object[] toArray();</div><div class="line"></div><div class="line">    &lt;T&gt; T[] toArray(T[] a);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p>
<p>在List接口中采用泛型化定义之后，<e>中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。<br>注意一下这两个常用的方法：</e></p>
<ul>
<li><code>boolean add(E e);</code></li>
<li><code>E get(int index);</code></li>
</ul>
<p>第一个方法一定需要<e>类型的参数，第二个方法一定会返回一个<e>类型的对象，这也就解释了上面为什么add加入一个非String类型的值会直接提示出错，为什么从集合中取值不再需要强制类型转换。<br>当然了，这只是List接口的定义，ArrayList实现类既然实现了List，那么一定会重写add()方法和get()方法，所以其也是需要<e>类型的参数的</e></e></e></p>
<h1 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h1><p>谈完了什么是泛型，按照我的节奏，我一般都会去想一想使用它的好处都有什么</p>
<ul>
<li>类型安全：在使用时对一个对象进行了限制，只有约定类型的对象才能继续，编译器在编译时期也可以进行类型检查</li>
<li>避免强制类型转换：因为前面已经约束了类型，所以在使用时就已知了类型，便省去了类型转换的过程，使得代码更加可读，也减少了出错的机会</li>
<li>潜在的性能收益：泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。</li>
</ul>
<h1 id="泛型类、泛型接口和泛型方法"><a href="#泛型类、泛型接口和泛型方法" class="headerlink" title="泛型类、泛型接口和泛型方法"></a>泛型类、泛型接口和泛型方法</h1><p>大概知晓了泛型的知识，来看看我们如何使用泛型：</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">	<span class="keyword">private</span> E e;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(E e)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.e = e;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setE</span><span class="params">(E e)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.e = e;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> e;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericityClass</span> <span class="keyword">extends</span> <span class="title">NewPrint</span></span>&#123;</div><div class="line">	A&lt;String&gt; a = <span class="keyword">new</span> A&lt;String&gt;(<span class="string">"socra"</span>);</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</div><div class="line">		println(a.getE());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？"><a href="#对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？" class="headerlink" title="对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？"></a>对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericityType</span><span class="params">()</span></span>&#123;</div><div class="line">	A&lt;String&gt; str = <span class="keyword">new</span> A&lt;String&gt;(<span class="string">"socra"</span>);</div><div class="line">	A&lt;Integer&gt; no = <span class="keyword">new</span> A&lt;Integer&gt;(<span class="number">10</span>);</div><div class="line">	</div><div class="line">	println(str.getClass()); <span class="comment">// class Genericity.A</span></div><div class="line">	println(no.getClass()); <span class="comment">// class Genericity.A</span></div><div class="line">	System.out.println(str.getClass()==no.getClass()); <span class="comment">// true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果竟不是预料的，原以为在编译时，编译器会将所有的泛型擦除变成其真实的类型，但现在看来似乎不是这样</p>
<blockquote>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。<br>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦除，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。<br>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
</blockquote>
<p>很奇怪，不是吗？（《Think in Java》P372之后的章节有详述</p>
<h3 id="泛型中“擦除”"><a href="#泛型中“擦除”" class="headerlink" title="泛型中“擦除”"></a>泛型中“擦除”</h3><p>一个很玄学的东西：<strong>Java泛型中的具体类型信息在运行时都被擦除了，而被当作泛型类型的对象去使用</strong>。（在泛型代码内部是无法获取任何有关泛型参数类型的信息）</p>
<blockquote>
<p>在基于擦除的实现中，泛型类型被当作第二类类型被处理（没有具体化），即不能在某些重要的上下文中使用的类型。泛型类型只有在静态类型检查期间才会出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如，List<t>这样的类型注解被擦除为List，而普通的类型变量类型在未指定边界的情况下将被擦除为Object</t></p>
</blockquote>
<p>那么问题来了，我们是如何得知泛型中参数类型的呢？毕竟我们在运行时还需要检查其类性呢<br>首先在编写代码时进行检查就容易实现了，编辑器自动检测泛型类型是否一致，下面来看看编译运行时的检测办法：<br>首先是一点不使用泛型的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Object obj;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.obj = obj;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.obj = obj;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	&#125;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	A a = <span class="keyword">new</span> A();</div><div class="line">	a.setObject(<span class="string">"socra"</span>);</div><div class="line">	String str = (String)a.getObject();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反编译后查看其字节码发现：<br><img src="/2017/05/07/Java泛型详解/test2.jpg" alt="test2"><br>注意红线画到的地方</p>
<p>接下来看同样操作使用泛型的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">		<span class="keyword">private</span> E e;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;	&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(E e)</span></span>&#123;</div><div class="line">			<span class="keyword">this</span>.e = e;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setE</span><span class="params">(E e)</span></span>&#123;</div><div class="line">			<span class="keyword">this</span>.e = e;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> e;</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		A&lt;String&gt; a = <span class="keyword">new</span> A&lt;String&gt;();</div><div class="line">		a.setE(<span class="string">"socra"</span>);</div><div class="line">		String str = a.getE();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样反编译查看字节码可以发现：<br><img src="/2017/05/07/Java泛型详解/test.jpg" alt="test1"><br>可以看到两者的字节码是一样的，然后注意到<code>checkcast</code>这个部分，这是检查类型的语句，事实上这才是关键所在。<br><strong>编译时擦除了泛型的参数类型信息，在编译时在边界地方开始检查类型</strong>，所谓边界就是对象进入和离开的地方。</p>
<ul>
<li>在实例一中，会在强制转型的地方开始检测参数类型；</li>
<li>在实例二中，会在调用getObject()方法处检查参数类型</li>
</ul>
<p>综上，我们知道为什么泛型可以知道参数类型信息了（先擦除后检查类型，毕竟泛型的主要目的之一就是希望将错误检测移入到编译期</p>
<h3 id="泛型中的边界"><a href="#泛型中的边界" class="headerlink" title="泛型中的边界"></a>泛型中的边界</h3><p>边界可以在泛型的参数类型上设置限制条件，例如<code>class A&lt;T extends B&gt;</code>，表示的意思就是<strong>参数类型必须是B类型或者是继承自B的子类</strong>。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>看过了上面泛型类的例子，就知道泛型接口就是接口有参数类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setE</span><span class="params">(E e)</span></span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewB</span> <span class="keyword">implements</span> <span class="title">B</span>&lt;<span class="title">String</span>&gt;</span>&#123;</div><div class="line">	<span class="comment">// 泛型接口中的泛型对象定义在实现类中</span></div><div class="line">	String name ;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setE</span><span class="params">(String str)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = str;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="注意接口声明的小细节"><a href="#注意接口声明的小细节" class="headerlink" title="注意接口声明的小细节"></a>注意接口声明的小细节</h3><ul>
<li>接口的默认访问修饰符是protected</li>
<li>接口中的属性只能是static或final修饰的已知类型的对象，同时接口中不允许声明构造方法</li>
<li>泛型对象需要在实现类中定义</li>
</ul>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>关注到这个是因为学到了hibernate中的某一个方法，看一看<a href="http://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html" target="_blank" rel="external">Java中的泛型方法</a>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 泛型方法</div><div class="line"> * &lt;T&gt; 用来声明该方法为泛型方法</div><div class="line"> * <span class="doctag">@param</span> t 参数类型对象</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">display</span><span class="params">(T t)</span></span>&#123;</div><div class="line">	println(<span class="string">"hello，这里是泛型方法"</span>);</div><div class="line">	<span class="keyword">return</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDisplay</span><span class="params">()</span></span>&#123;</div><div class="line">	String name = <span class="string">"socra"</span>;</div><div class="line">	String name2 = display(name);</div><div class="line">	println(name2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里还有dalao提供的进阶版泛型方法，当然了，框架中使用的泛型方法就是这种类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基于反射的泛型方法</div><div class="line"> * Class&lt;T&gt; 声明泛型的T的具体类型</div><div class="line"> * <span class="doctag">@param</span> t 是泛型T类的需要被代理的对象</div><div class="line"> * <span class="doctag">@return</span> 实例化的代理对象</div><div class="line"> * <span class="doctag">@throws</span> IllegalAccessException  安全权限异常</div><div class="line"> * <span class="doctag">@throws</span> InstantiationException  实例化异常</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getObject</span><span class="params">(Class&lt;T&gt; t)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span>&#123;</div><div class="line">	T newt = t.newInstance(); <span class="comment">// 基于反射创建对象</span></div><div class="line">	<span class="keyword">return</span> newt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h1><p>从上面的例子中，可以得知A<string>和A<integer>其实还是一种类型，那么能否将这两种类型看作是与A类型有关系的父子类型呢？<br>这里就需要有一个引用类型，用来在逻辑上表示形如A<string>和A<integer>父类的引用类型。这就引出了我们的关注焦点——类型统配符。</integer></string></integer></string></p>
<h2 id="神奇的-‘-’"><a href="#神奇的-‘-’" class="headerlink" title="神奇的 ‘?’"></a>神奇的 ‘?’</h2><p>java中类型通配符一般是使用<code>?</code>代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且A&lt;?&gt;在逻辑上是A<integer>、A<string>…等所有A&lt;具体类型实参&gt;的父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aPrintln</span><span class="params">(A&lt;?&gt; a)</span></span>&#123;</div><div class="line">	println(a.getE());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="comment">// 用以测试通配符</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildcard</span><span class="params">()</span></span>&#123;</div><div class="line">	A&lt;String&gt; str = <span class="keyword">new</span> A&lt;String&gt;(<span class="string">"socra"</span>);</div><div class="line">	A&lt;Integer&gt; no = <span class="keyword">new</span> A&lt;Integer&gt;(<span class="number">10</span>);</div><div class="line">	</div><div class="line">	aPrintln(str); <span class="comment">// socra</span></div><div class="line">	aPrintln(no); <span class="comment">// 10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></string></integer></p>
<p>可以看到将A&lt;?&gt;当作A<string>和A<integer>的父类然后直接传入参数，利用多态特性完成输出</integer></string></p>
<h2 id="通配符的上下界"><a href="#通配符的上下界" class="headerlink" title="通配符的上下界"></a>通配符的上下界</h2><p>其实这是泛型边界的定义，上文也有说到，但边界也可用于通配符中</p>
<ul>
<li>类型通配符上界：<code>&lt;? extends T&gt;</code>，必须是T类或者其子类</li>
<li>类型通配符下界：<code>&lt;? super E&gt;</code>，必须是E类或者是E类的父类</li>
</ul>
<h2 id="泛型数组？"><a href="#泛型数组？" class="headerlink" title="泛型数组？"></a>泛型数组？</h2><p>不存在的，Java中没有泛型数组这么一说，所有想用到泛型数组的地方都可以使用<code>List&lt;E&gt;</code>来代替</p>
<h1 id="话尾"><a href="#话尾" class="headerlink" title="话尾"></a>话尾</h1><p>一不小心怎么研究了这么多，前前后后加上翻书查资料加上做做小实验，4个小时+应该是有的，不敢说翻了个底朝天，掌握大部分应该是有的。<br>其实很喜欢这种状态。<br>当然了，对Java掌握的越深越好啊  :-)，还是那句话，先狗后人</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java变量的默认初始化]]></title>
      <url>http://yoursite.com/2017/05/07/Java%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="变量的默认初始化"><a href="#变量的默认初始化" class="headerlink" title="变量的默认初始化"></a>变量的默认初始化</h1><p>Java是会为类的成员变量提供默认初始化的，但是又听说局部变量不会提供默认的初始化，是这样吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVariable</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> id;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">char</span> c;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">byte</span> by;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">float</span> f;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">double</span> d;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> bo;</div><div class="line">	</div><div class="line">	<span class="comment">// 再次说明了局部变量只能有final修饰符，static都不行</span></div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testV</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> no;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> no2;</div><div class="line">		</div><div class="line">		System.out.println(id); <span class="comment">// 0</span></div><div class="line">		System.out.println(name); <span class="comment">// null</span></div><div class="line">		System.out.println(c); <span class="comment">// 空字符</span></div><div class="line">		System.out.println(by); <span class="comment">// 0</span></div><div class="line">		System.out.println(f); <span class="comment">// 0.0</span></div><div class="line">		System.out.println(d); <span class="comment">// 0.0</span></div><div class="line">		System.out.println(bo); <span class="comment">// false</span></div><div class="line">		<span class="comment">// 局部变量没有初始化，编译就报错</span></div><div class="line"><span class="comment">//		System.out.println(no);</span></div><div class="line"><span class="comment">//		System.out.println(no2);</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果男默女泪，编译时就出错了</p>
<h1 id="类的成员属性的默认初始化"><a href="#类的成员属性的默认初始化" class="headerlink" title="类的成员属性的默认初始化"></a>类的成员属性的默认初始化</h1><p>结论是会为类的普通属性成员初始化</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h2><ul>
<li>int: 0</li>
<li>char: 空字符</li>
<li>byte: 0</li>
<li>float: 0.0</li>
<li>double: 0.0</li>
<li>short: 0</li>
<li>long：0</li>
<li>boolean: false</li>
</ul>
<h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>String: <code>null</code><br>Other Object: <code>null</code></p>
<h1 id="局部成员的默认初始化"><a href="#局部成员的默认初始化" class="headerlink" title="局部成员的默认初始化"></a>局部成员的默认初始化</h1><p>局部变量并不会默认的初始化，而是在<strong>编译时就直接报错</strong>！！！</p>
<h2 id="局部变量的修饰符"><a href="#局部变量的修饰符" class="headerlink" title="局部变量的修饰符"></a>局部变量的修饰符</h2><p>局部变量不允许使用修饰符，只能使用<code>final</code>,<code>static</code>都不行</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内部类探讨]]></title>
      <url>http://yoursite.com/2017/05/07/Java%E5%86%85%E9%83%A8%E7%B1%BB%E6%8E%A2%E8%AE%A8/</url>
      <content type="html"><![CDATA[<h1 id="默认的访问修饰符"><a href="#默认的访问修饰符" class="headerlink" title="默认的访问修饰符"></a>默认的访问修饰符</h1><p>最初的发现是遇到了一个疑问，Java中类、接口、内部类、抽象类中属性方法的默认访问修饰符是什么？<br>稍微查了查资料</p>
<ul>
<li>普通类默认的访问修饰符是：default，也即包内友好</li>
<li>接口中的属性的默认是public static final ，方法是public abstract</li>
<li>内部类默认的访问修饰符是：public，只是要依附与外围类</li>
<li>抽象类默认的访问修饰符是：default</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>Java中外围类、接口、抽象类的访问修饰符只能是public和default</p>
<h1 id="成员内部类访问修饰权限的测试"><a href="#成员内部类访问修饰权限的测试" class="headerlink" title="成员内部类访问修饰权限的测试"></a>成员内部类访问修饰权限的测试</h1><p>这里还可以看一看如何实例化成员内部类，（滑稽</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>包<code>InPackage</code>中有一个<code>OutClass</code>，里面有一个内部类<code>InClass</code>作为成员变量</li>
<li>同一个包下有一个测试类<code>InPackage_OutClass</code></li>
<li>不在同一个包下有一个测试类<code>OutPackage_OutClass</code></li>
</ul>
<h2 id="成员内部类的实例化方法"><a href="#成员内部类的实例化方法" class="headerlink" title="成员内部类的实例化方法"></a>成员内部类的实例化方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">OutClass.InClass in = <span class="keyword">new</span> OutClass.InClass(); <span class="comment">//只有在内部类中的外围类中可以使用</span></div><div class="line"></div><div class="line"><span class="comment">// 1.通用</span></div><div class="line">OutClass.InClass in2 = <span class="keyword">new</span> OutClass().new InClass();</div><div class="line"><span class="comment">// 2.通用</span></div><div class="line">OutClass out = <span class="keyword">new</span> OutClass();</div><div class="line">OutClass.InClass in3 = out.new InClass();</div></pre></td></tr></table></figure>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>测试的方法就是看能否实例化成员内部类对象</p>
<ul>
<li><p>首先是直接在外围类中测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * public &gt; protected &gt; default &gt; private</div><div class="line"> * private 不能修饰外部类</div><div class="line"> * protected 不能修饰外部类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">// 作为成员内部类,内部类拥有其外围类的所有成员的访问权</span></div><div class="line">	<span class="comment">// 不加修饰符的情况下，其修饰符是 default</span></div><div class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InClass</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">//public static int id; // static变量违法</span></div><div class="line">		</div><div class="line">		<span class="comment">// 内部类不能有static方法，因为内部类必须依赖与外部类存在</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"this inner class"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInClass</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">// 1.成员内部类的一种初始化方法</span></div><div class="line">		InClass in = <span class="keyword">new</span> InClass();</div><div class="line">		in.print();</div><div class="line">		<span class="comment">// 2.成员内部类的另一种初始化方法</span></div><div class="line">		OutClass.InClass in2 = <span class="keyword">new</span> OutClass().new InClass();</div><div class="line">		in2.print();</div><div class="line">		</div><div class="line">		<span class="comment">// 3.使用外部类绑定来初始化</span></div><div class="line">		OutClass out = <span class="keyword">new</span> OutClass();</div><div class="line">		OutClass.InClass in3 = out.new InClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 4.当内部类是static修饰时可以使用这个初始化方式</span></div><div class="line">		<span class="comment">//InClass in4 = new OutClass.InClass();</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着是“同包不同类”中实验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 该类旨在测试同一个包下，是否可以访问内部类</div><div class="line"> * </div><div class="line"> * 所以访问权限是，只有依附与外部类，内部类是可以访问的；但无法直接访问，即便是public也不行</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InPackage_OutClass</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInClass</span><span class="params">()</span></span>&#123;</div><div class="line">		OutClass out = <span class="keyword">new</span> OutClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 1.同一个包的情况下，可以访问内部类</span></div><div class="line">		OutClass.InClass in = <span class="keyword">new</span> OutClass().new InClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 不使用.new便无法初始化对象</span></div><div class="line">		<span class="comment">//		OutClass.InClass in2 = new OutClass.InClass(); // 在内部类的外围类中可以使用该初始化方法</span></div><div class="line">		</div><div class="line">		<span class="comment">// 2.使用外部类对象绑定初始化内部类</span></div><div class="line">		OutClass.InClass in3 = out.new InClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 在同一个包的情况下，可以直接导入，但原理还是与上面一致</span></div><div class="line">		InClass in4 = out.new InClass();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接着是“不同包不同类”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 本例旨在测试不在同一个包的情况下，默认修饰的内部类的访问权限</div><div class="line"> * </div><div class="line"> * 所以访问权限是，只有依附与外部类，内部类是可以访问的；但无法直接访问</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutPackage_OutClass</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInClass</span><span class="params">()</span></span>&#123;</div><div class="line">		OutClass out = <span class="keyword">new</span> OutClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 1.该方法继承或不继承都可以使用</span></div><div class="line">		 OutClass.InClass in = <span class="keyword">new</span> OutClass().new InClass();</div><div class="line">		</div><div class="line">		<span class="comment">// 2.外围类对象绑定的方法可以初始化</span></div><div class="line">		OutClass.InClass in2 = out.new InClass();</div><div class="line">		<span class="comment">// 该方法与上述原理一样</span></div><div class="line">		InClass in3 = out.new InClass(); <span class="comment">// 不行</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>从上面的实验可以看出，成员内部类的默认访问修饰符是public，这个public其实是指在依赖于外部类的情况下来看这个内部类其实是public的（其实一开始认为是default，直到发现没有继承时也可通过外围类进行实例化…….）</p>
<h3 id="有疑问的地方"><a href="#有疑问的地方" class="headerlink" title="有疑问的地方"></a>有疑问的地方</h3><p>其实上述的结论是不敢确定的，因为还看到了这个：<a href="http://www.cnblogs.com/mr-long/p/5885306.html" target="_blank" rel="external">Java内部类与访问修饰符</a><br>所以，真相究竟是什么？ (ㄒoㄒ)</p>
<h2 id="成员内部类的用途"><a href="#成员内部类的用途" class="headerlink" title="成员内部类的用途"></a>成员内部类的用途</h2><p>其实一旦观察到了这个知识点，总是很容易会想到用途这个实际的东西（…….)，看了看《Think In Java》，里面有这么一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Context</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内部类的主要用途是在类向上转型（接口）时隐藏实现细节</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassApplication</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InClass</span> <span class="keyword">implements</span> <span class="title">Context</span></span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">			System.out.println(<span class="string">"我是实现接口的成员内部类"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InClass();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInClassApplication</span><span class="params">()</span></span>&#123;</div><div class="line">		InnerClassApplication icap = <span class="keyword">new</span> InnerClassApplication();</div><div class="line">		icap.getContext().print();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解释一下就是，使用内部类实现一个接口或者继承一个基类，然后向上转型可以隐藏实现的细节</p>
<h1 id="再来看看其它的内部类"><a href="#再来看看其它的内部类" class="headerlink" title="再来看看其它的内部类"></a>再来看看其它的内部类</h1><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>首先来看为什么要这样用，无非是有这样的需求：</p>
<ul>
<li>实现了某类型的接口，然后隐藏实现返回接口的实例化对象</li>
<li>希望有一个非公共的类来完成某些特殊的任务<h3 id="普通局部内部类"><a href="#普通局部内部类" class="headerlink" title="普通局部内部类"></a>普通局部内部类</h3>定义在一个方法中，作用域就是该方法，相较于成员内部类，就是直接把类放入了方法体中<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3>这个就有说头了，匿名就是类没有名字，由JVM自动分配一个特殊助记名<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">public</span> Context <span class="title">getContextFromNoNameClass</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Context()&#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">				System.out.println(<span class="string">"我是隐式实现了接口的匿名内部类"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNoNameInClass</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">// 可以看到的是尽管没有显式的实现Context接口，但还是重写了print()方法</span></div><div class="line">		<span class="keyword">this</span>.getContextFromNoNameClass().print();</div><div class="line">		</div><div class="line">		System.out.println(<span class="keyword">this</span>.getContextFromNoNameClass().getClass());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个内部类的类名是<code>class InnerClass.InnerClassApplication$1</code>，重点是<code>$1</code>，这个就是JVM给匿名内部类分配的助记符</p>
<h3 id="匿名内部类的一些注意"><a href="#匿名内部类的一些注意" class="headerlink" title="匿名内部类的一些注意"></a>匿名内部类的一些注意</h3><p><strong>匿名类不可以改变外围类中的属性</strong>，所以当在匿名内部类中使用外部类对象时，会要求这个外围类对象加上<code>final</code>修饰符</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>说白了就是给成员内部类加上了<code>static</code>的修饰符，这意味着</p>
<ul>
<li>要创建嵌套类的对象并不需要依附与外围类（长能耐了）</li>
<li>不能从嵌套类的对象中访问到非静态的外围类对象</li>
<li>同时可以使用<code>InClass in = new OutClass.InClass();</code>这种实例化方法</li>
</ul>
<h1 id="为什么要有内部类"><a href="#为什么要有内部类" class="headerlink" title="为什么要有内部类"></a>为什么要有内部类</h1><p>神说要有光，于是便有了光。那为什么会需要内部类呢？</p>
<blockquote>
<p>“每个内部类都能独立的继承自一个（接口的）是实现，所以无论外围类是否已经继承了（接口的）实现，对内部类都没有影响” ——《Think in Java》</p>
</blockquote>
<p>除此之外，私以为还有上述提到的<strong>隐藏实现细节</strong>这个原因，所以掌握熟练也是很有必要的，工业界应该少不了这个要求吧？！</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中==和equals()和hashCode()]]></title>
      <url>http://yoursite.com/2017/04/30/Java%E4%B8%AD==%E5%92%8Cequals()%E5%92%8ChashCode()/</url>
      <content type="html"><![CDATA[<h1 id="Java中的"><a href="#Java中的" class="headerlink" title="Java中的=="></a>Java中的==</h1><p>我们知道Java中有八大基本数据类型：<br><code>int</code>、<code>double</code>、<code>char</code>、<code>boolean</code>、<code>float</code>、<code>byte</code>、<code>short</code>、<code>long</code><br>像String、Integer这种是被包装的非基本数据类型，也被认为是指向引用类型。<br>那么<code>==</code>对于基本数据类型来说，<strong>比较的是存储的值</strong>，而非基本数据类型比较的则是<strong>JVM中存储的地址（堆地址，内存中的存放地址）</strong></p>
<h1 id="Java中的equals"><a href="#Java中的equals" class="headerlink" title="Java中的equals()"></a>Java中的equals()</h1><p>Java中所有对象都继承自Object，并拥有其equals()方法，该方法原本采取的比较方式就是<code>==</code>，查看JDK源码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> * @param   obj   the reference object with which to compare.</div><div class="line"> * @return  &#123;@code true&#125; if this object is the same as the obj</div><div class="line"> *          argument; &#123;@code false&#125; otherwise.</div><div class="line"> * @see     #hashCode()</div><div class="line"> * @see     java.util.HashMap</div><div class="line"> */</div><div class="line">public boolean equals(Object obj) &#123;</div><div class="line">    return (this == obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而根据上面讲述的==的比较规则，可以得知<strong>equals()针对基本数据类型比较的是值，非基本数据类型比较的是存储的地址</strong>。那么我们会有一个疑问了，我们常常使用equals()方法来比较String字符串的值是不是相等，显然与刚才的结论是相悖的，为什么呢？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> * @param  anObject</div><div class="line"> *         The object to compare this &#123;@code String&#125; against</div><div class="line"> *</div><div class="line"> * @return  &#123;@code true&#125; if the given object represents a &#123;@code String&#125;</div><div class="line"> *          equivalent to this string, &#123;@code false&#125; otherwise</div><div class="line"> *</div><div class="line"> * @see  #compareTo(String)</div><div class="line"> * @see  #equalsIgnoreCase(String)</div><div class="line"> */</div><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    if (this == anObject) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    if (anObject instanceof String) &#123;</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此可以看到，String中重写了equals()方法，可以直接比较<strong>两个String变量中的值而不是地址</strong>，因此如果我们想使用equals()来比较值，需要重写equals()方法</p>
<h1 id="Java中的hashCode"><a href="#Java中的hashCode" class="headerlink" title="Java中的hashCode()"></a>Java中的hashCode()</h1><p>事实上，单纯的重写equals()方法是不够的，为了更好的比较两个对象是否是同一个对象，<strong>除了比较其中的值，还需要比较其指向的地址</strong>，那么这就需要我们还重写hashCode()方法。</p>
<p>hashCode()方法是比较两个对象的指向的JVM中地址是否相同，HashCode主要用于提供快捷的查找，在HashTable和HashMap中都有使用，HashCode是用来在散列存储结构中确定对象的存储地址的。</p>
<p>更具体的内容可以到另一篇博文中寻找：<a href="http://zpcheng.me/2017/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/" target="_blank" rel="external">hashCode()详细说明</a></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>两个对象的hashCode相同，不代表就是同一个对象/两个对象相同，在hash存储结构中，这只说明了两个对象发生了冲突，被分配在了同一个桶里面。java判断两个对象是否相同还会判断对象引用中存储的地址是否相同（默认）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>偶然想起了这个“重写equals()就一定要重写hashCode()”这句话，所以顺便就来找一下为什么了。一些细枝末节的东西细细追究起来还是可以回味良久的。 </p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet与JSP-JavaWeb项目食用指南]]></title>
      <url>http://yoursite.com/2017/04/10/Servlet%E4%B8%8EJSP-JavaWeb%E9%A1%B9%E7%9B%AE%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="SocraWeb食用指南"><a href="#SocraWeb食用指南" class="headerlink" title="SocraWeb食用指南"></a>SocraWeb食用指南</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本项目是基于Servlet+JSP+DataBase实现的一个商品管理系统，主要目的是学习JavaWeb入门的知识：Servlet、JSP以及EL表达式、Ajax和JSON。完成这个项目主要还是巩固练习JavaWeb的基础知识，为后面的JavaEE框架的学习做铺垫。所以以本人的学习经验来看，这是一个很好的上手Web的练习项目</p>
<p><img src="/2017/04/10/Servlet与JSP-JavaWeb项目食用指南/index.png" alt="index"></p>
<h2 id="Github连接"><a href="#Github连接" class="headerlink" title="Github连接"></a>Github连接</h2><p>项目存储于：<br><a href="https://github.com/SocraHat/SocraWeb.git" target="_blank" rel="external">https://github.com/SocraHat/SocraWeb.git</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>MySQL数据库：本人的版本是Server version: 5.7.11 MySQL Community Server (GPL)</li>
<li>JDK：版本java version “1.8.0_112”</li>
<li>Tomcat：apache-tomcat-7.0.73</li>
<li>JDBC-jar包：mysql-connector-java-5.1.40-bin.jar</li>
<li>JSTL-jar包：jstl.jar</li>
<li>开发环境：EclipseEE版本</li>
</ul>
<h3 id="数据库表单创建"><a href="#数据库表单创建" class="headerlink" title="数据库表单创建"></a>数据库表单创建</h3><ul>
<li>首先确认连接MySQL数据库的用户名是<code>root</code>，密码是<code>123456</code></li>
<li>创建名为<code>web_manage</code>的数据库</li>
<li>再在该数据下创建名为<code>user</code>，<code>manager</code>，<code>goods</code>和<code>goodsInformation</code>的四个数据表</li>
<li><p>user的SQL语句为：存储注册用户信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE user(</div><div class="line">	uid varchar(16) PRIMARY KEY,</div><div class="line">	upsd varchar(16) NOT NULL,</div><div class="line">  	uname varchar(16) </div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>manager的SQL语句为：存储管理员信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE manager(</div><div class="line">	mid varchar(16) PRIMARY KEY,</div><div class="line">	mpsd varchar(10) ,</div><div class="line">  	mname varchar(16) </div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>goods的SQL语句为：存储管理商品的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE goods(</div><div class="line">	gid int(11) PRIMARY KEY,</div><div class="line">	gname varchar(50),</div><div class="line">  	gprice float,</div><div class="line">  	gintroduce varchar(50),</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>goodsInformation的SQL语句为：商品信息的补充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE goodsInformation(</div><div class="line">	gid int(11) PRIMARY KEY,</div><div class="line">  	gintroduce varchar(255),</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>整个项目主要的功能是增删改查</p>
<ul>
<li>用户的注册登陆以及退出</li>
<li>主页商品的查看和查询商品</li>
<li>用户信息的修改</li>
<li>管理员登陆修改自己的信息</li>
<li>管理员修改商品信息</li>
<li>增加、删除商品信息</li>
<li>过滤器对于没有权限的访问不予通过</li>
</ul>
<h2 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h2><p>具体的导入工程（Eclipse或者是IDEA）请自行百度，在导入项目后启动Tomcat服务器后就可以直接食用了。<br>但是有几点需要再注意下</p>
<ul>
<li>用户需要登陆才能查看商品详细信息（权限设置）</li>
<li>只有管理员才有权限去更改商品的各个信息</li>
<li>可能在程序中设置有session的存活时间，所以长时间不对页面操作而导致登陆状态消失时请重新登录</li>
<li>修改商品信息、用户信息、管理员信息时一定注意不能是空值<code>null</code>，另外在新增商品时注意商品的编号不能是<code>0</code></li>
<li>其余的基本操作可以自己去尝试，和一般的网页处理事务的顺序原理相似</li>
</ul>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><p>项目前后历时还是有个个把月的，但主要还是最后的这两天完成实现了大部分功能，虽然只是一个初级的小项目，但是内心还是充满了欢喜的。这部分知识不敢说全部掌握，起码也有个六七八了，后面的细节，再做补充。</p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><p>感觉项目中比较棘手的地方：</p>
<ul>
<li>页面的合理设计：追求一定美观合适，也使用了BootStrap</li>
<li>前后台数据的交互：有时需要用到Servlet到JSP或是Servlet的转发，有时需要用到Session，有时需要用到JS的跳转，错综复杂，但是编码问题，调用的方法，需要后续再补充一篇细节总结</li>
<li>使用JS来获取页面的表格中的数据并使用Ajax传递到后台</li>
<li>登陆后的登出以及验证问题</li>
<li>程序和数据库交互问题：如何正确又高效的查询</li>
<li>初步尝试MVC（Servlet+JSP+JavaBean）模式，虽然分了层，但是感觉还是不够清晰简洁</li>
<li>使用过滤器实现权限的判断和页面的跳转</li>
</ul>
<h1 id="责任声明"><a href="#责任声明" class="headerlink" title="责任声明"></a>责任声明</h1><p>本项目纯属个人项目，因为本人能力问题，可能某些地方的处理不合适或是有误，欢迎大家提出宝贵意见。<br>若是对您学习造成了误导，本人表示十分抱歉。</p>
]]></content>
      
        
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解ArrayList]]></title>
      <url>http://yoursite.com/2017/03/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ArrayList/</url>
      <content type="html"><![CDATA[<h1 id="是的，这又是一篇转文"><a href="#是的，这又是一篇转文" class="headerlink" title="是的，这又是一篇转文"></a>是的，这又是一篇转文</h1><p>讲道理，有时候转载博文也是挺效率得一件事，毕竟没有那么多的时间去自己抠（哎），毕竟我是站在dalao得肩膀上啊<a href="http://zhangshixi.iteye.com/blog/674856" target="_blank" rel="external">ArrayList的实现原理</a>侵删</p>
<p>本篇是研究一下ArrayList的底层实现，顺便把List的底也给掀了</p>
<h1 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h1><p>ArrayList是List接口的可变数组的实现。实现了所有可选列表的操作，并允许包括null在内的所有元素。同时ArrayList也有内部的方法用于操作数组大小以及元素。<br>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>另外需要提及的一点就是，ArrayList并不是线程安全的，多线程使用时需要注意注意同步。</p>
<h1 id="来看一下源码"><a href="#来看一下源码" class="headerlink" title="来看一下源码"></a>来看一下源码</h1><p>其实本质就是对数组的操作，我们在使用时的简单操作的原理是透明的。</p>
<h2 id="存储实现"><a href="#存储实现" class="headerlink" title="存储实现"></a>存储实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * The array buffer into which the elements of the ArrayList are stored.</div><div class="line">     * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表，构造一个指定初始容量的数组，以及构造一个包含指定Collection元素的列表，这些元素按照collection的迭代器返回它们的顺序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>();  </div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);  </div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    elementData = c.toArray();  </div><div class="line">    size = elementData.length;  </div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)  </span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>常见的添加、替换方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">    <span class="comment">// 有一个强制转型的操作</span></div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">    elementData[index] = element;  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></div><div class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </div><div class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。  </span></div><div class="line">    ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，  </span></div><div class="line">    <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span></div><div class="line">    <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    size++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </div><div class="line">            <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="某些细节"><a href="#某些细节" class="headerlink" title="某些细节"></a>某些细节</h3><p>看到这里我注意到有两个方法出现的次数很高：<code>ensureCapacity()</code>和<code>System.arraycopy()</code></p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>指定下标删除或者指定元素删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    modCount++;  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。  </span></div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </div><div class="line">            fastRemove(index);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>元素被移除后，该元素后面的元素的下标值都减一了，使用时需要注意</p>
<h2 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h2><p>每次对ArrayList进行操作之前都会判断一下容量的大小，如果容量不够，会及时的自动扩充。但是通过我们手动调用，给ensuerCapacity输入参数，可以避免方法重复递归调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;  </div><div class="line">        Object oldData[] = elementData;  </div><div class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;  </div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity)  </div><div class="line">                newCapacity = minCapacity;  </div><div class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line">      elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以明显的看出，数组的每次自我扩容是原来的1.5倍，较为保守。<br>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Fail-Fast机制（快速失败机制）"><a href="#Fail-Fast机制（快速失败机制）" class="headerlink" title="Fail-Fast机制（快速失败机制）"></a>Fail-Fast机制（快速失败机制）</h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<blockquote>
<p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
</blockquote>
<p>ArrayList值得看一看的基本就在这里，其余的方法使用时可自行查阅API文档。（所以说，这就是一个自动的可以存放任意类型对象的数组，使用时很方便）</p>
<h1 id="那就不得不说一下Vector"><a href="#那就不得不说一下Vector" class="headerlink" title="那就不得不说一下Vector"></a>那就不得不说一下Vector</h1><p>打开Vector源码一看，果不出期然，Vector的实现与ArrayList的底层实现基本如出一辙，除了线程安全基本没有改变什么（重量级操作）<br>其实查看源码时，很容易注意到，很多方法都用<code>synchronized</code>修饰了，这也就是线程安全的实现原理。</p>
<h1 id="顺便看一看LinkedList"><a href="#顺便看一看LinkedList" class="headerlink" title="顺便看一看LinkedList"></a>顺便看一看LinkedList</h1><p>虽然实现了List的接口，但底层并不是对数组进行的操作，而是使用<strong>双向循环链表</strong>实现。继承于AbstractSequentialList，可以被当作堆栈、队列或双端队列进行操作。<br>FROM-<a href="http://www.cnblogs.com/ITtangtang/p/3948610.html" target="_blank" rel="external">Java集合—LinkedList源码解析</a>侵删</p>
<h2 id="链表节点Entry"><a href="#链表节点Entry" class="headerlink" title="链表节点Entry"></a>链表节点Entry</h2><p>其中的链表节点元素都是Entry类型的实例（包含三个变量：previous、next、element）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E element; <span class="comment">// 业务数据</span></div><div class="line">    Entry&lt;E&gt; next; <span class="comment">// 后节点信息</span></div><div class="line">    Entry&lt;E&gt; previous; <span class="comment">// 前节点信息</span></div><div class="line"></div><div class="line">    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.previous = previous;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>因为是<strong>双向-循环-链表</strong><br>第一种构造方法在初始化时只有头元素的情况下，previous和next都指向自己，形成一个闭环，这是称为循环的原因。<br>第二种方法是接收一个Collection参数c，调用第一种方法构造一个空链表（首节点不算），然后通过addAll()方法将c中的元素全部添加到链表中。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>这里是重头戏，dalao已经讲解的很好了，丝毫不敢稍有改动。</p>
<ul>
<li>初始化后LinkedList是首结点闭环<br><img src="/2017/03/30/深入理解ArrayList/1.png" alt="1"></li>
<li>再初始化一个预添加的Entry实例，<code>Entry newEntry = newEntry(e, entry, entry.previous);</code><br><img src="/2017/03/30/深入理解ArrayList/2.png" alt="2"></li>
<li>调整新加入节点和首节点的前后指针<br><img src="/2017/03/30/深入理解ArrayList/3.png" alt="3"><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">newEntry.previous.next = newEntry;</div><div class="line">newEntry.next.previous = newEntry;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>再有新的节点插入时，过程是这样的</p>
<ul>
<li>新建一个节点<br><img src="/2017/03/30/深入理解ArrayList/4.png" alt="4"></li>
<li>修改前后指针<br><img src="/2017/03/30/深入理解ArrayList/5.png" alt="5"></li>
</ul>
<h2 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;E&gt; e = header.next;</div><div class="line">    <span class="comment">// e可以理解为一个移动的“指针”，因为是循环链表，所以回到header的时候说明已经没有节点了</span></div><div class="line">     <span class="keyword">while</span> (e != header) &#123;</div><div class="line">       <span class="comment">// 保留e的下一个节点的引用</span></div><div class="line">        Entry&lt;E&gt; next = e.next;</div><div class="line">        <span class="comment">// 解除节点e对前后节点的引用</span></div><div class="line">        e.next = e.previous = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 将节点e的内容置空</span></div><div class="line">        e.element = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 将e移动到下一个节点</span></div><div class="line">        e = next;</div><div class="line"> &#125;</div><div class="line">    <span class="comment">// 将header构造成一个循环链表，同构造方法构造一个空的LinkedList</span></div><div class="line">    header.next = header.previous = header;</div><div class="line">    <span class="comment">// 修改size</span></div><div class="line">    size = <span class="number">0</span>;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">remove</span><span class="params">(Entry&lt;E&gt; e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == header)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="comment">// 保留将被移除的节点e的内容</span></div><div class="line">    E result = e.element;</div><div class="line">   <span class="comment">// 将前一节点的next引用赋值为e的下一节点</span></div><div class="line">    e.previous.next = e.next;</div><div class="line">   <span class="comment">// 将e的下一节点的previous赋值为e的上一节点</span></div><div class="line">    e.next.previous = e.previous;</div><div class="line">   <span class="comment">// 上面两条语句的执行已经导致了无法在链表中访问到e节点，而下面解除了e节点对前后节点的引用</span></div><div class="line">   e.next = e.previous = <span class="keyword">null</span>;</div><div class="line">  <span class="comment">// 将被移除的节点的内容设为null</span></div><div class="line">  e.element = <span class="keyword">null</span>;</div><div class="line">  <span class="comment">// 修改size大小</span></div><div class="line">  size--;</div><div class="line">  modCount++;</div><div class="line">  <span class="comment">// 返回移除节点e的内容</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单说就是，先把前后节点互相连接起来，再清空该节点的所有数据。然后等待GC回收即可</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><p>感觉这是一个需要关注一点的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取双向链表中指定位置的节点    </span></div><div class="line">    <span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)    </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+    </div><div class="line">                                                <span class="string">", Size: "</span>+size);    </div><div class="line">        Entry&lt;E&gt; e = header;    </div><div class="line">        <span class="comment">// 获取index处的节点。    </span></div><div class="line">        <span class="comment">// 若index &lt; 双向链表长度的1/2,则从前先后查找;    </span></div><div class="line">        <span class="comment">// 否则，从后向前查找。    </span></div><div class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)    </div><div class="line">                e = e.next;    </div><div class="line">        &#125; <span class="keyword">else</span> &#123;    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)    </div><div class="line">                e = e.previous;    </div><div class="line">        &#125;    </div><div class="line">        <span class="keyword">return</span> e;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一个小细节就可以提高性能</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实就一个数组/链表，基本原理就是这样子，无非是Java给你封装好了直接拿来用就好了┑(￣Д ￣)┍<br>把这个List更完，常用的集合框架就只剩一个TreeMap 了，由于底层是使用红黑树实现的（虽然看了好几遍插删，但是记不住啊），日后补完JVM垃圾回收在去干它好了。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java集合框架的并发安全研究]]></title>
      <url>http://yoursite.com/2017/03/29/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="早就想开这个坑了"><a href="#早就想开这个坑了" class="headerlink" title="早就想开这个坑了"></a>早就想开这个坑了</h1><p>讲真，从开始慢慢深入Java后，发现了并发这个最关键的点之一，不了解这个怕是不敢说熟悉Java啊，呐，择日不如撞日，就今天来打第一炮好了</p>
<h1 id="我站在dalao的肩膀上"><a href="#我站在dalao的肩膀上" class="headerlink" title="我站在dalao的肩膀上"></a>我站在dalao的肩膀上</h1><p>其实这是一篇转文，来自<a href="http://blog.csdn.net/mexican_ok/article/details/12859351" target="_blank" rel="external">dalao博文侵删</a><br>在集合框架中，有些类是线程安全的，这些都是jdk1.1中的出现的。在jdk1.2之后，就出现许许多多非线程安全的类。</p>
<p><strong>线程安全的类/接口</strong></p>
<ul>
<li>Vector：底层是容量默认为10的Object数组（翻看ArrayList源码，底层也是Object数组），比ArrayList多了个同步化机制（线程安全），但是效率较低，现不建议使用</li>
<li>Statck：继承自Vector，所以其也是线程安全的</li>
<li>HashTable：相较于HashMap多了同步机制，但是同样，带来了效率的底下，具体区别看<a href="http://zpcheng.me/2017/03/16/HashMap和HashTable的区别/#more" target="_blank" rel="external">HashMap和HashTable的区别</a></li>
<li>Enumeration：枚举类，相当于迭代器（这个真没什么了解）</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>除了上述列出的类，其余的集合框架中的类或者是接口都是非线程安全的（这不等于线程不安全）。因为保证了同步，所以相较而言就比较笨重，效率较低。</p>
<p>呐，顺便再提一下StringBuffer和StringBuilder好了，二者区别就是StringBuffer是线程安全的<a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">String、StringBuffer与StringBuilder之间区别</a></p>
<h1 id="事实"><a href="#事实" class="headerlink" title="事实"></a>事实</h1><p>事实就是今天一晚上都在研究集合框架研究嗨了，从HashSet到把Set翻了个底朝天，从又看HashMap到现在看集合框架的并发安全性，首先需要明确的是这就是个坑，暂时放在这里，后面再开始啃Java并发之后再详谈，<br>今天还要再看一看Java锁呢，垃圾回收机制怕是只能到明天再继续了</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解HashSet]]></title>
      <url>http://yoursite.com/2017/03/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashSet/</url>
      <content type="html"><![CDATA[<h1 id="首先是有一个悲伤的故事"><a href="#首先是有一个悲伤的故事" class="headerlink" title="首先是有一个悲伤的故事"></a>首先是有一个悲伤的故事</h1><p>讲道理，这是面试时遇到的第一个卡壳以至于转移面试官注意力的地方（……），还好之前有被人指点一下加确实已经仔细研究过HashMap，才不至于无法补救</p>
<h1 id="其次我TM惊呆了"><a href="#其次我TM惊呆了" class="headerlink" title="其次我TM惊呆了"></a>其次我TM惊呆了</h1><p>本想着回来以后好好看看HashSet的底层实现，结果打开源码一看的我惊呆了<br><img src="/2017/03/29/深入理解HashSet/set.png" alt="set"><br>wocao怎么这么刺眼呢？你是set啊，你是Collection的子类啊，你叔叔才是Map啊，<br><img src="/2017/03/29/深入理解HashSet/cai.png" alt="cai"><br>你这样我心好痛啊<br><img src="/2017/03/29/深入理解HashSet/ji.jpg" alt="ji"><br>冷静下来我仔细一想，Set不能有重复的元素，HashMap不允许有重复的键，又是一口老血，当时也没想到也没敢去这么想</p>
<h1 id="转一下dalao的博客"><a href="#转一下dalao的博客" class="headerlink" title="转一下dalao的博客"></a>转一下dalao的博客</h1><p>于是接着去看网上的dalao的博客，发现了这一篇<a href="http://zhangshixi.iteye.com/blog/673143" target="_blank" rel="external">私自转载dalao博文侵删</a></p>
<h2 id="HashSet概述和实现"><a href="#HashSet概述和实现" class="headerlink" title="HashSet概述和实现"></a>HashSet概述和实现</h2><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变，此类允许使用null元素。<br>在HashSet中，<strong>元素都存到HashMap键值对的Key上面，而Value时有一个统一的值<code>private static final Object PRESENT = new Object();</code></strong>，</p>
<h2 id="HashSet插入"><a href="#HashSet插入" class="headerlink" title="HashSet插入"></a>HashSet插入</h2><p>当有新值加入时，底层的HashMap会判断Key值是否存在（HashMap细节请移步<a href="http://zpcheng.me" target="_blank" rel="external">深入理解HashMap</a>），如果不存在，则插入新值，同时这个插入的细节会依照HashMap插入细节；如果存在就不插入</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>同HashMap删除原理</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>盗（xue）用（xi）一下dalao 的分析代码，侵权请告之，立马删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </div><div class="line">      </div><div class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 默认的无参构造器，构造一个空的HashSet。 </div><div class="line">     *  </div><div class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 构造一个包含指定collection中的元素的新set。 </div><div class="line">     * </div><div class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </div><div class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </div><div class="line">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </div><div class="line">    addAll(c);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </div><div class="line">     * </div><div class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </div><div class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </div><div class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </div><div class="line">     * </div><div class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </div><div class="line">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </div><div class="line">     * <span class="doctag">@param</span> loadFactor 加载因子。 </div><div class="line">     * <span class="doctag">@param</span> dummy 标记。 </div><div class="line">     */  </div><div class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;  </div><div class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </div><div class="line">     *  </div><div class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </div><div class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </div><div class="line">     * value使用一个static final的Object对象标识。 </div><div class="line">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.keySet().iterator();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回此set中的元素的数量（set的容量）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </div><div class="line">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.size();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set不包含任何元素，则返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.isEmpty();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set包含指定元素，则返回true。 </div><div class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </div><div class="line">     * 的e元素时，返回true。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </div><div class="line">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.containsKey(o);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </div><div class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </div><div class="line">     * 的元素e2，则向此set 添加指定的元素e。 </div><div class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </div><div class="line">     * </div><div class="line">     * 底层实际将将该元素作为key放入HashMap。 </div><div class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </div><div class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </div><div class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </div><div class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </div><div class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </div><div class="line">     * <span class="doctag">@param</span> e 将添加到此set中的元素。 </div><div class="line">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 如果指定元素存在于此set中，则将其移除。 </div><div class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </div><div class="line">     * 则将其移除。如果此set已包含该元素，则返回true </div><div class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </div><div class="line">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </div><div class="line">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">    map.clear();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </div><div class="line">     * </div><div class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </div><div class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </div><div class="line">            <span class="keyword">return</span> newSet;  </div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>说白了，HashSet就是限制了功能的HashMap，所以了解HashMap的实现原理，这个HashSet自然就通</li>
<li>对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性</li>
<li>虽说时Set是对于重复的元素不放入，倒不如直接说是底层的Map直接把原值替代了（这个Set的put方法的返回值真有意思）</li>
<li>HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得</li>
</ul>
<h1 id="说起来你可能不信"><a href="#说起来你可能不信" class="headerlink" title="说起来你可能不信"></a>说起来你可能不信</h1><p>本来是打算分开写集合框架的底层分析的，直到我发现，LinkedHashSet是继承自HashSet，底层实现是LinkedHashMap。并且其初始化时直接<code>super(......)</code>，瞬间我就觉得，Set写在一起得了</p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>同HashSet相比并没有实现新的功能（新的方法），只不过把HashSet中预留的构造方法启用了，因而可以实现有序插入，而这个具体的实现要去看LinkedHashMap了，我们使用时是不需要再可以去设置参数的，直接拿来用即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</div><div class="line"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@serial</span></div><div class="line"> */</div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div></pre></td></tr></table></figure></p>
<p>查看了LinkedHashMap的构造方法后，发现其因为继承自HashMap，所以其底层实现也是HashMap!!!（呵呵，我已经发现了……怪不得还是得主要研究HashMap啊），然后发现了LinkedHashMap调用父类构造方法初始化时，还顺便设置了变量<code>accessOrder = false</code>，看上面得源码可以知道，这是给了迭代器一个参数，<strong>false代表迭代时使用插入得顺序</strong>（追根溯源了，真爽）</p>
<h3 id="偶然发现"><a href="#偶然发现" class="headerlink" title="偶然发现"></a>偶然发现</h3><p>查看源码时，我发现了一个奇怪的重写的方法：<code>public Spliterator&lt;E&gt; spliterator()</code>，查了查资料发现叫做可分割迭代器，这个接口是为了并行遍历数据源中的元素而设计的迭代器，为了更好的发挥多核CPU的能力。<br>其实这样我想起了要去关注一下集合框架中的并发安全了。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>根据Set的这个尿性，我先猜测一波，TreeSet的底层实现是TreeMap（而且我在猜TreeMap的底层实现借助了HashMap）。一看源码，哎呦我去，还真是（呵呵，到底谁才是你爹…..心疼一波Collection,Map又不继承Collection接口）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="TreeSet特点与实现机制"><a href="#TreeSet特点与实现机制" class="headerlink" title="TreeSet特点与实现机制"></a>TreeSet特点与实现机制</h3><p>TreeSet中存放的元素是有序的（不是插入时的顺序，是有按关键字大小排序的），且元素不能重复。<br>而如何实现有序存储，就需要有一个比较器，其实说起来，TreeSet更受关注的是不重复且有序，这个有序就需要有一个compare的过程，因此会需要参数实现Comparable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a new, empty tree set, sorted according to the specified</div><div class="line"> * comparator.  All elements inserted into the set must be &lt;i&gt;mutually</div><div class="line"> * comparable&lt;/i&gt; by the specified comparator: &#123;<span class="doctag">@code</span> comparator.compare(e1,</div><div class="line"> * e2)&#125; must not throw a &#123;<span class="doctag">@code</span> ClassCastException&#125; for any elements</div><div class="line"> * &#123;<span class="doctag">@code</span> e1&#125; and &#123;<span class="doctag">@code</span> e2&#125; in the set.  If the user attempts to add</div><div class="line"> * an element to the set that violates this constraint, the</div><div class="line"> * &#123;<span class="doctag">@code</span> add&#125; call will throw a &#123;<span class="doctag">@code</span> ClassCastException&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this set.</div><div class="line"> *        If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable natural</div><div class="line"> *        ordering&#125; of the elements will be used.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="所以说"><a href="#所以说" class="headerlink" title="所以说"></a>所以说</h2><p>所以说使用Set需要注意的还是根据自己的需求选取正确的存储结构即可，而因为并没有get()方法给你使用，所以还是要用迭代器来获取想要的元素，然后本次Set深入分析到此结束，我要去再开一坑研究TreeMap了（滑稽）</p>
<h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><p>经历这么一次滑稽的经历，看来真的有必要把几个常用的集合框架的底层实现都看一遍，以免再次搞出这样的尴尬（手动滑稽）<br>其实深入到这个程度我觉得常用的集合除了List的家族还有Queue，其实都可以规约为深入理解HashMap，来，就是这个节奏。走起。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM中String常量池与运行时常量池]]></title>
      <url>http://yoursite.com/2017/03/29/JVM%E4%B8%ADString%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="Start-with-JVM"><a href="#Start-with-JVM" class="headerlink" title="Start with JVM"></a>Start with JVM</h1><p>周志明先生著-《深入理解Java虚拟机》，书买回来好几天了，但是最近才准备开始搞一搞了（哭瞎…..）。首先是第一章的Java以及JVM发展历史，大概知道了现行的应用最广泛的Java虚拟机是HotSpot，当然一些商业公司也有使用自己的虚拟机。</p>
<h2 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h2><p>这是放在Java内存区域与内存溢出异常里面的必备知识，描述了Java虚拟机在运行时的数据区域<br>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/shujuqu.png" alt="shujuqu"><br><strong>私有</strong></p>
<ul>
<li>程序计数器：记录当前线程所执行字节码的行号指示器</li>
<li>虚拟机栈：存放了当前线程调用方法的局部变量表、操作数栈、动态链接、方法返回值等信息（可以理解为线程的栈）</li>
<li>本地方法栈：为虚拟机使用的Native方法提供服务，后多与JVM Stack合并为一起</li>
</ul>
<p><strong>共享</strong></p>
<ul>
<li>Java堆：占据了虚拟机管理内存中最大的一块（没想到吧），<strong>唯一目的就是存放对象实例</strong>（与引用是两个概念），也是垃圾回收器主要管理的地方，故又称GC堆。先开坑，后面讲垃圾回收机制再详述</li>
<li>方法区：<strong>存储加载的类信息、常量区、静态变量、JIT（即时编译器）处理后的数据等</strong>，类的信息包含类的版本、字段、方法、接口等信息。需要注意是常量池就在方法区中，也是我们这次需要关注的地方。</li>
</ul>
<h3 id="提一下这个Native方法"><a href="#提一下这个Native方法" class="headerlink" title="提一下这个Native方法"></a>提一下这个Native方法</h3><p>指得就是Java程序调用了非Java代码，算是一种引入其它语言程序的接口</p>
<h2 id="看一下方法区"><a href="#看一下方法区" class="headerlink" title="看一下方法区"></a>看一下方法区</h2><p>方法区因为总是存放不会轻易改变的内容，故又被称之为“永久代”。HotSpot也选择把GC分代收集扩展至方法区，但也容易遇到内存溢出问题。可以选择不实现垃圾回收，但如果回收就主要涉及常量池的回收和类的卸载（这里开坑，后续补上链接）</p>
<h1 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h1><p>回归本次讨论正题，主要是在看Java和C++的一些原理时，老是有“常量池”这个我一知半解的讨厌的字词，烦的一批，今天我就来探一探究竟。</p>
<p>JVM中运行时常量池在方法区中，因为是建立在JDK1.7/1.8的基础上来研究这个，所以我先认为String常量池在堆中。Class文件中除了类的版本、字段、方法、接口等描述信息，还有常量池，用于<strong>存放编译期生成的各种字面量和符号引用</strong></p>
<h2 id="运行时常量池与Class文件常量池区别"><a href="#运行时常量池与Class文件常量池区别" class="headerlink" title="运行时常量池与Class文件常量池区别"></a>运行时常量池与Class文件常量池区别</h2><ul>
<li>JVM对Class文件中每一部分的格式都有严格的要求，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行；但运行时常量池没有这些限制，<strong>除了保存Class文件中描述的符号引用，还会把翻译出来的直接引用也存储在运行时常量区</strong></li>
<li>相较于Class文件常量池，运行时常量池更具动态性，<strong>在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入</strong>。最主要的运用便是String类的intern()方法</li>
<li>在方法区中，常量池有运行时常量池和Class文件常量池；但其中的内容是否完全不同，暂时还未得知</li>
</ul>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>检查字符串常量池中是否存在String并返回池里的字符串引用；若池中不存在，则将其加入池中，并返回其引用。<br>这样做主要是为了避免在堆中不断地创建新的字符串对象</p>
<h2 id="那class常量池呢？"><a href="#那class常量池呢？" class="headerlink" title="那class常量池呢？"></a>那class常量池呢？</h2><p>具体的等分析到Class文件格式再来填这个坑，先来看常量池中的内容：<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/changliangchi.png" alt="changliangchi"><br>看一下dalao的博客<a href="http://blog.csdn.net/wangtaomtk/article/details/52267548" target="_blank" rel="external">Class文件中常量池详解</a></p>
<h1 id="看一看String常量池（的特殊姿势）吧"><a href="#看一看String常量池（的特殊姿势）吧" class="headerlink" title="看一看String常量池（的特殊姿势）吧"></a>看一看String常量池（的特殊姿势）吧</h1><p>在研究这个的时候我也上网看了别人的博客，有的人做出了实验，我也试一下</p>
<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String a = <span class="string">"a"</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">		String b = <span class="string">"b"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Java自带的反编译工具反编译一下，编译后输入<code>javap -verbose Test.class</code></p>
<p><img src="/2017/03/29/JVM中String常量池与运行时常量池/test1.png" alt="test1"><br>可以发现两个静态String变量都放入了常量池中</p>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"laji"</span> + <span class="string">"MySQL"</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在编译前先分析一波，按理说，既然是静态String常量，那么理应出现在常量池（Constant Pool）中，但<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/test2.png" alt="test2"></p>
<p>来看看进阶版的Test2_2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2_2</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		String string1 = <span class="string">"laji"</span>;  </div><div class="line">		String string2 = <span class="string">"MySQL"</span>;  </div><div class="line">		String string3 = string1+string2;  </div><div class="line">		String string4 = string1+<span class="string">"C"</span>;	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个的结果就更有意思了↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/test2_2.png" alt="test2_2"><br>总商量个实验，可以看出</p>
<ul>
<li>对于直接做<code>+</code>运算的两个字符串（字面量）常量，并不会放入String常量池中，而是直接把运算后的结果放入常量池中</li>
<li>对于先声明的字符串字面量常量，会放入常量池，但是若使用字面量的引用进行运算就不会把运算后的结果放入常量池中了</li>
<li>总结一下就是JVM会对String常量的运算进行优化，未声明的，只放结果；已经声明的，只放声明</li>
</ul>
<h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		String str = <span class="string">"laji"</span>;</div><div class="line">		String str2 = <span class="keyword">new</span> String(<span class="string">"MySQL"</span>);</div><div class="line">		String str3 = <span class="keyword">new</span> String(<span class="string">"laji"</span>);</div><div class="line">		</div><div class="line">		System.out.println(str==str3);<span class="comment">// 运行后结果为false</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果为：<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/test3.png" alt="test3"><br>这个实验三包含了很多内容，首先是new一个对象时，明明是在堆中实例化一个对象，怎么会出现常量池中？</p>
<ul>
<li>这里的<code>&quot;MySQL&quot;</code>并不是字符串常量出现在常量池中的，而是以字面量出现的，实例化操作（new的过程）是在运行时才执行的，编译时并没有在堆中生成相应的对象</li>
<li>最后输出的结果之所以是false，就是因为str指向的”laji”是存放在常量池中的，而str3指向的”laji”是存放在堆中的，==比较的是引用（地址），当然是false</li>
</ul>
<h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><p>主要是为了解释一下intern()方法的用处<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		String str = <span class="string">"laji"</span>;</div><div class="line">		String str2 = <span class="keyword">new</span> String(<span class="string">"laji"</span>);</div><div class="line">		String str3 = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		System.out.println(str==str2);<span class="comment">// 运行后结果为false</span></div><div class="line">		str3 = str2.intern();</div><div class="line">		System.out.println(str==str3);<span class="comment">// 运行后结果为true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，str3在初始化的时候是从字符串常量池中获取到的值</p>
<h1 id="String常量池随JDK的改变"><a href="#String常量池随JDK的改变" class="headerlink" title="String常量池随JDK的改变"></a>String常量池随JDK的改变</h1><p>JDK1.7中JVM把String常量区从方法区中移除了；JDK1.8中JVM把String常量池移入了堆中，同时取消了“永久代”，改用元空间代替（Metaspace）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 String str = <span class="string">"abc"</span>;  </div><div class="line">	        <span class="keyword">char</span>[] array = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;  </div><div class="line">	        String str2 = <span class="keyword">new</span> String(array);  </div><div class="line">	        <span class="comment">//使用intern()将str2字符串内容放入常量池  </span></div><div class="line">	        str2 = str2.intern();  </div><div class="line">	        <span class="comment">//这个比较用来说明字符串字面常量和我们使用intern处理后的字符串是在同一个地方  </span></div><div class="line">	        System.out.println(str == str2);  </div><div class="line">	        <span class="comment">//那好，下面我们就拼命的intern吧  </span></div><div class="line">	     </div><div class="line">	        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </div><div class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;  </div><div class="line">	            String temp = String.valueOf(i).intern();  </div><div class="line">	            list.add(temp);  </div><div class="line">	        &#125;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个实验最早是2014年有人实验过的，ta得出的结论是<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</code>，然而时至今日，我自己按照ta的代码跑了一遍，并没有出现上述的错误，虽然一段时间内内存资源占用呈上升状态。猜想：所使用JDK版本不同，对于String常量池存放的位置已经发生了改变；或者是两者的电脑硬件不同<br><a href="http://zangxt.iteye.com/blog/472236" target="_blank" rel="external">实验出处</a></p>
<p>然后，我又看到了这个<a href="http://book.51cto.com/art/201504/472210.htm" target="_blank" rel="external">新的实验证明String常量池的位置</a>，<br><code>JVM参数设置：-Xmx5m -XX:MaxPermSize=5m</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString2</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">            list.add(String.valueOf(i++).intern());  </div><div class="line">        &#125;  </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为JDK版本不同的原因，我无法按照上述的代码得出原博文相同的结果，这是我自己运行出的结果<br><img src="/2017/03/29/JVM中String常量池与运行时常量池/GC.png" alt="GC"></p>
<blockquote>
<p>sun官方说明：并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。</p>
</blockquote>
<p>对照着结果以及上面的博客可以得知，这显然是在堆中的垃圾回收发生了异常所致。在内存满后，会进行垃圾回收，但又会intern新的字符串到String常量池中，那么就会导致垃圾回收器一直不停的干着没有意义的活，时间一久，自然报错。同时原文中所提及的这一句话我觉得需要注意一下：</p>
<blockquote>
<p>另外一点值得注意的是，虽然String.intern()的返回值永远等于字符串常量。但这并不代表在系统的每时每刻，相同的字符串的intern()返回都会是一样的（虽然在95%以上的情况下，都是相同的）。因为存在这么一种可能：在一次intern()调用之后，该字符串在某一个时刻被回收，之后，再进行一次intern()调用，那么字面量相同的字符串重新被加入常量池，但是引用位置已经不同。</p>
</blockquote>
<p>综上，虽自己没有太多的明确结果证明，但是我想这已经能够印证JDK版本变化导致的String常量池位置的改变。</p>
<h1 id="日常summary"><a href="#日常summary" class="headerlink" title="日常summary"></a>日常summary</h1><p>这个本来是今天计划打算进行的一部分，结果好像进入牛角尖了，一定要深入一下…..，结果垃圾回收也没有看多少，明天继续。<br>但终于算是把这一块搞的一清二楚了，😜</p>
<h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>第一次听说垃圾分代时是懵逼的，分袋？还用分袋装垃圾？这是真的吗？现在了解了才发现自己的想法真是666</p>
]]></content>
      
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的volatile关键字]]></title>
      <url>http://yoursite.com/2017/03/18/Java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="Java并发中的可见性与原子性"><a href="#Java并发中的可见性与原子性" class="headerlink" title="Java并发中的可见性与原子性"></a>Java并发中的可见性与原子性</h1><p>Java并发是一个十分重要的知识点，然而我并不会（…..），慢慢上手吧，今天来看一看这个volatile</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指线程之间的可见性，也就是一个线程修改的结果对另一个线程是可见的。使用volatile修饰的变量就会具有可见性。但需要注意的是volatile只能保证被修饰的内容具有可见性，而不能保证具有原子性，因而就会存在线程安全问题</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子是不可分割的，因此原子操作也是指某些操作是连续的不可分割的（操作系统中有详细的解释）。非原子操作会存在线程安全问题，而加上synchronized关键字后就会使操作变成原子操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ......</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">a = a + <span class="number">1</span>;</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<p>这么一个简单的过程，CPU在运行的时候会先读取a的值，然后相加计算的结果会再赋值给a；这时候如果是多个线程在工作，那么在赋值操作前CPU读取的值到底是0还是1呢？（多个线程同时工作，无法得知哪个线程在CPU执行的先后顺序，此时使用的a值说不定就是彼时计算后的a值）</p>
<h2 id="重排序-Java多线程"><a href="#重排序-Java多线程" class="headerlink" title="重排序-Java多线程"></a>重排序-Java多线程</h2><p>再看下面的内容之前，先要看一看这个重排序：指令重排序，是指编译器或程序运行时环境为了<strong>优化程序性能</strong>而采取的对指令重新排序执行的一种手段<br>简单的说，两条语句在执行时，处于优化的原因，谁先执行谁后不一定</p>
<h1 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h1><p>为了解决线程并发的问题，Java引入了同步快synchronized和volatile关键字机制</p>
<ul>
<li>synchronized关键字：被synchronized修饰的块结构在多线程访问时，同一时刻只能有一个线程能有访问的到块内容</li>
<li>volatile关键字：volatile修饰的变量，线程在每次访问的时候，都会读取变量最后一次修改的值</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>synchronized保证了原子性，但仍不代表线程安全</li>
<li>如果一定要保证线程安全，可以使用重入锁<code>ReentrantLock</code></li>
</ul>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>再来仔细探讨一下volatile深入的原理，这是一种相对较弱的同步机制，能够确保使变量的更新对其他线程是可见的。被volatile声明的变量，编译器与运行时的环境都会注意到这是一个共享的变量，<strong>因此不会将该变量上的操作与其他内容操作一起重排序</strong>。这是因为volatile变量不会被缓存在寄存器或者其它对处理器不可见的地方，因此每次访问volatile变量都会返回最新更新的值。</p>
<blockquote>
<p>处理器在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更为轻量级（稍弱）的同步机制</p>
</blockquote>
<h2 id="先看一下普通状态下的线程工作的内存变化"><a href="#先看一下普通状态下的线程工作的内存变化" class="headerlink" title="先看一下普通状态下的线程工作的内存变化"></a>先看一下普通状态下的线程工作的内存变化</h2><p>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/18/Java中的volatile关键字/volatile.png" alt="volatile原理"><br>JVM在运行时会对不同的线程分配自己的线程栈（线程内存），线程栈保存了线程运行时变量的信息。当线程想访问一个对象的值的时候，会进行如下的操作：</p>
<ul>
<li>首先，通过对象的引用找到对应在堆内存中变量的值</li>
<li>然后把该值load到本地线程内存中，<strong>建立一个变量的副本</strong>，之后线程就不在和对内存中变量的值有任何关系，而是直接修改副本中的值</li>
<li>在修改完副本变量值后，在线程完全退出前，会自动把线程副本变量的值写回到对象在堆中的值，这样堆中变量的值就发生了变化</li>
</ul>
<p>如上图所示，取副本中的值（use）和写到副本中（asign）可以多次出现。<strong>重要的是，上图中的操作并不是原子性的</strong>，就是说当线程read和load后，如果主内存中变量的值发生了改变，线程无从得知，进而导致最后计算出的结果并不是我们预想中的。</p>
<h2 id="回过头来看一下volatile的原理"><a href="#回过头来看一下volatile的原理" class="headerlink" title="回过头来看一下volatile的原理"></a>回过头来看一下volatile的原理</h2><p>还是上图，当使用volatile修饰后，JVM<strong>只会</strong>保证从主存加载到线程栈中的变量的值是最新的，这已经可以解释了volatile是如何使处理器总是使用到最新的变量值（依靠上图中蓝色的双向箭头）。</p>
<p><strong>但是，注意但是</strong>，凡事都有个意外，volatile也会引发并发取值不一致的情况，原因在这里：</p>
<ul>
<li>假设有一个线程1和一个线程2，两个线程都会取number变量的值，计算，并写回主存</li>
<li>先是线程1，read和load并计算写回后，number的值发生了变化</li>
<li>再是线程2，当线程2read和load时，可能会是线程1写回并更新之后的number的新值，当线程2计算并写回后，这个number的值还是我们想要的值嘛？</li>
</ul>
<h2 id="总结普通状态与加了volatile关键字的对比"><a href="#总结普通状态与加了volatile关键字的对比" class="headerlink" title="总结普通状态与加了volatile关键字的对比"></a>总结普通状态与加了volatile关键字的对比</h2><p>简单的说，普通状态下，每个线程先从内存拷贝变量值到CPU缓存中（线程工作内存）。当有多个CPU工作时，每个线程可能在不同的CPU上被处理，也就是说，不同的线程使用的变量值都是来自不同的CPU缓存的</p>
<p>而<strong>volatile生命的变量就保证了JVM每次读变量都从主存中读取，跳过了CPU缓存这一步</strong></p>
<h1 id="加了volatile关键词后带来的特性"><a href="#加了volatile关键词后带来的特性" class="headerlink" title="加了volatile关键词后带来的特性"></a>加了volatile关键词后带来的特性</h1><ul>
<li>一就是可见性了，因为线程都是从主存读取数据，相当于线程利用主存传递数据</li>
<li>二就是禁止了指令重排序，查看网上的博客，发现了这么一句指令代码<code>lock addl $0x0,(%esp)</code>，这是汇编指令，该操作相当于是一个<strong>内存屏障</strong>，作用是指令重排序时不能把屏障之后的指令排到屏障之前的位置</li>
</ul>
<h1 id="日常O-O"><a href="#日常O-O" class="headerlink" title="日常O_O"></a>日常O_O</h1><p>写这个Blog主要还是被笔试题虐了，关于JVM内存处理机制还是处于比较懵懂的状态，后面买了书再慢慢填坑<br>PS：今天心情爆炸不爽，服。自己还是先狗后人吧。:-)</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java序列化]]></title>
      <url>http://yoursite.com/2017/03/18/Java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h1><p>Java序列化是指把Java对象转换为字节序列的过程；反序列化就是把字节序列再恢复成Java对象的过程</p>
<h1 id="序列化的作用是什么？"><a href="#序列化的作用是什么？" class="headerlink" title="序列化的作用是什么？"></a>序列化的作用是什么？</h1><p>一般序列化的作用有两方面：</p>
<ul>
<li>把对象转换成字节序列永久的保存到硬盘上（保存到文件中），在MVC中很好用</li>
<li>在网络上传送对象的字节序列</li>
</ul>
<p>简单的说，就是<strong>把数据（对象）换个时间或者是换个地方，继续使用</strong></p>
<ul>
<li>换个时间，比如说把数据存盘</li>
<li>换个地方，比如网络间数据的传输</li>
</ul>
<h2 id="网络间对象的传输"><a href="#网络间对象的传输" class="headerlink" title="网络间对象的传输"></a>网络间对象的传输</h2><p>我们可以通过网络传输图片、文子、音像、视频等资料，同样也可以传对象，这样两个Java程序间通信就可以交换数据。（云服务，把用户数据从服务器传输给用户等）</p>
<h1 id="如何实现序列化和反序列化？"><a href="#如何实现序列化和反序列化？" class="headerlink" title="如何实现序列化和反序列化？"></a>如何实现序列化和反序列化？</h1><p>一个不是很难理解的过程，很像是一个处理流</p>
<h2 id="对象流：ObjectOutputStream和ObjectInputStream"><a href="#对象流：ObjectOutputStream和ObjectInputStream" class="headerlink" title="对象流：ObjectOutputStream和ObjectInputStream"></a>对象流：ObjectOutputStream和ObjectInputStream</h2><p>ObjectOutputStream对象输出流，在实例化时<code>new ObjectOutputStream(OutputStream os)</code>获取输出流，然后<code>writeObject(Object obj)</code>方法可以对参数指定的obj对象进行序列化，然后可以把序列化的的字节序列写到这个os流中；<br><strong>序列化操作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(file_name);</div><div class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</div><div class="line"><span class="comment">// ......</span></div><div class="line">Object obj  = <span class="keyword">new</span> Object();</div><div class="line">oos.writeObject(obj);</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>反序列化操作</strong><br>ObjectInputStream对象输出流，在实例化时<code>new ObjectOutputStream(OutputStream os)</code>获取输入流，然后<code>(Object)readObject()</code>方法可以把读取到的字节序列强制转换成某个类的对象，并赋值；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(file_name);</div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</div><div class="line"><span class="comment">// ......</span></div><div class="line"><span class="comment">// 所需的对象字节序列都在流中</span></div><div class="line">Object obj  = (Object)ois.readObject();</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><p>只有实现了<code>Serializable或Externalizable接口的类</code>的对象才能被序列化，否则会抛出异常</p>
<ul>
<li>实现Serializable接口<br>使用默认的序列化/反序列化的方式，对类的非transient的实例对象进行序列化和反序列化</li>
<li>实现Serializable接口并重写了writeObjetct和readObject方法<br>该类对象就可以调用重写后的读写方法</li>
<li>实现Externalizable接口并重写了writeExternal和readExternal方法<br>该类对象可以调用读写方法</li>
<li>直接使用JDK类库<br>上述代码段的使用方式，不再赘述<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><strong>对象序列化写入到对象流中的顺序应该与读取对象反序列化时的顺序一致</strong></li>
</ul>
<h2 id="对于transient关键字的补充"><a href="#对于transient关键字的补充" class="headerlink" title="对于transient关键字的补充"></a>对于transient关键字的补充</h2><ul>
<li>transient只能修饰变量，不能修饰方法和类</li>
<li>被transient修饰的变量不能被序列化；同时，static静态变量不管是否被transient修饰，都不会被序列化</li>
<li>一旦变量被transient修饰，变量将不会被作为持久化对象中的一部分，该变量<strong>内容</strong>在序列化后不能被访问（变量还在，但变量中的值不在了）</li>
</ul>
<h1 id="日常总结"><a href="#日常总结" class="headerlink" title="日常总结"></a>日常总结</h1><p>被虐了……直到现在还在心塞，原理还是不懂，这些Java的小细节可以说是知之甚少，虽然听说过，但怎么用，为什么这么用，实现的原理是什么，一句话都说不出来……<br>关键是还知道这是各种面试笔试都会被提到的高频知识点……讲真的，该去买书看了，JVM、设计模式……</p>
<p>PS：没错，我又开始挖坑了…….剩下的慢慢写好了</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针常量和常量指针]]></title>
      <url>http://yoursite.com/2017/03/18/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h1 id="翻看笔试题绕晕了"><a href="#翻看笔试题绕晕了" class="headerlink" title="翻看笔试题绕晕了"></a>翻看笔试题绕晕了</h1><p>本来翻看着各种笔试题，一切顺利的进行，不会的查一查，记不起来的查一查，直到在看<code>C/C++</code>有关的题目时遇到了</p>
<blockquote>
<p>指针常量和常量指针的区别</p>
</blockquote>
<p>手动黑人问号懵逼</p>
<p>然后，法式懵逼……一种不祥的预感</p>
<p>然后查了一下，世界懵逼……</p>
<h1 id="有这么一种通俗易懂的说法"><a href="#有这么一种通俗易懂的说法" class="headerlink" title="有这么一种通俗易懂的说法"></a>有这么一种通俗易懂的说法</h1><p>查看了好几篇博客，直到看到了这么一种说法：<br><strong>三句箴言：</strong></p>
<ul>
<li>常量 const ，指针 <code>*</code>，谁排在前先读谁</li>
<li><code>*</code> 是指针本身，是地址，<code>const</code>是常量本身</li>
<li><code>const</code>和 <code>*</code> 谁排在前，谁代表的内容就不可以改变<br>举个栗子吧：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *ptr = &amp;a;</div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;b;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面的代码中，ptr就是常量指针，ptr2是指针常量；<br><strong>ptr所指向的地址中的内容是常量</strong>，所以指向内容不可以改变，但是指向的地址可以改变，比如可以<code>ptr = &amp;b</code>，但是不可以<code>*ptr = b</code><br><strong>ptr2所指向的地址不可以改变，但该地址中的内容可以改变</strong>，比如可以<code>*ptr2 = a</code>，但是不可以<code>ptr = &amp;a</code></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>指针常量因为指向的地址不可更改的原因，在定义时一定要初始化（不能为NULL）</p>
<h1 id="指针常量的用处"><a href="#指针常量的用处" class="headerlink" title="指针常量的用处"></a>指针常量的用处</h1><p>指针常量有这么两个可靠性方面的优点：</p>
<ul>
<li>指针不可修改指向，且不能赋值为null</li>
<li>在调用函数时，对于传入的参数可以起到保护的作用，同时还不需要考虑指针为null时的情况</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>其实这是翻译的锅，我们在学习的时候大多用的是翻译过来的说法，如果有心去看一下原文《C Primer plus》，可以看到对于指针常量和常量指针的写法是：</p>
<ul>
<li>常量指针<code>const pointer</code></li>
<li>指针常量<code>pointer to const</code></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的优先队列]]></title>
      <url>http://yoursite.com/2017/03/17/Java%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Form一个问题"><a href="#Form一个问题" class="headerlink" title="Form一个问题"></a>Form一个问题</h1><p>假设百度搜索引擎一天会搜索<strong>M亿条URL</strong>，如何根据URL被搜索的次数来找出次数最高的N个URL呢？<br>个人有一个抽象的思路：</p>
<ul>
<li>先对所有的URL日志文档进行整合，同一类型的当作一个结点，利用B或者B+树搜索的优秀性能来处理</li>
<li>再使用优先队列或者是最大值堆来进行一个排序</li>
</ul>
<p>正确与否先撇开不谈，整合同类URL的过程中会给后续排序减少大量的工作量（但究竟对于这种亿级的数据量还是只有一个朦胧的概念）。不管怎么说，先来研究一下Java中的优先队列好了</p>
<h1 id="优先队列和遍历层次树"><a href="#优先队列和遍历层次树" class="headerlink" title="优先队列和遍历层次树"></a>优先队列和遍历层次树</h1><p>优先队列（PriorityQueue）是不同于普通队列的先进先出的队列，每次从队列中取出的是具有最高优先权的元素。这是从Java1.5开始引入的数据结构的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestPriorityQueue.java</span></div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> id;</div><div class="line">	String name;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = <span class="number">0</span>;</div><div class="line">		<span class="keyword">this</span>.name = <span class="string">""</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriorityQueue</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Student&gt; stCompare = <span class="keyword">new</span> Comparator&lt;Student&gt;()&#123;</div><div class="line">		<span class="comment">// 重写了比较器中的compare方法，否则直接把Student类型的元素加入优先队列会报错</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student st1,Student st2)</span></span>&#123;</div><div class="line">          	<span class="comment">// 针对Student的id属性进行比较</span></div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>)(st1.getId()-st2.getId());</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		Queue&lt;Integer&gt; number = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();<span class="comment">// 存放int类型的数据</span></div><div class="line">		Random rand = <span class="keyword">new</span> Random();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			<span class="comment">//因为实例化时使用了默认的比较器，所以队列新增的元素时都会自动排序</span></div><div class="line">			number.add(rand.nextInt(<span class="number">100</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(Integer i : number)&#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">		</div><div class="line">		<span class="comment">// ----- 下面开始排序自定义类</span></div><div class="line">		<span class="comment">// 把重写后的比较器作为参数传入优先队列</span></div><div class="line">		Queue&lt;Student&gt; students = <span class="keyword">new</span> PriorityQueue&lt;Student&gt;(<span class="number">5</span>,stCompare);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			students.add(<span class="keyword">new</span> Student(rand.nextInt(<span class="number">10</span>),String.valueOf(i)));</div><div class="line">		&#125;</div><div class="line">      </div><div class="line">		<span class="comment">// 预计的输出结果会是：不管st.name是怎样的顺序，但是st.id一定是由小到大</span></div><div class="line">		<span class="keyword">for</span>(Student st : students)&#123;</div><div class="line">			System.out.println(st.id + <span class="string">" "</span> + st.name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遍历层次树"><a href="#遍历层次树" class="headerlink" title="遍历层次树"></a>遍历层次树</h2><p>怎么百度的都是概念层次树（黑人问号….），相关的知识有如何<strong>层次遍历二叉树</strong>，思路是</p>
<ul>
<li>使其根节点入队列，然后出队进行访问</li>
<li>若左子节点不为空，使左子节点入队</li>
<li>若该节点的右子节点，再使右子节点入队</li>
<li>重复上面三个步骤，直到访问了所有节点</li>
</ul>
<p>大概的思路是这样，开的坑已经够多了，这个就先放后面好了 /:doge</p>
<h1 id="又回到了HashMap高性能读写方法？"><a href="#又回到了HashMap高性能读写方法？" class="headerlink" title="又回到了HashMap高性能读写方法？"></a>又回到了HashMap高性能读写方法？</h1><p>其实是自己没有绕出这个圈，那天和dalao讨论的时候，ta认为没有什么优化的方法，毕竟HashMap已经被写好放在jar中了，若是使用，怎么会优化呢？</p>
<p>of cause，自己撸一个HashMap实现，这就引出了一个重点，<strong>在我们讨论这个问题的时候，前提是什么？</strong>，有说可以自己撸吗？不知道，有说必须要用jdk中的HashMap吗？不知道。</p>
<p>So，…….</p>
<h2 id="来来来，填坑了"><a href="#来来来，填坑了" class="headerlink" title="来来来，填坑了"></a>来来来，填坑了</h2><p>上次和面试遇到这道题的那个哥们交流了一下，发现了一些意想不到的事情，起始原始的问题是“HashMap放入10W字符串，怎么做可以减少CPU消耗率”<br>他提出了一种解答方式：<strong>线程睡眠-每放一定数量的字符串后，就令线程睡眠个1s</strong><br>这…..手动笑哭，显然是延长了程序周期，但是确实CPU消耗率降下来了…….</p>
<h1 id="日常总结"><a href="#日常总结" class="headerlink" title="日常总结"></a>日常总结</h1><p>今天被教育“凡是遇到问题的时候，第一个想到的就应该是<strong>前提条件</strong>”，没有前提条件，问题是不受约束的。看似是一个谁都懂的道理，但真的很多时候，会被<strong>自己潜意识认为的条件局限了自己的思维</strong>。就这样。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap和HashTable的区别]]></title>
      <url>http://yoursite.com/2017/03/16/HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p>昨天听说了这么一道题，往HashMap中读写10w条字符串，如何处理可以消耗更少的cpu资源。后面感觉有点蹊跷，不知所以<br><img src="/2017/03/16/HashMap和HashTable的区别/1.jpg" alt="HashMap和HashTable的区别"><br>后面问了dalao黄一下，问题是没有解决，但是言语之间似乎有这么一个信息，<strong>HashMap和HashTable在存储数据时是有区别的</strong><br><img src="/2017/03/16/HashMap和HashTable的区别/2.jpg" alt="HashMap和HashTable的区别"><br>我是想啊，要么HashTable对数据量大的情况下有更好的存储性能？？？，要么是HashTable有更好的并行<br>性？？？</p>
<p>of cause，查一下嘛</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>大概主要的意思是有这么几点区别：<br>两者继承自不同的类，HashMap是HashTable的轻量级实现（非线程安全的实现），但都完成了Map接口</p>
<blockquote>
<ul>
<li>​HashMap去掉了HashTable中的contains方法，但是加上了containsValue()和containKey()方法</li>
<li>HashTable是同步的，而HashMap是非同步的，由于非线程安全，效率上比HashTable要高</li>
<li>​HashMap允许空键值，而HashTable不允许</li>
</ul>
</blockquote>
<p>HashMap和HashTable采用的hash/rehash算法大致一样，性能不会差很多</p>
<h2 id="一些其它的小细节"><a href="#一些其它的小细节" class="headerlink" title="一些其它的小细节"></a>一些其它的小细节</h2><ul>
<li>HashMap和Hashtable都实现了Map接口</li>
<li>HashMap是非synchronized，而Hashtable是synchronized</li>
<li>HashTable使用Enumeration，HashMap使用Iterator； HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。</li>
<li>Hashtable直接使用对象的hashCode，HashMap重新计算hash值，而且用与代替求模</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好吧，虽然看起来差别不大，但是真的要并行式去存储会不会可以呢？（不晓得啊，其实也不是很懂并行 0.0 ），问题过两天解决了再继续更好了<br><img src="/2017/03/16/HashMap和HashTable的区别/3.jpg" alt="HashMap和HashTable的区别"></p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三月中]]></title>
      <url>http://yoursite.com/2017/03/12/%E4%B8%89%E6%9C%88%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h1 id="几句随谈"><a href="#几句随谈" class="headerlink" title="几句随谈"></a>几句随谈</h1><p>前几天听胡哥讲课（正经课），理所当然的提到了鸡汤（这不是日常吗），本着我就静静的看着的心态<br><img src="/2017/03/12/三月中/show.jpg" alt="show"><br>突然某些话还是触动了什么…<br>遇到不会的解决不了的怎么办？看书上网查资料，还是不会呢？问有经验的人，要还是解决不了呢？</p>
<p>解决问题而不是解释问题，总想着等我把这个学完了再开始弄这个，什么时候是个头？</p>
<p>买书！买什么书？酸透了的爱情文学？《二十岁的青春》？愤世嫉俗的批判分析？熟悉人情掌控全局的厚黑学？买了你看了吗？为什么坚持一定要买？</p>
<h1 id="突然明白了什么"><a href="#突然明白了什么" class="headerlink" title="突然明白了什么"></a>突然明白了什么</h1><p>其实，有时候努力钻研但是举步维艰而心生退意很正常，我花了这么多时间，回报呢？受益呢？别人这么久都又敲了那么多代码，看了那么厚的书，然而，自己还是没有把问题解决…….可是，看书不会问人，问人再不会再看书，周而复始，没有一点点进步吗？没有一点点收获吗？每一天只要不虚度踏实的学习，不管在干什么，这不都是收获吗？</p>
<p>总想着不会，不敢，想着先大概了解一下内容，然后再用，再看，确实很低效，但是没有办法，有时候，就是想知道为什么，就是不想稀里糊涂的完成了，这是一种感觉是一种情怀，没有为什么，没有不敢、怂，可是确实和内心的想法有矛盾？</p>
<p>买书好，一定要花钱，不然不心疼，花钱是一种享受，买了可以不看，太多了的时候可以扔，扔的时候会有一个筛选的过程，尽管可能是不自知的，但一直都认为，提高生活质量的最有效方式就是定期扔东西，something and sometimes，同理</p>
<h1 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h1><p>本来几天前就该写的，因为周一下午接到了面试电话，约到了周二晚上，怀着忐忑的心准备了，并等待着，等到了电脑没电，等到了深夜，电话没有打来……第一次经历这样的事情（说不清楚心理变化），唯一能想得就只有继续前进，满满的压力，来自四面八方，羡慕dalao，只是希望到自己面对社会时，能感到，还好我做到了</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射机制]]></title>
      <url>http://yoursite.com/2017/03/11/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="前言碎语"><a href="#前言碎语" class="headerlink" title="前言碎语"></a>前言碎语</h1><p>刚开始学习时其实是跳过了这么一个知识点的（因为确定难懂又暂时没什么用），后面听说了在框架中反射是基本的原理，我就又滚回来了（出来混迟早要还的，深以为然）</p>
<h1 id="反射机制是什么？"><a href="#反射机制是什么？" class="headerlink" title="反射机制是什么？"></a>反射机制是什么？</h1><blockquote>
<p>反射机制是能在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息的以及动态调用对象的方法的功能成为java反射机制</p>
</blockquote>
<p>反射是为了动态的加载java类，使得程序在编译时不需要知道某些类的具体信息，只有在运行的时候根据输入的类（补全了某些类的信息），来动态的加载该类，并运行其中的方法。</p>
<h1 id="反射机制有什么用？"><a href="#反射机制有什么用？" class="headerlink" title="反射机制有什么用？"></a>反射机制有什么用？</h1><p>看过一篇博客，举了这么一个通俗易懂的例子：<br>两个程序员A和B一起工作，因为工作的原因，两个人的任务是分开完成的，同时也是为了保证工程进度；但是程序员A的任务中需要用到程序员B的代码，那么如何在<strong>保证A的任务能够进行下去同时又能保证A和B一起推进任务</strong>呢？<br>这时就需要用到了java反射的机制。按照上面的说法，我们可以在A的代码中先对所需要B中的某个类进行<strong>代理使用</strong>，这样可以保证A的程序编译通过；然后在程序运行的时候，通过某种方式（传参数）来获取到真正想要调用的类。这样在程序运行时就会使用到该类的<code>动态代理对象</code>，从而完成任务。</p>
<h1 id="反射机制的原理"><a href="#反射机制的原理" class="headerlink" title="反射机制的原理"></a>反射机制的原理</h1><p>看了上面的介绍以，我就在想这是怎么实现的（感觉这个反射是为了骗过编译器啊….）</p>
<p>首先说一下动态加载，我们知道jvm在运行java程序前会先加载所使用到的类进行编译，而有的类是在编译时期不知道的，只有在运行的时候才会加载，此谓动态加载。在实现动态加载类时，又有一个<code>动态的代理机制</code>在里面：<br>所谓动态代理，就是程序在运行的时候，对于一个接口和实现类，可以<strong>由JVM生成一个代理对象来帮助你使用接口或类中的方法</strong>（而不需要显式的去实例化一个类的对象）<br>这样我们可以在程序中直接使用代理对象，完成操作。</p>
<h1 id="反射机制的常规用法"><a href="#反射机制的常规用法" class="headerlink" title="反射机制的常规用法"></a>反射机制的常规用法</h1><p>对于编译时知道类的信息的情况就不说了，上一篇Class里面有涉及，具体使用时查API文档就好，这里说编译时期不知道类的信息的情况</p>
<ul>
<li><p>定义一个动态代理类，该类必须实现<code>InvocationHandler</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 这个是要代理的对象</span></div><div class="line">    <span class="keyword">private</span> Object subject;</div><div class="line">    </div><div class="line">    <span class="comment">// 构造方法，给要代理的对象赋初值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object subject)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></div><div class="line">    	<span class="comment">// blablabla... </span></div><div class="line">        </div><div class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象的invoke方法来进行调用</span></div><div class="line">        method.invoke(subject, args);</div><div class="line">        </div><div class="line">        <span class="comment">// 在代理真实对象后也可以添加一些操作</span></div><div class="line">        <span class="comment">// blablabla...</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用Class类来获取所需要代理的类；<a href="http://zpcheng.me/2017/03/10/java反射之Class初级用法/#more" target="_blank" rel="external">java中Class的用法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class testClass = Class.forName(str);<span class="comment">// str可以以字符串的形式传入</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建一个动态代理对象并开始使用被代理对象中的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"> 		<span class="comment">// 需要代理的真实对象</span></div><div class="line">        Object realObject = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">        <span class="comment">// 将真实对象传入，最后是通过代理对象来调用其方法的</span></div><div class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(realObject);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 代理对象obj，通过Proxy的newProxyInstance方法来创建</div><div class="line">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载代理对象</div><div class="line">         * 第二个参数realObject.getClass().getInterfaces()，这里为代理对象提供的接口是真实对象所实现的接口，表示要代理的是该真实对象，这样就能调用这组接口中的方法了</div><div class="line">         * 第三个参数handler， 将这个代理对象关联到了上方的 InvocationHandler 这个对象上</div><div class="line">         */</div><div class="line">        Object obj = (Object)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realObject.getClass().getInterfaces(), handler);</div><div class="line">     </div><div class="line">        obj.wait(<span class="number">10</span>); <span class="comment">// 这样使用代理对象来直接调用被代理类的wait方法，并输入参数</span></div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有需要注意的地方：<strong>Proxy的newProxyInstance方法的第二个参数，意思是代理对象去实现了被代理对像的接口</strong>，这样代理对象才可以去使用被代理对象实现接口或继承类中的方法。同时如果打印出代理对象的<code>obj.getClass().getName()</code>会显示<code>$proxy0</code>，因为这是JVM自动动态生成的代理对象（与使用时自己初始化代理对象不是一个意思，初始化主要是为了传入被代理对象），这是一种固定的命名方式。</p>
<h2 id="总结反射顺序"><a href="#总结反射顺序" class="headerlink" title="总结反射顺序"></a>总结反射顺序</h2><ul>
<li>创建一个代理类，实现<code>InvkcationHandler</code>接口</li>
<li>重写<code>invoke()</code>方法，并调用<code>method.invoke()</code></li>
<li>声明真实对象，并传入代理类</li>
<li>声明代理对象，并初始化为<code>Proxy.newProxyInstance()</code>方法获得的实例</li>
<li>使用代理对象调用真实对象的方法</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>一定要使用<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</code>方法实例化代理对象</li>
<li>代理类中的<code>invoce(Object proxy, Method method, Object[] args)</code>方法是由代理对象隐式调用的</li>
<li>直接使用代理对象调用真实对象的方法即可</li>
</ul>
<h1 id="使用反射的利弊"><a href="#使用反射的利弊" class="headerlink" title="使用反射的利弊"></a>使用反射的利弊</h1><p><strong>优点</strong>：<br>反射提高了程序的灵活性以及扩展性，降低了耦合性（依赖关系），提高了程序的适应能力；允许程序在不知道具体类的信息的情况下，创建和控制任何类的对象。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>性能问题：使用反射时是一种解释操作，用于字段和方法接入时要远慢于直接代码（这事必然啊，总要能理解吧），所以反射机制主要应用于灵活性和扩展性要求很高的系统框架上，普通程序不建议使用</li>
<li>模糊程序内部逻辑：反射绕过了源代码的技术会带来后期的维护问题，毕竟看反射代码更难</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实当我们使用编译器，在对象后面加上<code>.</code>时，编译器会自动列出该对象中的所有属性以及方法，这里就用到了这个原理，并称之为<strong>java类的自审</strong>，可以探知到类的基本结构。</p>
<p>上面的内容都是我在学习时自己提出的问题，越来越感觉在学一个知识点时主动挖掘它的原理是重要的（虽然有的并不需要也并不会想到），开始萌发要看看JVM底层原理的书的念头了….</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射之Class初级用法]]></title>
      <url>http://yoursite.com/2017/03/10/Java%E5%8F%8D%E5%B0%84%E4%B9%8BClass%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>Class类的实例表示java应用运行时的类或接口（每个java类在运行的时候都会在JVM里表现为一个Class对象，可以通过<code>类名.Class</code>，<code>类型.getClass()</code>，<code>Class.forName(&quot;包.类名&quot;)</code>等方法获取Class对象）</p>
<h2 id="Class类的特点"><a href="#Class类的特点" class="headerlink" title="Class类的特点"></a>Class类的特点</h2><p>Class类的父类是Object，事实上，任何java类，不管是jdk里面的还是自定义的，都是Class类的对象，同时，所有的数据类型、关键字、方法等等，一切的一切都是Class类的对象。这是前提，很关键</p>
<h2 id="Class类的运行原理"><a href="#Class类的运行原理" class="headerlink" title="Class类的运行原理"></a>Class类的运行原理</h2><p>java种创建对象时不是通过类直接创建的，一个类的对象被创建之前，首先JVM会加载该类的字节码文件（.class文件），也就是编译后的java程序文件；加载完成后，JVM会自动的为该类创建自己的Class对象，再通过Class对象创建目标对象</p>
<h1 id="使用Class的目的"><a href="#使用Class的目的" class="headerlink" title="使用Class的目的"></a>使用Class的目的</h1><p>很简单的一句话，可以利用反射机制重新获取到Object对象，这个是动态加载类以及对象的，是在程序运行时才会发生的动作，至于反射机制的具体应用，先挖个坑，以后填</p>
<h1 id="API文档的仿制"><a href="#API文档的仿制" class="headerlink" title="API文档的仿制"></a>API文档的仿制</h1><p>按照Class类的特性，java种的一切都是Class类的对象，我们可以获取到这些“对象”的信息，比如任意类的属性、构造方法、所有方法等等信息，诚然，我们甚至可以做出一个API文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</div><div class="line">		<span class="comment">// 1.返回与带有给定字符串名的类或接口相关联的 Class 对象，直接导致该类被初始化</span></div><div class="line">		Class testClass = Class.forName(<span class="string">"java.lang.Class"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">// 2. 获取该类的实例化对象</span></div><div class="line">		Class testClass2 =  Class.class;</div><div class="line">		</div><div class="line">		<span class="comment">// 3.获取该类的实例化Class对象</span></div><div class="line">		Class testClass3 = <span class="keyword">new</span> Test().getClass();</div><div class="line">		</div><div class="line">		String target = <span class="string">"([a-zA-Z_-]+)\\."</span>; <span class="comment">// 需要匹配的正则表达式，表示了形如“字母+.”的模式，这样便去除了某个类的包名前缀</span></div><div class="line">		</div><div class="line">		Class&lt;? <span class="keyword">super</span> Object&gt; superC = testClass.getSuperclass();</div><div class="line">		String name = superC.getName();</div><div class="line">		System.out.print(<span class="string">"Class的父类是："</span> + name.replaceAll(target, <span class="string">""</span>) + <span class="string">"\n"</span>);</div><div class="line">		</div><div class="line">		Constructor&lt;Class&gt;[] consClass = testClass.getDeclaredConstructors();</div><div class="line">		System.out.println(<span class="string">"Class的构造方法有："</span>);</div><div class="line">		<span class="keyword">for</span>(Constructor con : consClass)&#123;</div><div class="line">			name = con.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Class&lt;Class&gt;[] classes = testClass.getClasses();</div><div class="line">		System.out.println(<span class="string">"Clsass所有的成员的公共类和接口："</span>);</div><div class="line">		<span class="keyword">if</span>(classes.length==<span class="number">0</span>)</div><div class="line">			System.out.println(<span class="string">"null"</span>);</div><div class="line">		<span class="keyword">for</span>(Class cla : classes)&#123;</div><div class="line">			name = cla.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"Class的属性是："</span>);</div><div class="line">		Field[] fields = testClass.getDeclaredFields();</div><div class="line">		<span class="keyword">for</span>(Field f : fields)&#123;</div><div class="line">			name = f.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Method[] methods = testClass.getMethods();</div><div class="line">		System.out.println(<span class="string">"Class的所有方法是："</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;methods.length; i++)&#123;</div><div class="line">			name = methods[i].toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		ClassLoader loader = testClass.getClassLoader();<span class="comment">// 如果对象是基本类型或者是void，则返回null</span></div><div class="line">		System.out.println(<span class="string">"Class的类加载器是："</span> + loader);</div></pre></td></tr></table></figure></p>
<p>这只是一个简单的思路介绍，重要的是从0到1的过程，至于怎么从1到n，这需要更多的努力。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解HashMap]]></title>
      <url>http://yoursite.com/2017/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      <content type="html"><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>哈希，译作散列，或哈希。就是把任意长度的输入，通过散列算法（hash算法），变换成固定长度的输出，这个输出的值就是哈希值。显然这是一个映射的过程。</p>
<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p>再来看一看HashCode，这是一个方法，该方法返回一个特殊的值，在java中会返回一个整数，用来判断是否是两个相同的对象，和equals方法有紧密的联系：</p>
<ul>
<li>HashCode主要用于提供快捷的查找，在HashTable和HashMap中都有使用，HashCode是用来在散列存储结构中确定对象的存储地址的（之所以这样说是因为index的计算与hashCode息息相关）</li>
<li>如果使用equals(Objetc)方法，两个对象相等，那么这两个对象调用hashCode方法返回的值一定是相等的</li>
<li>如果两个对象中的equals方法被重写了，那么一定也要按照同样的方法来重写hashCode方法（这是为了保持hashCode方法的常规协定，规定了相等对象必须有相同的hashCode值）</li>
<li>借用网上看来的文章的一句话：两个对象的hashCode相同（其实更应该说成通过hashCode计算出的index相同），不代表就是同一个对象/两个对象相同，在hash存储结构中，这只说明了两个对象发生了冲突，被分配在了同一个桶里面。java判断两个对象是否相同还会判断对象引用中存储的地址是否相同（默认）</li>
</ul>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>hash函数，用来计算出哈希值的函数，通常情况下，每一个对象都有自己单独的哈希值，通过hash函数计算出后，可以做到唯一识别。虽然有可能会有冲突的情况出现，出现了同一个hash值，但概率是微乎其微再来n个微乎其微…..<br>hash函数的用途有这么几个：可以这么说，hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<ul>
<li>文件校验：通过对文件摘要，可以对文件进行校验，一定程度上能检测并纠正数据传输中的信道误码，但不能防止对数据的恶意破坏</li>
<li>数字签名：在数字签名协议中，用的最多的单向散列函数可以产生一个机构的数字签名</li>
<li>数据结构中提供快速查找的功能：常用的数据结构HashMap和HashTable会使用到Hash函数来产生hash值，是组成HashMap优越性能必不可少的一环</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>在分析这个HashMap之前我们先来看一看数组和链表，我们都知道，数组提供了很好的查找性能，因为数组空间是连续的，查找起来很方便，但是在数据的插入和删除时，性能就不佳了；再看链表，它的存储空间是离散的，所以在数据的插入删除时，性能很高，但是当论到查找时，其性能就不行了。<br>综上所述，我们总是在面对问题时，根据自己的需求来使用不同的数据结构，这是权衡和妥协的结果。那么我们如果能使用到一种数据结构，它提供良好的查找性能，又可以很方便的插入删除。于是乎，把这两种数据结构组合起来就有了我们这个HashTable。<br>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/05/深入理解HashMap/hash.png" alt="hash"><br>从图中可以看出，这是由数组和链表组成的数据结构，在数组中每个元素存储的是一个链表的头指针，把一个个数据存放到相应的位置，就需要由hash函数来计算了，一般是采用<strong>index=hash(value)%length计算出元素应该放到对应下标的数组中的位置</strong>。比如，如果value为5，数组长度为10，则计算出的下标位置就是5%10=5，这个值应该放到下标为5的元素中。当然了，如果俩个值计算出存放的位置相同了，就<strong>以后存入的值为头节点，以链表的形式存入，以此类推</strong></p>
<p>现在回过头来看看HashMap，它其实也是一个线性的数组实现的，所以可以理解为其存储的数据结构就是一个线性数组。但是有一点我们需要注意的就是，HashMap是按照键值对来存取数据的，这一点怎么可能通过数组或是链表来实现呢？</p>
<p>深入到HashMap的源码中去看，对照着资料，发现在HashMap中存取数据的关键有一个叫做Map.Entry的内部接口很是关键，再去看Entry，发现它被定义为<code>Entry&lt;Key,Value&gt;</code>，而<strong>Map.Entry<k,v>就是一个键值对的实体</k,v></strong>。如果说HashMap是依靠于数组存储，那么这个数据就是Entry[]，Map存储的内容都在Entry[]里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Entry[] table;</div></pre></td></tr></table></figure></p>
<h2 id="HashMap存取的实现"><a href="#HashMap存取的实现" class="headerlink" title="HashMap存取的实现"></a>HashMap存取的实现</h2><p>在“线性数组”的基础上如何做到随机存储呢：重点是确定键值对的存储位置，这里是希望HashMap里面的元素尽量离散分布，使每个位置上的元素只有一个。当使用hash算法求出这个位置时，马上就可以获取对应位置的值，而不用取遍历链表。也与hash方法的离散性能密切相关<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hash jdk1.8</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说起来，这里的Hash算法本质上就是三步：<strong>取key的hashCode的值、高位运算、取模运算</strong><br>对于任意对象，只要hashCode返回值相同，那么程序调用方法所计算的Hash码时一样的，把hash值对数组的长度取模运算，这样元素的分布相对来说是比较均匀的。在上面的方法中，通过<strong>把hashCode返回值高16位和低16位与计算，达到了hashCode返回值取模数组长度的效果</strong>。因为在HashMap底层数组中，length总是2的n次方（不够的用null填充），此时<strong>使用hashCode返回值与数组长度进行与运算</strong>依然达到了上述的效果，这是jdk1.7中的实现方法，在1.8中高16位与低16位进行与运算是优化的算法，能保证在hashCode返回值很大时，高低Bit都会参与到hash运算中，并且不会产生较大的开销</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>我们知道HashMap中<strong>键 Key</strong>一定是唯一的，那么当再次往HashMap中存入键相同的键值对时，上一次存入的键值对就会被<strong>覆盖</strong>。但是如果两个键值对的index值一样时，HashMap会把先存入的值放入链表的尾部，<strong>最新加入的值则是该线性数组中每个下标对应的链表的首元素</strong>，以此类推。<br><strong>需要注意到的是，jdk1.8新增了HashMap链表中节点的个数对于8个时，转为红黑树的存储方式</strong><br>查看HashMap中的put方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> 		<span class="comment">// 进行hash运算</span></div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">// 判断键值对数组table是否为空或null，否则进行resize扩容</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        <span class="comment">// 根据键值key计算hash得到插入位置的索引</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">// p被赋值</span></div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">// 判断键值对中key是否存在（相同），存在直接覆盖，相同指hashCode和equals</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            <span class="comment">// 判断是否为树，是的话直接插入新结点</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">// 链表</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 如果链表的长度大于8就 转化为红黑树处理</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// key已经存在，直接覆盖</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 存在key的映射</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">// 插入成功判断是否超出了最大容量，是就进行扩容</span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>reszie的源码是将原来数组的容量扩大一倍，<strong>这个过程是一个十分消耗性能的过程，所以在使用中最好定一个预定的最大值，避免HashMap进行频繁的扩容</strong>。默认的负载因子是0.75</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>还一个小细节就是，每次put入键值对时，都是先比较key的hashCode，再去使用equals比较key，这样可以节省查重的效率</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>首结点都是Entry类型的键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 先检查链表中的首结点</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first; <span class="comment">// 判断出了与key相同（hashCode和equals）</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            	<span class="comment">// 继续根据hash查找</span></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="comment">// 不在首结点，不在红黑树，只能遍历链表</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="null-key"><a href="#null-key" class="headerlink" title="null key"></a>null key</h3><p>null key总是放在Entry[]数组的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="获得索引值index"><a href="#获得索引值index" class="headerlink" title="获得索引值index"></a>获得索引值index</h3><p>HashMap存取时需要计算索引index来确认到Entry[]数组取元素的位置，也就是获取数组下标的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * Returns index for hash code h.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按位取并，作用上相当于取模：<code>index = hashcode % table.length</code></p>
<h3 id="hashtable初始大小"><a href="#hashtable初始大小" class="headerlink" title="hashtable初始大小"></a>hashtable初始大小</h3><p>在调用HashMap的无参构造方法时，初始大小是16。当后续大小改变时，table初始大小总是2的n次方（没有填充满就空着）</p>
<h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>我们总是希望整个HashMap是一个尽量离散的优秀结构，用尽量少的空间存储尽量多的数据，且其查找增删的性能依据很高效。这个是一个复杂的平衡过程，和负载因子相关，和解决hash冲突的办法相关：hash冲突是指两个key被分配到了同一个桶中，其实就是通过hashCode计算出的index值一样</p>
<ul>
<li>开放定址法（线性探查再散列、二次探查再散列、为随机探查再散列）</li>
<li>再哈希法</li>
<li>链地址法（拉链法）</li>
<li>建立一个公共的溢出桶<br><strong>java中的HashMap使用的就是拉链法，如前面图所示</strong></li>
</ul>
<h2 id="再散列过程-rehash"><a href="#再散列过程-rehash" class="headerlink" title="再散列过程 rehash"></a>再散列过程 rehash</h2><p>当哈希表的容量超过默认的大小时，就需要将所有的元素换一个新的“桶”来存储，这个新的桶中的键值对存放的位置会发生改变，需要重新根据新桶的大小来重新计算各个键值对的索引位置，这个过程就叫做rehash</p>
<h1 id="谈一谈血与泪"><a href="#谈一谈血与泪" class="headerlink" title="谈一谈血与泪"></a>谈一谈血与泪</h1><p>之所以新加上这个片段就是因为真是彻底的被自己的记性教育了，这真是血淋林的教训啊，已经不记得有几次面试时答错了，这里总结记录一下：</p>
<ul>
<li>HashMap是非线程安全的，HashTable才是线程安全的</li>
<li>HashMap中允许有<code>null</code>键值对，HashTable不允许</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此次深入探究java中的HashMap查阅了不少资料和源码，感谢先行者的指引，这里仅是个人愚见，如有异议，欢迎联系<br><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="external">HashMap实现原理分析</a><br><a href="http://www.importnew.com/20386.html" target="_blank" rel="external">java8重新认识HahsMap</a></p>
<p><img src="/2017/03/05/深入理解HashMap/lianhong.jpg" alt="lianhong"></p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet重定向与转发区别]]></title>
      <url>http://yoursite.com/2017/03/02/Servlet%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>servlet在对客户端请求的数据处理之后，会向客户端返回相应的响应结果。这个响应结果可以是由当前servlet对象的PrintWriter输出流直接输出到页面上的信息，也可以是一个新的URL地址对应的信息。<br>在servlet中通过两种方式完成对新URL地址的转向：重定向和请求转发。</p>
<h2 id="URL与URI区别"><a href="#URL与URI区别" class="headerlink" title="URL与URI区别"></a>URL与URI区别</h2><p>一图胜千言系列  ↓↓↓<br><img src="/2017/03/02/Servlet重定向与转发区别/url.png" alt="url"></p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>由原请求地址重新定位到某个新地址，原有的请求失效，客户端看到的是新的请求返回的响应结果，客户端浏览器地址栏变为新的请求地址。其中第二次请求是由客户端浏览器自动发出。<br><img src="/2017/03/02/Servlet重定向与转发区别/redirect.png" alt="redirect"></p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>请求转发是将请求再转发到其他地址，转发过程中使用的是同一个请求，转发后浏览器地址栏内容不变。<br><img src="/2017/03/02/Servlet重定向与转发区别/dispatcher.png" alt="dispatcher"></p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>转发只能将请求转发给同一个web应用（项目工程）中的其他组件（servlet程序）；重定向可以重定向到任意的地址，网络地址或是文件地址（跨项目文件夹）</li>
<li>重定向访问结束后，浏览器地址栏URL发生变化，变成了重定向后的URL；转发则不变</li>
<li>重定向对浏览器的请求直接做出响应，结果就是告诉浏览器去重新发出另一个新的URL访问请求；请求转发在服务器端内部将请求转发给另一个资源，浏览器不知道服务器程序内部发生了转发过程</li>
<li>请求转发调用者与被调用者之间共享相同的请求对象，属于同一个请求和响应过程；重定向则是不同的请求和响应过程</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[alter和update以及drop和delete区别]]></title>
      <url>http://yoursite.com/2017/02/28/alter%E5%92%8Cupdate%E4%BB%A5%E5%8F%8Adrop%E5%92%8Cdelete%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用MySQL时，很多语法相似，容易记浑，比如alter和update，比如drop和delete。</p>
<h1 id="alter和update区别"><a href="#alter和update区别" class="headerlink" title="alter和update区别"></a>alter和update区别</h1><ul>
<li>alter是对表的结构进行的操作，比如增加删除表的字段，或者是修改字段的顺序</li>
<li>update是对表中的数据进行的操作，比如依据某个字段修改当前记录中另一个字段的值</li>
</ul>
<h1 id="drop和delete区别"><a href="#drop和delete区别" class="headerlink" title="drop和delete区别"></a>drop和delete区别</h1><ul>
<li>drop是对表本体进行的操作，比如删除整张表。如果需要对表的结构进行增删，使用alter</li>
<li>delete是对表的数据进行的操作，比如删除某一条记录</li>
</ul>
<p>总的来说，如果你不想要这张表了，用drop，如果你还想用这张表，只是删除一些数据，用delete</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL使用手册]]></title>
      <url>http://yoursite.com/2017/02/28/MySQL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="MySQL语法总结"><a href="#MySQL语法总结" class="headerlink" title="MySQL语法总结"></a>MySQL语法总结</h1><h2 id="MySQL结构："><a href="#MySQL结构：" class="headerlink" title="MySQL结构："></a>MySQL结构：</h2><p>数据库中存放数据都是依托与一张张的数据表存在的，我们通过数据库可以高效的利用数据；而我们对数据的操作就是对数据库中的表的操作。</p>
<h2 id="SQL数据类型："><a href="#SQL数据类型：" class="headerlink" title="SQL数据类型："></a>SQL数据类型：</h2><p>字符型：<code>&lt;varchar&gt; VS &lt;char&gt;</code><br>文本型：<code>&lt;text&gt;</code><br>数值型：<code>&lt;int&gt; VS &lt;smallint&gt; VS &lt;tinyint&gt;</code><br>浮点型：<code>&lt;float&gt; VS &lt;decinal&gt;</code><br>逻辑型：<code>&lt;bit&gt;</code><br>日期型：<code>&lt;datetime&gt; VS &lt;smalldatetime&gt;</code></p>
<h2 id="MySQL基本操作（格式）："><a href="#MySQL基本操作（格式）：" class="headerlink" title="MySQL基本操作（格式）："></a>MySQL基本操作（格式）：</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p><code>mysql -u root -p</code><br>默认没有密码，直接回车，也可以自行修改密码。<br>操作数据库中的表单时，一定要先<code>USE &lt;数据库名&gt;</code>来进入该数据库</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>创建数据库：<code>CREATE databases &lt;数据库名&gt;;</code></li>
<li>创建表单：<code>CREATE table &lt;表名&gt;;</code></li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>单表查询</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT &lt;字段名一，字段名二，...&gt;</div><div class="line">FROM &lt;表名&gt;</div><div class="line">WHERE &lt;查询条件&gt;;</div></pre></td></tr></table></figure></p>
<ul>
<li>查询所有数据库：<code>SHOW DATABASE;</code></li>
<li>选中某个数据库进行操作：<code>USE &lt;数据库名&gt;</code></li>
<li>查询某数据库中所有的表：<code>SHOW TABLES;</code></li>
<li>查询表中某字段的数据：<code>SELECT &lt;字段名一,字段名二....&gt; FROM &lt;表名&gt;;</code></li>
<li>查询某记录：<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;;</code><ul>
<li>（多个）查询条件：<code>&lt;字段名&gt; =值 &amp;&amp; &lt;字段名&gt; =值</code></li>
</ul>
</li>
<li>查询表中的所有记录：<code>SELECT * FROM &lt;表名&gt;;</code></li>
<li>查询表结构字段名（不包含外键）：<code>DESC &lt;表名&gt;;</code></li>
<li>查询表创建时（修改后）的SQL语句：<code>SHOW CREATE TABLE &lt;表名&gt;;</code>可以用来查看外键信息</li>
<li>查询从指定位置开始、一定数量的记录：<code>SELECT &lt;列名&gt; FROM &lt;表名&gt; LIMIT &lt;查询数量&gt; OFFSET &lt;开始位置&gt; ;</code></li>
</ul>
<p><strong>连接查询</strong>：可以使用表的别名（eg：table1 A）</p>
<ul>
<li>内连接-等值连接：指使用等号”=”比较两个表的连接列的值，相当于两表执行笛卡尔后，取两表连结列值相等的记录-<code>SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; INNER JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt;;</code></li>
<li>内连接-非等值连接：<code>SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; INNER JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; &gt;(或者&lt;) &lt;表名B.字段名&gt;;</code></li>
<li>外连接-左外连接：指将左表的所有记录与右表符合条件的记录匹配，返回的结果除内连接的结果，同时如果有左表不符合条件的记录，就在右表相应列中填NULL-<code>SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; LEFT JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt;</code></li>
<li>外连接-右外连接：<code>SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; RIGHT JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt;</code></li>
<li>自然连接：MySQL中的自然连接是自动将两个表中相同名称的列进行记录匹配<code>SELECT &lt;表名A.字段名&gt;,&lt;表名B.字段名&gt; FROM &lt;表名A&gt; NATURAL JOIN &lt;表名B&gt;;</code></li>
<li>自连接：用别的表实现自身表的连接-<code>SELECT &lt;表名B.字段名(*)&gt; FROM &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; WHERE &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt; AND &lt;查询条件&gt;;</code></li>
</ul>
<p><strong>嵌套查询</strong>：将一个查询块嵌套在另一个查询块的WHERE子句或者HAVING短语的条件中的查询</p>
<ul>
<li>含IN的子查询：可以多层嵌套-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; IN (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;);</code></li>
<li>含ANY的子查询：查询的条件符合另一个查询结果的任一个即可-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; &lt;ANY(或者是&gt;ANY、=ANY) (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;)</code></li>
<li>含EXISTS的子查询：EXISTS代表存在量词∃。带有EXISTS谓词的子查询不返回任何数据，只产生逻辑值true或者false-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; EXISTS (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;)</code></li>
</ul>
<p><strong>集合查询</strong>：SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作主要包括并操作UNION、交操作INTERSECT、差操作EXCEPT，在MySQL替换过来就是<code>OR</code>、<code>AND</code>、<code>EXISTS/IN</code></p>
<ul>
<li>集合并查询：实质上是进行两次查询操作然后将结果取并集-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; UNION  SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;</code>，可以使用语句取代-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; OR &lt;查询条件&gt;</code></li>
<li>集合交查询：MySQL不支持直接的交集查询，使用替代语句-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; AND &lt;查询条件&gt;</code></li>
<li>集合差查询：MySQL不支持直接的差集查询-<code>SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; AND &lt;查询条件&gt;</code>，具体使用时逻辑符号会变。或者使用<code>IN</code>或者<code>EXISTS</code></li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>按照某字段升序排列：<code>SELECT * FROM &lt;表名&gt; ORDER BY &lt;字段名&gt; LIMIT &lt;待排列的记录数&gt;;</code></li>
<li>降序排列：<code>SELECT * FROM &lt;表名&gt; ORDER BY &lt;字段名&gt; DESC LIMIT &lt;待排列的记录数&gt;;</code></li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>插入记录：<code>INSERT INTO &lt;表名&gt; VALUES(&#39;...&#39;,&#39;&#39;,&#39;&#39;,....);</code></li>
<li>插入某一字段：<code>ALTER TABLE &lt;表名&gt; ADD &lt;字段名&gt; &lt;字段类型&gt; ;</code></li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除数据库：<code>DROP DATABASE &lt;数据库名&gt;;</code></li>
<li>删除未被外键关联的表：<code>DROP TABLE IF EXISTS &lt;表名&gt;;</code></li>
<li>删除已经外键关联的表：先删除子表再删除父表</li>
<li>删除表中的某一条记录：<code>DELETE FROM &lt;表名&gt; WHERE &lt;字段=值&gt;;</code></li>
<li>删除表中的某一字段：<code>ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;;</code></li>
<li>删除外键约束：<code>ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键名&gt;</code></li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>修改表名：<code>ALTER TABLE &lt;旧表名&gt; RENAME TO &lt;新表名&gt;;</code></li>
<li>修改表中的字段名：<code>ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;数据类型&gt;;</code></li>
<li>修改表中字段的数据类型：<code>ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;新数据类型&gt;;</code></li>
<li>修改表中字段的顺序：<code>ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt; FIRST/AFTER &lt;字段名&gt;;</code></li>
<li>修改表中某一记录某一字段的值：<code>UPDATE &lt;表名&gt; SET &lt;字段名&gt;=&lt;新值&gt; WHERE &lt;查询条件&gt;;</code></li>
<li>在表都创建之后添加外键：<code>ALTER TABLE &lt;需要添加外键的表名&gt; ADD CONSTRAINT &lt;外键名&gt; FOREIGN KEY(&lt;需添加外键的表的字段名&gt;) REFERENCES &lt;被作为外键的表名&gt; (&lt;被作为外键的字段名&gt;);</code></li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>index索引可以有重复的值，而unique和primary key索引列中的值时唯一的</p>
<ul>
<li>ALTER创建索引（可同时添加多个表的索引列）<ul>
<li><code>ALTER TABLE &lt;表名&gt; ADD INDEX &lt;索引名（可省缺）&gt;(索引字段名);</code></li>
<li><code>ALTER TABLE &lt;表名&gt; ADD UNIQUE(&lt;索引字段名&gt;);</code></li>
<li><code>ALTER TABLE &lt;表名&gt; ADD PRIMARY KEY(&lt;索引字段名&gt;);</code></li>
</ul>
</li>
<li>CREATE增加索引<ul>
<li><code>CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;索引字段名&gt;);</code></li>
<li><code>CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;索引字段名&gt;);</code></li>
</ul>
</li>
<li>查询索引：<code>SHOW INDEX FROM &lt;表名&gt;;</code>或者<code>SHOW KEYS FROM &lt;表名&gt;;</code></li>
<li>删除索引：<code>DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;;</code>或者<code>ALTER TABLE &lt;表名&gt; DROP INDEX &lt;索引名&gt;</code>或者<code>ALTER TABLE &lt;表名&gt; DROP PRIMARY KEY;</code></li>
</ul>
<h3 id="设置约束关系"><a href="#设置约束关系" class="headerlink" title="设置约束关系"></a>设置约束关系</h3><p><strong>主键</strong>，又称主码，主键约束就是作为主键的字段在记录中是唯一存在的，不可重复，并且也不许为空。就像我们每个人都有自己唯一的身份ID一样，唯一标识。利用这个特性，我们可以在数据库中快速的查询定位到一条记录。</p>
<ul>
<li>设置主键：创建表的时候，在定义字段以及数据类型的后面直接加上<code>PRIMARY KEY (默认值)</code>；或者在定义完所有的字段以及数据类型后，加上<code>PRIMARY KEY (&lt;字段名一,....&gt;)</code></li>
</ul>
<p><strong>外键</strong>，表中的一个或多个字段，可以不是本表的主键，但<strong>必须是另一个表的主键</strong>。外键用来在两个表中建立连接关系，对于有关联关系的两个表而言，相关联字段中主键所在的表为父表，外键所在的表为子表。</p>
<ul>
<li>设置外键：在表中所有字段都定义后（包括外键名），加上<code>CONSTRAINT &lt;外键约束名&gt; FOREIGN KEY(外键名) REFERENCES &lt;关联的外表名(外表的字段名)&gt;;</code></li>
</ul>
<p><strong>注意的是，这里的外键约束名与外键名是不同的意思</strong><br><strong>同一个数据库中，外键约束名和外键名一定不可以重复！！！</strong> /(ㄒoㄒ)/~~</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图包含行和列，其中的字段来自一个或多个数据库中的真实的表中的字段，一起组合成一个类似真实的表。可以像基本表一样，进行增删改查的操作。记录进行改动后，视图与基本表都会更新</p>
<ul>
<li><p>创建视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE VIEW &lt;视图名&gt;(视图字段名一,字段名二,...(可选)) AS &lt;子查询语句&gt;</div><div class="line">SELECT &lt;字段名一,字段名二,...&gt;</div><div class="line">FROM &lt;表名&gt;</div><div class="line">WHERE &lt;查询条件&gt;;</div></pre></td></tr></table></figure>
</li>
<li><p>删除视图：<code>DROP VIEW &lt;视图名&gt;;</code></p>
</li>
<li>查询视图：<code>SELECT * FROM &lt;视图名&gt;;</code>或者<code>SLECT &lt;字段名&gt; FROM &lt;视图名&gt;;</code></li>
<li>修改视图：可以向上述修改字段/记录的方式一样来修改视图，并且修改结果各个实际的表也会生效，也可以按下面的方法修改↓↓↓↓↓<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE VIEW &lt;视图名&gt;(视图字段名一,字段名二,...(可选)) AS &lt;子查询语句&gt;</div><div class="line">SELECT &lt;字段名一,字段名二,...&gt;</div><div class="line">FROM &lt;表名&gt;</div><div class="line">WHERE &lt;查询条件&gt;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>某些情况下可以缺省视图的字段名，MySQL会自动补全。但是当SELECT后面的字段有来自函数查询的结果时，不可以缺省。</p>
<h3 id="添加注释-备注"><a href="#添加注释-备注" class="headerlink" title="添加注释/备注"></a>添加注释/备注</h3><ul>
<li>给表添加描述：<code>ALTER TABLE &lt;表名&gt; COMMENT=&#39;这里是表的注释&#39;</code></li>
<li>给列添加描述：<code>ALTER TABLE &lt;表名&gt; MODIFY &#39;&lt;字段名&gt;&#39; DATETIME DEFAULT NULL COMMENT &#39;字段描述&#39;</code></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>谈一谈<strong>外键约束关系</strong>：<br>在两个相关联的表中，一个表的主键是另一个表的非主键字段，这个字段中的值可能有很多。就拿学生选课来说，某一个课程可能有很多学生选，学生的主键是学号，那么该课程的表中，学号这一外键就会有很多值，同时，也把课程的数据表和学生的数据表关联了起来。<br>呐，在这个例子中，课程的表就是子表，学生的数据表就是父表。倘若，父表的值改变了，那么一定需要修改子表的值，而子表想去修改外键的值是没有权限的；但是，子表可以删除带有外键值的记录。这之中就有一种很明显的约束关系。</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse编写jsp自动导入包]]></title>
      <url>http://yoursite.com/2017/02/27/Eclipse%E7%BC%96%E5%86%99jsp%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用eclipse我们会需要一个自动补全剩余代码的功能，这使得我们可以在输完一些变量或者方法甚至是包的时候，可以方便快捷的选择我们想要输入的内容。very convenient！~</p>
<p>这个关键性的组合按键就是：<br><code>alt + /</code></p>
<p>当然了，这个在写java程序的时候可以使用，在写jsp程序的时候，依然是这个组合键 QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中几个获取长度的方法区别]]></title>
      <url>http://yoursite.com/2017/02/27/Java%E4%B8%AD%E5%87%A0%E4%B8%AA%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="length和length-和size"><a href="#length和length-和size" class="headerlink" title="length和length()和size()"></a>length和length()和size()</h1><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>length是数组的属性，直接使用<code>.</code>来进行访问，用来获取数组的长度。</p>
<h2 id="length-1"><a href="#length-1" class="headerlink" title="length()"></a>length()</h2><p>length()是一个方法，针对的是String类型，用来获取字符串的长度。</p>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>size()是方法，用于获取泛型集合的大小，以便了解其中的元素个数。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程]]></title>
      <url>http://yoursite.com/2017/02/27/Java%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="java线程体会"><a href="#java线程体会" class="headerlink" title="java线程体会"></a>java线程体会</h1><h2 id="为什么需要使用线程："><a href="#为什么需要使用线程：" class="headerlink" title="为什么需要使用线程："></a>为什么需要使用线程：</h2><p>​    我们知道，一般程序都是以一个由上至下的运行方式运行的，不完成上一步的时候，是无法进入下一步的执行的。可是我们有时候需要在一个程序同时去做两个不同的任务，各自之间互不干涉，那么根据程序的执行过程，该如何解决呢？</p>
<p>​    答案就是使用<strong>线程</strong>，所谓线程，就是一个程序中最小的执行单元，一个程序在运行时就是一个进程，一个进程可以包含多个线程，这样就允许了一个程序同时去做不同的任务。所以总结的说，我们<strong>需要使用线程来让程序在同一时间做不同的事情，并且互不干涉。</strong></p>
<p>注：</p>
<ul>
<li><strong>程序</strong>是包含了所有执行文件、数据文件、图像文件以及各种文档的资源集合，存储在电脑磁盘里</li>
<li><strong>进程</strong>是一个程序在运行时所需要的所有资源集合，包含了代码、数据、堆栈、变量等，就像一台电脑。</li>
<li><strong>线程</strong>是进程的子集，每一个线程可以看作是进程中的一个执行单元，就像CPU。</li>
</ul>
<h2 id="线程的基本特点："><a href="#线程的基本特点：" class="headerlink" title="线程的基本特点："></a>线程的基本特点：</h2><p>在不同的语言中，线程有不同的实现方式，但都有共同的基本特征：</p>
<ul>
<li>没有属于自己的内存空间，所有使用的空间都是由进程统一安排分配</li>
<li>在线程中使用的数据会存放到属于自己的栈中，但栈中的数据我们是知道的，是不会保留下来的 :cry:</li>
<li>线程的上下文切换是比进程要快很多倍的，而且新建一个线锁需要的时间开销也是少于进程的；但有优点就一定会有缺点，线程的开销是很大的，每创建一个线程都至少要分配512KB甚至是1MB字节的内存，还有的线程及进程的区别可以去看有关操作系统的书</li>
</ul>
<h2 id="使用线程的方法："><a href="#使用线程的方法：" class="headerlink" title="使用线程的方法："></a>使用线程的方法：</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>使用使用ExecutorService（线程池接口）、Callable（重写call()方法）、Future实现有返回结果的多线程(JDK5.0以后)</li>
</ul>
<p>虽然都可以实现线程的控制，但是我们在实际中却用到第二种方法比较多，原因就是<strong>我们有时候需要继承不止一个类</strong>，这时如果我们不去实现Runnable接口，我们该如何使这个类编程线程类呢？:happy:</p>
<h2 id="实现线程类需要注意的地方："><a href="#实现线程类需要注意的地方：" class="headerlink" title="实现线程类需要注意的地方："></a>实现线程类需要注意的地方：</h2><ul>
<li><p>我们想让线程去做的任务都写在run方法里</p>
</li>
<li><p>线程类创建后我们需要去启动线程，而不是调用run方法，不然就仍旧还是方法调用</p>
</li>
<li><p>启动线程的方法</p>
</li>
</ul>
<p>实现Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  <span class="keyword">new</span> Thread(ball).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   继承Thrad类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  ball.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>使用线程进行操作的时候注意添加异常操作<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">			<span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">			</div><div class="line">			singleThreadExecutor.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">					System.out.println(index);</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						Thread.sleep(<span class="number">2000</span>);</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    综上所述，线程的使用方法以及一些特点就在这里了。<strong>个人理解其使用的条件就是想让程序同时完成不同的任务时，使用多线程实现。</strong></p>
<p>​    多线程是java重要的的特点之一，利用多线程我们可以完成很多特殊的功能，比如：弹球游戏、坦克大战和聊天室等等。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[writeUTF学习]]></title>
      <url>http://yoursite.com/2017/02/27/writeUTF%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="流式输出对象的writeUTF-方法"><a href="#流式输出对象的writeUTF-方法" class="headerlink" title="流式输出对象的writeUTF()方法"></a>流式输出对象的writeUTF()方法</h1><p>记录如何使用字节数组来进行数据的传输</p>
<h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h2><p>作为所有输入输出流的父类，其方法read和write</p>
<h2 id="DataInputStream-DataOutputStream"><a href="#DataInputStream-DataOutputStream" class="headerlink" title="DataInputStream / DataOutputStream"></a>DataInputStream / DataOutputStream</h2><p>处理流，包含了很多对数据的处理方法readInt，readFully和writeInt，write。另外因为是处理流，需要套在节点流上使用，故构造方法需要一个参数InputStream / OutputStream</p>
<h2 id="InputStraemReader"><a href="#InputStraemReader" class="headerlink" title="InputStraemReader"></a>InputStraemReader</h2><p>该类一个接收System.in输入的内容</p>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>可以将InputStreamReader流中的内容当成字符串整行的读取出来</p>
<h2 id="flush-close"><a href="#flush-close" class="headerlink" title="flush() / close()"></a>flush() / close()</h2><p>所有的输出流在写完后最好都强制刷新一下缓冲flush，程序接收后把整个输入输出流关掉</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Socket通信字节流or字符流]]></title>
      <url>http://yoursite.com/2017/02/27/Socket%E9%80%9A%E4%BF%A1%E5%AD%97%E8%8A%82%E6%B5%81or%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      <content type="html"><![CDATA[<h1 id="socket通信选择字节流还是字符流？"><a href="#socket通信选择字节流还是字符流？" class="headerlink" title="socket通信选择字节流还是字符流？"></a>socket通信选择字节流还是字符流？</h1><p>字符流处理的单元为2个字节的字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。</p>
<p> 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列</p>
<p>1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串；<br>2.字节流提供了处理任何类型的IO操作的功能，但它不能直接处理字符，而字符流就可以</p>
<hr>
<p>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化。这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联，在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的 </p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux终端配色方案]]></title>
      <url>http://yoursite.com/2017/02/27/linux%E7%BB%88%E7%AB%AF%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu终端配色"><a href="#Ubuntu终端配色" class="headerlink" title="Ubuntu终端配色"></a>Ubuntu终端配色</h1><p>骚年，看到单调的黑色背景的终端是不是感觉很乏味？<br>试试这个教程吧，可以使终端变的beautiful~</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>使用快捷键<code>ctrl + alt + T</code>打开终端<br>键入<code>gedit ~/.bashrc</code><br>会弹出一个编辑文本，复制粘贴下面的代码到<strong>文件的最后部分</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;35;01m\]\u\[\033[00;00;01m\]@\[\033[01;35;01m\]\h\[\033[00;31;01m\]:\[\033[00;00;01m\]\w \[\033[01;32;01m\]\$ \[\033[01;01;01m\]&apos;</div></pre></td></tr></table></figure></p>
<p><strong>注意代码两边的冒号<code>‘</code></strong>。<br>保存后退出即可。</p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>关闭终端后重新打开终端，可以看到，终端的配色方案已经有了变化。<br>然后，在终端中点击鼠标右键，选择下面的选项<br><img src="/2017/02/27/linux终端配色方案/caidan.png" alt="caidan"><br>然后选择<code>Background</code>标签，勾选上<code>Transparent background</code>选项，这是打开终端背景透明的选项。<br><img src="/2017/02/27/linux终端配色方案/caidan2.png" alt="caidan2"></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>设置后透明度之后，点击close即可，这时你的终端就会变的很好(炫)看(闪)了。<br><img src="/2017/02/27/linux终端配色方案/zhongduan.png" alt="zhongduan"></p>
]]></content>
      
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github上传项目]]></title>
      <url>http://yoursite.com/2017/02/27/github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>今天下午突发奇想，打开了小站，然后顺便打开了github，于是想上传曾经做过的项目，本来想按照之前传博客的方法去传项目，然后发现，好像哪里不太对劲，仔细一看教程，确实不太一样。<br>于是乎就去找github上传本地项目的方法，下面总结一下自己的试坑过程。</p>
<h2 id="First-创建本地仓库"><a href="#First-创建本地仓库" class="headerlink" title="First-创建本地仓库"></a>First-创建本地仓库</h2><p>首先要在自己的本地磁盘内创建一个文件夹，名字自己随便取，用来当作自己本地存放项目并且用来和github交互的仓库。<br><img src="/2017/02/27/github上传项目/wenjianjia.png" alt="wenjianjia"><br>我这里创建一个名为 mygit的文件夹。</p>
<h2 id="Second-在github上创建项目仓库"><a href="#Second-在github上创建项目仓库" class="headerlink" title="Second-在github上创建项目仓库"></a>Second-在github上创建项目仓库</h2><p>登陆自己的github，然后新建仓库，项目名字自己取，我这里取了<code>try</code>这个名字。<br><img src="/2017/02/27/github上传项目/chuangjiancangku.png" alt="chuangjiancangku"><br>勾选项和我的设置保持一致即可。</p>
<h2 id="Third-设置ssh密钥"><a href="#Third-设置ssh密钥" class="headerlink" title="Third-设置ssh密钥"></a>Third-设置ssh密钥</h2><p>git shell程序随便选一个安装，打开shell后，输入命令：<br><code>ssh-keygen -C &#39;your@email.address&#39; -t rsa</code><br>注意的是，这个 ‘ ‘ 中的内容就是你的github账号，因为一般是用邮箱注册的。<br>然后不需要管弹出什么内容，什么请输入密码啊什么的，联系按三个回车键，然后在你的电脑的用户目录下找一个名为<code>.ssh</code>的文件夹。<br><img src="/2017/02/27/github上传项目/ssh.png" alt="ssh"><br>打开其中的<code>id_rsa.pub</code>文件，然后复制全部的内容。<br>接着打开你github项目设置里面，左侧栏有一个选项<code>SSH and GPG Keys</code>，打开后，点击右上角的<code>new SSH key</code>按钮，title栏随便输入提示性，key栏把刚才复制的内容全部粘贴进去。确认后会显示一把绿色的小钥匙。</p>
<p>完成上述步骤后，在git shell中输入命令<code>ssg -T git@github.com</code>，注意，这里需要是大写的<code>-T</code>，不知道怎么回事，我输入小写的t就是不行。正确的显示结果如下：<br><img src="/2017/02/27/github上传项目/link.png" alt="link"><br>则表明已经成功连接至你的github库了。</p>
<h2 id="Fouth-“装填”项目文件"><a href="#Fouth-“装填”项目文件" class="headerlink" title="Fouth-“装填”项目文件"></a>Fouth-“装填”项目文件</h2><p>在git shell运行命令：<code>git clone https://github.com/your name/you program name.git</code><br>其实后面的链接就是你打开你的github项目中的仓库后，网页中网址链接，复制粘贴即可。<br>这个时候会在你本地仓库目录中生成文件夹，名字就是你的项目的名字，同时还会有一个隐藏的<code>.git</code>文件。在我举的这个例子中，这个文件夹就是<code>try</code>。<br>然后，只需要把想要上传到仓库中的项目文件全部放到这个文件夹中就好了，我的话就是把项目文件放入到<code>try</code>文件夹中就好。</p>
<p>然后，在git shell中输入以下命令：<br><code>git init</code><br><code>git add xxx</code>  （注意这个名字就是想上传文件夹的名字，没有<code>&#39; &#39;</code>）<br><code>git commit -m &#39;your-program-name&#39;</code>  （这里有<code>&#39; &#39;</code>，内容也是想上传文件夹的名字），一定注意要先add文件<br><strong>注意这里可能会有错误</strong>，↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/02/27/github上传项目/commit_error.png" alt="commit_error"><br>那就使用<code>git commit -am &quot;your-program-name&quot;</code>这条命令再继续</p>
<p>如果正确，会有类似的显示结果：<br><img src="/2017/02/27/github上传项目/gitinit.png" alt="gitinit"><br>然后继续输入<br><code>git remote add origin https://github.com/your-name/you-program-name.git</code><br>这里可能会出现错误↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/02/27/github上传项目/remote_error.png" alt="remote_error"><br>那就使用<code>git remote rm origin</code>，在继续下一步<br>then<br><code>git pull origin master</code><br>这里会即进入Vi编辑器的界面，是需要你输入merge的理由，随便写，不会vim编辑器语法的我后面讲。<br><code>git push origin master</code><br>如果步骤都正确，会有这样的过程和结果：<br><img src="/2017/02/27/github上传项目/gitend.png" alt="gitend"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述步骤有些复杂，一般情况下可以使用更为简单的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git add xxx</div><div class="line"></div><div class="line">git commit -m &quot;这次提交的备注信息&quot;</div><div class="line"></div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><p>这里简单说一下vim编辑器的使用吧，本次操作只需要两个命令即可：<br><code>i</code> 开始进行编辑内容<br><code>:wq</code> 编辑完成后，按<code>Esc</code>，进入命令界面，输入:wq，表示保存及退出</p>
<h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p>到此为止，已经正确上传了项目到你自己的github中，以后也可以重复上面除了新建ssh密钥的步骤外别的操作来继续上传。当然了，如果只需要修改部分文件或者是上传部分文件，又或者是有其他github的操作，请自行移步git使用教程。<br>当然了，以后我自己也会进行某些内容更新。QvQ<br><img src="/2017/02/27/github上传项目/xiexie.jpg" alt="xiexie"><br>2017.04.09补充：Github桌面版简化了很多步骤，方便的一批</p>
]]></content>
      
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo生成博文插入图片]]></title>
      <url>http://yoursite.com/2017/02/26/hexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>十分痛苦，是因为突然发现上传的博客里面的图片居然显示不来，excuse me???<br><img src="/2017/02/26/hexo生成博文插入图片/juewang.jpg" alt="juewang.jpg"><br>笋干shabi了<br>怎么办，上网google解决之道，然后又试了很多坑…….<br><img src="/2017/02/26/hexo生成博文插入图片/zenmeban.jpg" alt="zenmeban.jpg"><br>更加绝望了…..<br>然后，看到了这个：<a href="http://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="external">dalao指导</a><br>hhhh，再试一次…..<img src="/2017/02/26/hexo生成博文插入图片/meibanfa.jpg" alt="更加juewang"></p>
<p>然而，居然可以了….excuse me??</p>
<p>好吧，总结一下这个牛批的解决办法：</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">dalao的git</a></p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个<strong>同名的文件夹</strong></p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<p><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<p><strong>注意：</strong>xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<h2 id="总结一下这个跳（试）坑的过程"><a href="#总结一下这个跳（试）坑的过程" class="headerlink" title="总结一下这个跳（试）坑的过程"></a>总结一下这个跳（试）坑的过程</h2><p>首先是有句mmp想讲，实在是有点坑</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/haoqi.jpg" alt="haoqi"></p>
<p>但是，似乎又多了一项学（zhuang）习（bi）技巧<img src="/2017/02/26/hexo生成博文插入图片/bang.jpg" alt="bang"></p>
<p>hhh，先到这里，后面还有一个坑就是，想引入某些dalao 的链接时，如果链接里包含中文，那么再写入md文件里生成网页后这个链接就打不开了…..</p>
<p>待老夫研究后再填坑，后面如果有时间，就把自己搭建网站的过程码一下。</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/xiexie.jpg" alt="xiexie"></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Final]]></title>
      <url>http://yoursite.com/2017/02/21/Final/</url>
      <content type="html"><![CDATA[<h1 id="第一天的总结"><a href="#第一天的总结" class="headerlink" title="第一天的总结"></a>第一天的总结</h1><p>差不多先折腾到这里吧，大概已有的功能呢，有添加博客和归档的标签，以后还会完成自己的个人简历 Q^Q</p>
<p>说到了这里，这两天自己摸索着使用github来搭建自己的个人网站确实受益良多，贴出大腿的指导书：</p>
<p><code>https://volc1605.github.io/2016/10/03/Hexo之NexT主题搭建博客详细过程</code></p>
<p>暂时的尝试先到此为止，明后天看看能不能再去抢个腾讯的服务器吧，fightting！骚年</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[f__k? this day]]></title>
      <url>http://yoursite.com/2017/02/21/fuck/</url>
      <content type="html"><![CDATA[<h1 id="Today"><a href="#Today" class="headerlink" title="Today"></a>Today</h1><p>今天是特别的一天，忙碌了一整天的时间来学习搭建个人网站博客。到现在为止，略有小成，先写下这一篇随笔，然后全当做实验了。 </p>
<p>ps:没有大腿抱确实一个人折腾好累<br>pss:折腾完又有种莫名的兴奋感……QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
