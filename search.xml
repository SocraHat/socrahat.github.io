<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java中的volaitle关键字]]></title>
      <url>http://yoursite.com/2017/03/18/Java%E4%B8%AD%E7%9A%84volaitle%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java序列化]]></title>
      <url>http://yoursite.com/2017/03/18/Java%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h1><p>Java序列化是指把Java对象转换为字节序列的过程；反序列化就是把字节序列再恢复成Java对象的过程</p>
<h1 id="序列化的作用是什么？"><a href="#序列化的作用是什么？" class="headerlink" title="序列化的作用是什么？"></a>序列化的作用是什么？</h1><p>一般序列化的作用有两方面：</p>
<ul>
<li>把对象转换成字节序列永久的保存到硬盘上（保存到文件中），在MVC中很好用</li>
<li>在网络上传送对象的字节序列</li>
</ul>
<p>简单的说，就是<strong>把数据（对象）换个时间或者是换个地方，继续使用</strong></p>
<ul>
<li>换个时间，比如说把数据存盘</li>
<li>换个地方，比如网络间数据的传输</li>
</ul>
<h2 id="网络间对象的传输"><a href="#网络间对象的传输" class="headerlink" title="网络间对象的传输"></a>网络间对象的传输</h2><p>我们可以通过网络传输图片、文子、音像、视频等资料，同样也可以传对象，这样两个Java程序间通信就可以交换数据。（云服务，把用户数据从服务器传输给用户等）</p>
<h1 id="如何实现序列化和反序列化？"><a href="#如何实现序列化和反序列化？" class="headerlink" title="如何实现序列化和反序列化？"></a>如何实现序列化和反序列化？</h1><p>一个不是很难理解的过程，很像是一个处理流</p>
<h2 id="对象流：ObjectOutputStream和ObjectInputStream"><a href="#对象流：ObjectOutputStream和ObjectInputStream" class="headerlink" title="对象流：ObjectOutputStream和ObjectInputStream"></a>对象流：ObjectOutputStream和ObjectInputStream</h2><p>ObjectOutputStream对象输出流，在实例化时<code>new ObjectOutputStream(OutputStream os)</code>获取输出流，然后<code>writeObject(Object obj)</code>方法可以对参数指定的obj对象进行序列化，然后可以把序列化的的字节序列写到这个os流中；<br><strong>序列化操作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(file_name);</div><div class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</div><div class="line"><span class="comment">// ......</span></div><div class="line">Object obj  = <span class="keyword">new</span> Object();</div><div class="line">oos.writeObject(obj);</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>反序列化操作</strong><br>ObjectInputStream对象输出流，在实例化时<code>new ObjectOutputStream(OutputStream os)</code>获取输入流，然后<code>(Object)readObject()</code>方法可以把读取到的字节序列强制转换成某个类的对象，并赋值；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(file_name);</div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</div><div class="line"><span class="comment">// ......</span></div><div class="line"><span class="comment">// 所需的对象字节序列都在流中</span></div><div class="line">Object obj  = (Object)ois.readObject();</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><p>只有实现了<code>Serializable或Externalizable接口的类</code>的对象才能被序列化，否则会抛出异常</p>
<ul>
<li>实现Serializable接口<br>使用默认的序列化/反序列化的方式，对类的非transient的实例对象进行序列化和反序列化</li>
<li>实现Serializable接口并重写了writeObjetct和readObject方法<br>该类对象就可以调用重写后的读写方法</li>
<li>实现Externalizable接口并重写了writeExternal和readExternal方法<br>该类对象可以调用读写方法</li>
<li>直接使用JDK类库<br>上述代码段的使用方式，不再赘述<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><strong>对象序列化写入到对象流中的顺序应该与读取对象反序列化时的顺序一致</strong></li>
</ul>
<h2 id="对于transient关键字的补充"><a href="#对于transient关键字的补充" class="headerlink" title="对于transient关键字的补充"></a>对于transient关键字的补充</h2><ul>
<li>transient只能修饰变量，不能修饰方法和类</li>
<li>被transient修饰的变量不能被序列化；同时，static静态变量不管是否被transient修饰，都不会被序列化</li>
<li>一旦变量被transient修饰，变量将不会被作为持久化对象中的一部分，该变量<strong>内容</strong>在序列化后不能被访问（变量还在，但变量中的值不在了）</li>
</ul>
<h1 id="日常总结"><a href="#日常总结" class="headerlink" title="日常总结"></a>日常总结</h1><p>被虐了……直到现在还在心塞，原理还是不懂，这些Java的小细节可以说是知之甚少，虽然听说过，但怎么用，为什么这么用，实现的原理是什么，一句话都说不出来……<br>关键是还知道这是各种面试笔试都会被提到的高频知识点……讲真的，该去买书看了，JVM、设计模式……</p>
<p>PS：没错，我又开始挖坑了…….剩下的慢慢写好了</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针常量和常量指针]]></title>
      <url>http://yoursite.com/2017/03/18/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<h1 id="翻看笔试题绕晕了"><a href="#翻看笔试题绕晕了" class="headerlink" title="翻看笔试题绕晕了"></a>翻看笔试题绕晕了</h1><p>本来翻看着各种笔试题，一切顺利的进行，不会的查一查，记不起来的查一查，直到在看<code>C/C++</code>有关的题目时遇到了</p>
<blockquote>
<p>指针常量和常量指针的区别</p>
</blockquote>
<p>手动黑人问号懵逼</p>
<p>然后，法式懵逼……一种不祥的预感</p>
<p>然后查了一下，世界懵逼……</p>
<h1 id="有这么一种通俗易懂的说法"><a href="#有这么一种通俗易懂的说法" class="headerlink" title="有这么一种通俗易懂的说法"></a>有这么一种通俗易懂的说法</h1><p>查看了好几篇博客，直到看到了这么一种说法：<br><strong>三句箴言：</strong></p>
<ul>
<li>常量 const ，指针 <code>*</code>，谁排在前先读谁</li>
<li><code>*</code> 是指针本身，是地址，<code>const</code>是常量本身</li>
<li><code>const</code>和 <code>*</code> 谁排在前，谁代表的内容就不可以改变<br>举个栗子吧：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *ptr = &amp;a;</div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr2 = &amp;b;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面的代码中，ptr就是常量指针，ptr2是指针常量；<br><strong>ptr所指向的地址中的内容是常量</strong>，所以指向内容不可以改变，但是指向的地址可以改变，比如可以<code>ptr = &amp;b</code>，但是不可以<code>*ptr = b</code><br><strong>ptr2所指向的地址不可以改变，但该地址中的内容可以改变</strong>，比如可以<code>*ptr2 = a</code>，但是不可以<code>ptr = &amp;a</code></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>指针常量因为指向的地址不可更改的原因，在定义时一定要初始化（不能为NULL）</p>
<h1 id="指针常量的用处"><a href="#指针常量的用处" class="headerlink" title="指针常量的用处"></a>指针常量的用处</h1><p>指针常量有这么两个可靠性方面的优点：</p>
<ul>
<li>指针不可修改指向，且不能赋值为null</li>
<li>在调用函数时，对于传入的参数可以起到保护的作用，同时还不需要考虑指针为null时的情况</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>其实这是翻译的锅，我们在学习的时候大多用的是翻译过来的说法，如果有心去看一下原文《C Primer plus》，可以看到对于指针常量和常量指针的写法是：</p>
<ul>
<li>常量指针<code>const pointer</code></li>
<li>指针常量<code>pointer to const</code></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的优先队列]]></title>
      <url>http://yoursite.com/2017/03/17/Java%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="Form一个问题"><a href="#Form一个问题" class="headerlink" title="Form一个问题"></a>Form一个问题</h1><p>假设百度搜索引擎一天会搜索出<strong>M亿条URL</strong>，如何根据URL被搜索的次数来找出点击量最高的N个URL呢？</p>
<h1 id="优先队列和层次树"><a href="#优先队列和层次树" class="headerlink" title="优先队列和层次树"></a>优先队列和层次树</h1><h1 id="又回到了HashMap高性能读写方法？"><a href="#又回到了HashMap高性能读写方法？" class="headerlink" title="又回到了HashMap高性能读写方法？"></a>又回到了HashMap高性能读写方法？</h1><h1 id="日常总结"><a href="#日常总结" class="headerlink" title="日常总结"></a>日常总结</h1>]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap和HashTable的区别]]></title>
      <url>http://yoursite.com/2017/03/16/HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p>昨天听说了这么一道题，往HashMap中读写10w条字符串，如何处理可以消耗更少的cpu资源。后面感觉有点蹊跷，不知所以<br><img src="/2017/03/16/HashMap和HashTable的区别/1.jpg" alt="HashMap和HashTable的区别"><br>后面问了dalao黄一下，问题是没有解决，但是言语之间似乎有这么一个信息，<strong>HashMap和HashTable在存储数据时是有区别的</strong><br><img src="/2017/03/16/HashMap和HashTable的区别/2.jpg" alt="HashMap和HashTable的区别"><br>我是想啊，要么HashTable对数据量大的情况下有更好的存储性能？？？，要么是HashTable有更好的并行<br>性？？？</p>
<p>of cause，查一下嘛</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>大概主要的意思是有这么几点区别：<br>两者继承自不同的类，HashMap是HashTable的轻量级实现（非线程安全的实现），但都完成了Map接口</p>
<blockquote>
<ul>
<li>​HashMap去掉了HashTable中的contains方法，但是加上了containsValue()和containKey()方法</li>
<li>HashTable是同步的，而HashMap是非同步的，由于非线程安全，效率上比HashTable要高</li>
<li>​HashMap允许空键值，而HashTable不允许</li>
</ul>
</blockquote>
<p>HashMap和HashTable采用的hash/rehash算法大致一样，性能不会差很多</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好吧，虽然看起来差别不大，但是真的要并行式去存储会不会可以呢？（不晓得啊，其实也不是很懂并行 0.0 ），问题过两天解决了再继续更好了<br><img src="/2017/03/16/HashMap和HashTable的区别/3.jpg" alt="HashMap和HashTable的区别"></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三月中]]></title>
      <url>http://yoursite.com/2017/03/12/%E4%B8%89%E6%9C%88%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h1 id="几句随谈"><a href="#几句随谈" class="headerlink" title="几句随谈"></a>几句随谈</h1><p>前几天听胡哥讲课（正经课），理所当然的提到了鸡汤（这不是日常吗），本着我就静静的看着的心态<br><img src="/2017/03/12/三月中/show.jpg" alt="show"><br>突然某些话还是触动了什么…<br>遇到不会的解决不了的怎么办？看书上网查资料，还是不会呢？问有经验的人，要还是解决不了呢？</p>
<p>解决问题而不是解释问题，总想着等我把这个学完了再开始弄这个，什么时候是个头？</p>
<p>买书！买什么书？酸透了的爱情文学？《二十岁的青春》？愤世嫉俗的批判分析？熟悉人情掌控全局的厚黑学？买了你看了吗？为什么坚持一定要买？</p>
<h1 id="突然明白了什么"><a href="#突然明白了什么" class="headerlink" title="突然明白了什么"></a>突然明白了什么</h1><p>其实，有时候努力钻研但是举步维艰而心生退意很正常，我花了这么多时间，回报呢？受益呢？别人这么久都又敲了那么多代码，看了那么厚的书，然而，自己还是没有把问题解决…….可是，看书不会问人，问人再不会再看书，周而复始，没有一点点进步吗？没有一点点收获吗？每一天只要不虚度踏实的学习，不管在干什么，这不都是收获吗？</p>
<p>总想着不会，不敢，想着先大概了解一下内容，然后再用，再看，确实很低效，但是没有办法，有时候，就是想知道为什么，就是不想稀里糊涂的完成了，这是一种感觉是一种情怀，没有为什么，没有不敢、怂，可是确实和内心的想法有矛盾？</p>
<p>买书好，一定要花钱，不然不心疼，花钱是一种享受，买了可以不看，太多了的时候可以扔，扔的时候会有一个筛选的过程，尽管可能是不自知的，但一直都认为，提高生活质量的最有效方式就是定期扔东西，something and sometimes，同理</p>
<h1 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h1><p>本来几天前就该写的，因为周一下午接到了面试电话，约到了周二晚上，怀着忐忑的心准备了，并等待着，等到了电脑没电，等到了深夜，电话没有打来……第一次经历这样的事情（说不清楚心理变化），唯一能想得就只有继续前进，满满的压力，来自四面八方，羡慕dalao，只是希望到自己面对社会时，能感到，还好我做到了</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java反射机制]]></title>
      <url>http://yoursite.com/2017/03/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="前言碎语"><a href="#前言碎语" class="headerlink" title="前言碎语"></a>前言碎语</h1><p>刚开始学习时其实是跳过了这么一个知识点的（因为确定难懂又暂时没什么用），后面听说了在框架中反射是基本的原理，我就又滚回来了（出来混迟早要还的，深以为然）</p>
<h1 id="反射机制是什么？"><a href="#反射机制是什么？" class="headerlink" title="反射机制是什么？"></a>反射机制是什么？</h1><blockquote>
<p>反射机制是能在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息的以及动态调用对象的方法的功能成为java反射机制</p>
</blockquote>
<p>反射是为了动态的加载java类，使得程序在编译时不需要知道某些类的具体信息，只有在运行的时候根据输入的类（补全了某些类的信息），来动态的加载该类，并运行其中的方法。</p>
<h1 id="反射机制有什么用？"><a href="#反射机制有什么用？" class="headerlink" title="反射机制有什么用？"></a>反射机制有什么用？</h1><p>看过一篇博客，举了这么一个通俗易懂的例子：<br>两个程序员A和B一起工作，因为工作的原因，两个人的任务是分开完成的，同时也是为了保证工程进度；但是程序员A的任务中需要用到程序员B的代码，那么如何在<strong>保证A的任务能够进行下去同时又能保证A和B一起推进任务</strong>呢？<br>这时就需要用到了java反射的机制。按照上面的说法，我们可以在A的代码中先对所需要B中的某个类进行**代理使用，这样可以保证A的程序编译通过；然后在程序运行的时候，通过某种方式（传参数）来获取到真正想要调用的类。这样在程序运行时就会使用到该类的<code>动态代理对象</code>，从而完成任务。</p>
<h1 id="反射机制的原理"><a href="#反射机制的原理" class="headerlink" title="反射机制的原理"></a>反射机制的原理</h1><p>看了上面的介绍以，我就在想这是怎么实现的（感觉这个反射是为了骗过编译器啊….）</p>
<p>首先说一下动态加载，我们知道jvm在运行java程序前会先加载所使用到的类进行编译，而有的类是在编译时期不知道的，只有在运行的时候才会加载，此谓动态加载。在实现动态加载类时，又有一个<code>动态的代理机制</code>在里面：<br>所谓动态代理，就是程序在运行的时候，对于一个接口和实现类，可以<strong>由JVM生成一个代理对象来帮助你使用接口或类中的方法</strong>（而不需要显式的去实例化一个类的对象）<br>这样我们可以在程序中直接使用代理对象，完成操作。</p>
<h1 id="反射机制的常规用法"><a href="#反射机制的常规用法" class="headerlink" title="反射机制的常规用法"></a>反射机制的常规用法</h1><p>对于编译时知道类的信息的情况就不说了，上一篇Class里面有涉及，具体使用时查API文档就好，这里说编译时期不知道类的信息的情况</p>
<ul>
<li><p>定义一个动态代理类，该类必须实现<code>InvocationHandler</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 这个是要代理的对象</span></div><div class="line">    <span class="keyword">private</span> Object subject;</div><div class="line">    </div><div class="line">    <span class="comment">// 构造方法，给要代理的对象赋初值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object subject)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></div><div class="line">    	<span class="comment">// blablabla... </span></div><div class="line">        </div><div class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象的invoke方法来进行调用</span></div><div class="line">        method.invoke(subject, args);</div><div class="line">        </div><div class="line">        <span class="comment">// 在代理真实对象后也可以添加一些操作</span></div><div class="line">        <span class="comment">// blablabla...</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用Class类来获取所需要代理的类；<a href="http://zpcheng.me/2017/03/10/java反射之Class初级用法/#more" target="_blank" rel="external">java中Class的用法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class testClass = Class.forName(str);<span class="comment">// str可以以字符串的形式传入</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建一个动态代理对象并开始使用被代理对象中的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需要代理的真实对象</span></div><div class="line">       Object realObject = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">       <span class="comment">// 将真实对象传入，最后是通过代理对象来调用其方法的</span></div><div class="line">       InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(realObject);</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * 通过Proxy的newProxyInstance方法来创建我们的代理对象</div><div class="line">        * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载代理对象</div><div class="line">        * 第二个参数realObject.getClass().getInterfaces()，这里为代理对象提供的接口是真实对象所实现的接口，表示要代理的是该真实对象，这样就能调用这组接口中的方法了</div><div class="line">        * 第三个参数handler， 将这个代理对象关联到了上方的 InvocationHandler 这个对象上</div><div class="line">        */</div><div class="line">       Object obj = (Object)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realObject.getClass().getInterfaces(), handler);</div><div class="line">    </div><div class="line">       <span class="comment">// obj.xxx(); // 这样使用代理对象来直接调用被代理类的方法</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有需要注意的地方：<strong>Proxy的newProxyInstance方法的第二个参数，意思是代理对象去实现了被代理对像的接口</strong>，这样代理对象才可以去使用被代理对象实现接口或继承类中的方法。同时如果打印出代理对象的<code>obj.getClass().getName()</code>会显示<code>$proxy0</code>，因为这是JVM自动动态生成的代理对象（与使用时自己初始化代理对象不是一个意思，初始化主要是为了传入被代理对象），这是一种固定的命名方式。</p>
<h1 id="使用反射的利弊"><a href="#使用反射的利弊" class="headerlink" title="使用反射的利弊"></a>使用反射的利弊</h1><p><strong>优点</strong>：<br>反射提高了程序的灵活性以及扩展性，降低了耦合性（依赖关系），提高了程序的适应能力；允许程序在不知道具体类的信息的情况下，创建和控制任何类的对象。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>性能问题：使用反射时是一种解释操作，用于字段和方法接入时要远慢于直接代码（这事必然啊，总要能理解吧），所以反射机制主要应用于灵活性和扩展性要求很高的系统框架上，普通程序不建议使用</li>
<li>模糊程序内部逻辑：反射绕过了源代码的技术会带来后期的维护问题，毕竟看反射代码更难</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实当我们使用编译器，在对象后面加上<code>.</code>时，编译器会自动列出该对象中的所有属性以及方法，这里就用到了这个原理，并称之为<strong>java类的自审</strong>，可以探知到类的基本结构。</p>
<p>上面的内容都是我在学习时自己提出的问题，越来越感觉在学一个知识点时主动挖掘它的原理是重要的（虽然有的并不需要也并不会想到），开始萌发要看看JVM底层原理的书的念头了….</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java反射之Class初级用法]]></title>
      <url>http://yoursite.com/2017/03/10/java%E5%8F%8D%E5%B0%84%E4%B9%8BClass%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>Class类的实例表示java应用运行时的类或接口（每个java类在运行的时候都会在JVM里表现为一个Class对象，可以通过<code>类名.Class</code>，<code>类型.getClass()</code>，<code>Class.forName(&quot;包.类名&quot;)</code>等方法获取Class对象）</p>
<h2 id="Class类的特点"><a href="#Class类的特点" class="headerlink" title="Class类的特点"></a>Class类的特点</h2><p>Class类的父类是Object，事实上，任何java类，不管是jdk里面的还是自定义的，都是Class类的对象，同时，所有的数据类型、关键字、方法等等，一切的一切都是Class类的对象。这是前提，很关键</p>
<h2 id="Class类的运行原理"><a href="#Class类的运行原理" class="headerlink" title="Class类的运行原理"></a>Class类的运行原理</h2><p>java种创建对象时不是通过类直接创建的，一个类的对象被创建之前，首先JVM会加载该类的字节码文件（.class文件），也就是编译后的java程序文件；加载完成后，JVM会自动的为该类创建自己的Class对象，再通过Class对象创建目标对象</p>
<h1 id="使用Class的目的"><a href="#使用Class的目的" class="headerlink" title="使用Class的目的"></a>使用Class的目的</h1><p>很简单的一句话，可以利用反射机制重新获取到Object对象，这个是动态加载类以及对象的，是在程序运行时才会发生的动作，至于反射机制的具体应用，先挖个坑，以后填</p>
<h1 id="API文档的仿制"><a href="#API文档的仿制" class="headerlink" title="API文档的仿制"></a>API文档的仿制</h1><p>按照Class类的特性，java种的一切都是Class类的对象，我们可以获取到这些“对象”的信息，比如任意类的属性、构造方法、所有方法等等信息，诚然，我们甚至可以做出一个API文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</div><div class="line">		<span class="comment">// 1.返回与带有给定字符串名的类或接口相关联的 Class 对象，直接导致该类被初始化</span></div><div class="line">		Class testClass = Class.forName(<span class="string">"java.lang.Class"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">// 2. 获取该类的实例化对象</span></div><div class="line">		Class testClass2 =  Class.class;</div><div class="line">		</div><div class="line">		<span class="comment">// 3.获取该类的实例化Class对象</span></div><div class="line">		Class testClass3 = <span class="keyword">new</span> Test().getClass();</div><div class="line">		</div><div class="line">		String target = <span class="string">"([a-zA-Z_-]+)\\."</span>; <span class="comment">// 需要匹配的正则表达式，表示了形如“字母+.”的模式，这样便去除了某个类的包名前缀</span></div><div class="line">		</div><div class="line">		Class&lt;? <span class="keyword">super</span> Object&gt; superC = testClass.getSuperclass();</div><div class="line">		String name = superC.getName();</div><div class="line">		System.out.print(<span class="string">"Class的父类是："</span> + name.replaceAll(target, <span class="string">""</span>) + <span class="string">"\n"</span>);</div><div class="line">		</div><div class="line">		Constructor&lt;Class&gt;[] consClass = testClass.getDeclaredConstructors();</div><div class="line">		System.out.println(<span class="string">"Class的构造方法有："</span>);</div><div class="line">		<span class="keyword">for</span>(Constructor con : consClass)&#123;</div><div class="line">			name = con.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Class&lt;Class&gt;[] classes = testClass.getClasses();</div><div class="line">		System.out.println(<span class="string">"Clsass所有的成员的公共类和接口："</span>);</div><div class="line">		<span class="keyword">if</span>(classes.length==<span class="number">0</span>)</div><div class="line">			System.out.println(<span class="string">"null"</span>);</div><div class="line">		<span class="keyword">for</span>(Class cla : classes)&#123;</div><div class="line">			name = cla.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"Class的属性是："</span>);</div><div class="line">		Field[] fields = testClass.getDeclaredFields();</div><div class="line">		<span class="keyword">for</span>(Field f : fields)&#123;</div><div class="line">			name = f.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Method[] methods = testClass.getMethods();</div><div class="line">		System.out.println(<span class="string">"Class的所有方法是："</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;methods.length; i++)&#123;</div><div class="line">			name = methods[i].toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		ClassLoader loader = testClass.getClassLoader();<span class="comment">// 如果对象是基本类型或者是void，则返回null</span></div><div class="line">		System.out.println(<span class="string">"Class的类加载器是："</span> + loader);</div></pre></td></tr></table></figure></p>
<p>这只是一个简单的思路介绍，重要的是从0到1的过程，至于怎么从1到n，这需要更多的努力。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解HashMap]]></title>
      <url>http://yoursite.com/2017/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      <content type="html"><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>哈希，译作散列，或哈希。就是把任意长度的输入，通过散列算法（hash算法），变换成固定长度的输出，这个输出的值就是哈希值。显然这是一个映射的过程。</p>
<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p>再来看一看HashCode，这是一个方法，该方法返回一个特殊的值，在java中会返回一个整数，用来判断是否是两个相同的对象，和equals方法有紧密的联系：</p>
<ul>
<li>HashCode主要用于提供快捷的查找，在HashTable和HashMap中都有使用，HashCode是用来在散列存储结构中确定对象的存储地址的</li>
<li>如果使用equals(Objetc)方法，两个对象相等，那么这两个对象调用hashCode方法返回的值一定是相等的</li>
<li>如果两个对象中的equals方法被重写了，那么一定也要按照同样的方法来重写hashCode方法（这是为了保持hashCode方法的常规协定，规定了相等对象必须有相同的hashCode值）</li>
<li>借用网上看来的文章的一句话：两个对象的hashCode相同，不代表就是同一个对象/两个对象相同，在hash存储结构中，这只说明了两个对象发生了冲突，被分配在了同一个桶里面。java判断两个对象是否相同还会判断对象引用中存储的地址是否相同（默认）</li>
</ul>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>hash函数，用来计算出哈希值的函数，通常情况下，每一个对象都有自己单独的哈希值，通过hash函数计算出后，可以做到唯一识别。虽然有可能会有冲突的情况出现，出现了同一个hash值，但概率是微乎其微再来n个微乎其微…..<br>hash函数的用途有这么几个：可以这么说，hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<ul>
<li>文件校验：通过对文件摘要，可以对文件进行校验，一定程度上能检测并纠正数据传输中的信道误码，但不能防止对数据的恶意破坏</li>
<li>数字签名：在数字签名协议中，用的最多的单向散列函数可以产生一个机构的数字签名</li>
<li>数据结构中提供快速查找的功能：常用的数据结构HashMap和HashTable会使用到Hash函数来产生hash值，是组成HashMap优越性能必不可少的一环</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>在分析这个HashMap之前我们先来看一看数组和链表，我们都知道，数组提供了很好的查找性能，因为数组空间是连续的，查找起来很方便，但是在数据的插入和删除时，性能就不佳了；再看链表，它的存储空间是离散的，所以在数据的插入删除时，性能很高，但是当论到查找时，其性能就不行了。<br>综上所述，我们总是在面对问题时，根据自己的需求来使用不同的数据结构，这是权衡和妥协的结果。那么我们如果能使用到一种数据结构，它提供良好的查找性能，又可以很方便的插入删除。于是乎，把这两种数据结构组合起来就有了我们这个HashTable。<br>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/05/深入理解HashMap/hash.png" alt="hash"><br>从图中可以看出，这是由数组和链表组成的数据结构，在数组中每个元素存储的是一个链表的头指针，把一个个数据存放到相应的位置，就需要由hash函数来计算了，一般是采用<strong>hash(value)%length计算出元素应该放到对应下标的数组中的位置</strong>。比如，如果value为5，数组长度为10，则计算出的下标位置就是5%10=5，这个值应该放到下标为5的元素中。当然了，如果俩个值计算出存放的位置相同了，就<strong>以后存入的值为头节点，以链表的形式存入，以此类推</strong></p>
<p>现在回过头来看看HashMap，它其实也是一个线性的数组实现的，所以可以理解为其存储的数据结构就是一个线性数组。但是有一点我们需要注意的就是，HashMap是按照键值对来存取数据的，这一点怎么可能通过数组或是链表来实现呢？</p>
<p>深入到HashMap的源码中去看，对照着资料，发现在HashMap中存取数据的关键有一个叫做Map.Entry的内部接口很是关键，再去看Entry，发现它被定义为<code>Entry&lt;Key,Value&gt;</code>，而<strong>Map.Entry<k,v>就是一个键值对的实体</k,v></strong>。如果说HashMap是依靠于数组存储，那么这个数据就是Entry[]，Map存储的内容都在Entry[]里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Entry[] table;</div></pre></td></tr></table></figure></p>
<h2 id="HashMap存取的实现"><a href="#HashMap存取的实现" class="headerlink" title="HashMap存取的实现"></a>HashMap存取的实现</h2><p>在“线性数组”的基础上如何做到随机存储呢：重点是确定键值对的存储位置，这里是希望HashMap里面的元素尽量离散分布，使每个位置上的元素只有一个。当使用hash算法求出这个位置时，马上就可以获取对应位置的值，而不用取遍历链表。也与hash方法的离散性能密切相关<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hash jdk1.8</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说起来，这里的Hash算法本质上就是三步：<strong>取key的hashCode的值、高位运算、取模运算</strong><br>对于任意对象，只要hashCode返回值相同，那么程序调用方法所计算的Hash码时一样的，把hash值对数组的长度取模运算，这样元素的分布相对来说是比较均匀的。在上面的方法中，通过<strong>把hashCode返回值高16位和低16位与计算，达到了hashCode返回值取模数组长度的效果</strong>。因为在HashMap底层数组中，length总是2的n次方（不够的用null填充），此时<strong>使用hashCode返回值与数组长度进行与运算</strong>依然达到了上述的效果，这是jdk1.7中的实现方法，在1.8中高16位与低16位进行与运算是优化的算法，能保证在hashCode返回值很大时，高低Bit都会参与到hash运算中，并且不会产生较大的开销</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>我们知道HashMap中<strong>键 Key</strong>一定是唯一的，那么当再次往HashMap中存入键相同的键值对时，上一次存入的键值对就会被<strong>覆盖</strong>。但是如果两个键值对的index值一样时，HashMap会把先存入的值放入链表的尾部，<strong>最新加入的值则是该线性数组中每个下标对应的链表的首元素</strong>，以此类推。<br><strong>需要注意到的是，jdk1.8新增了HashMap链表中节点的个数对于8个时，转为红黑树的存储方式</strong><br>查看HashMap中的put方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> 		<span class="comment">// 进行hash运算</span></div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">// 判断键值对数组table是否为空或null，否则进行resize扩容</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        <span class="comment">// 根据键值key计算hash得到插入位置的索引</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">// 判断键值对中key是否存在（相同），存在直接覆盖，相同指hashCode和equals</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            <span class="comment">// 判断是否为树，是的话直接插入新结点</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">// 链表</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 如果链表的长度大于8就 转化为红黑树处理</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// key已经存在，直接覆盖</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">// 插入成功判断是否超出了最大容量，是就进行扩容</span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>reszie的源码是将原来数组的容量扩大一倍，<strong>这个过程是一个十分消耗性能的过程，所以在使用中最好定一个预定的最大值，避免HashMap进行频繁的扩容</strong>。默认的负载因子是0.75</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>首结点都是Entry类型的键值对<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 先检查链表中的首结点</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first; <span class="comment">// 判断出了与key相同（hashCode和equals）</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            	<span class="comment">// 继续根据hash查找</span></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="comment">// 不在首结点，不在红黑树，只能遍历链表</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="null-key"><a href="#null-key" class="headerlink" title="null key"></a>null key</h3><p>null key总是放在Entry[]数组的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="获得索引值index"><a href="#获得索引值index" class="headerlink" title="获得索引值index"></a>获得索引值index</h3><p>HashMap存取时需要计算索引index来确认到Entry[]数组取元素的位置，也就是获取数组下标的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * Returns index for hash code h.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按位取并，作用上相当于取模：<code>index = hashcode % table.length</code></p>
<h3 id="hashtable初始大小"><a href="#hashtable初始大小" class="headerlink" title="hashtable初始大小"></a>hashtable初始大小</h3><p>在调用HashMap的无参构造方法时，初始大小是16。当后续大小改变时，table初始大小总是2的n次方（没有填充满就空着）</p>
<h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>我们总是希望整个HashMap是一个尽量离散的优秀结构，用尽量少的空间存储尽量多的数据，且其查找增删的性能依据很高效。这个是一个复杂的平衡过程，和负载因子相关，和解决hash冲突的办法相关：hash冲突是指两个key被分配到了同一个桶中</p>
<ul>
<li>开放定址法（线性探查再散列、二次探查再散列、为随机探查再散列）</li>
<li>再哈希法</li>
<li>链地址法（拉链法）</li>
<li>建立一个公共的溢出桶<br><strong>java中的HashMap使用的就是拉链法，如前面图所示</strong></li>
</ul>
<h2 id="再散列过程-rehash"><a href="#再散列过程-rehash" class="headerlink" title="再散列过程 rehash"></a>再散列过程 rehash</h2><p>当哈希表的容量超过默认的大小时，就需要将所有的元素换一个新的“桶”来存储，这个新的桶中的键值对存放的位置会发生改变，需要重新根据新桶的大小来重新计算各个键值对的索引位置，这个过程就叫做rehash</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此次深入探究java中的HashMap查阅了不少资料和源码，感谢先行者的指引，这里仅是个人愚见，如有异议，欢迎联系<br><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="external">HashMap实现原理分析</a><br><a href="http://www.importnew.com/20386.html" target="_blank" rel="external">java8重新认识HahsMap</a></p>
<p><img src="/2017/03/05/深入理解HashMap/lianhong.jpg" alt="lianhong"></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet重定向与转发区别]]></title>
      <url>http://yoursite.com/2017/03/02/Servlet%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>servlet在对客户端请求的数据处理之后，会向客户端返回相应的响应结果。这个响应结果可以是由当前servlet对象的PrintWriter输出流直接输出到页面上的信息，也可以是一个新的URL地址对应的信息。<br>在servlet中通过两种方式完成对新URL地址的转向：重定向和请求转发。</p>
<h2 id="URL与URI区别"><a href="#URL与URI区别" class="headerlink" title="URL与URI区别"></a>URL与URI区别</h2><p>一图胜千言系列  ↓↓↓<br><img src="/2017/03/02/Servlet重定向与转发区别/url.png" alt="url"></p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>由原请求地址重新定位到某个新地址，原有的请求失效，客户端看到的是新的请求返回的响应结果，客户端浏览器地址栏变为新的请求地址。其中第二次请求是由客户端浏览器自动发出。<br><img src="/2017/03/02/Servlet重定向与转发区别/redirect.png" alt="redirect"></p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>请求转发是将请求再转发到其他地址，转发过程中使用的是同一个请求，转发后浏览器地址栏内容不变。<br><img src="/2017/03/02/Servlet重定向与转发区别/dispatcher.png" alt="dispatcher"></p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>转发只能将请求转发给同一个web应用（项目工程）中的其他组件（servlet程序）；重定向可以重定向到任意的地址，网络地址或是文件地址（跨项目文件夹）</li>
<li>重定向访问结束后，浏览器地址栏URL发生变化，变成了重定向后的URL；转发则不变</li>
<li>重定向对浏览器的请求直接做出响应，结果就是告诉浏览器去重新发出另一个新的URL访问请求；请求转发在服务器端内部将请求转发给另一个资源，浏览器不知道服务器程序内部发生了转发过程</li>
<li>请求转发调用者与被调用者之间共享相同的请求对象，属于同一个请求和响应过程；重定向则是不同的请求和响应过程</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[alter和update以及drop和delete区别]]></title>
      <url>http://yoursite.com/2017/02/28/alter%E5%92%8Cupdate%E4%BB%A5%E5%8F%8Adrop%E5%92%8Cdelete%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用MySQL时，很多语法相似，容易记浑，比如alter和update，比如drop和delete。</p>
<h1 id="alter和update区别"><a href="#alter和update区别" class="headerlink" title="alter和update区别"></a>alter和update区别</h1><ul>
<li>alter是对表的结构进行的操作，比如增加删除表的字段，或者是修改字段的顺序</li>
<li>update是对表中的数据进行的操作，比如依据某个字段修改当前记录中另一个字段的值</li>
</ul>
<h1 id="drop和delete区别"><a href="#drop和delete区别" class="headerlink" title="drop和delete区别"></a>drop和delete区别</h1><ul>
<li>drop是对表本体进行的操作，比如删除整张表。如果需要对表的结构进行增删，使用alter</li>
<li>delete是对表的数据进行的操作，比如删除某一条记录</li>
</ul>
<p>总的来说，如果你不想要这张表了，用drop，如果你还想用这张表，只是删除一些数据，用delete</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL使用手册]]></title>
      <url>http://yoursite.com/2017/02/28/MySQL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="MySQL语法总结"><a href="#MySQL语法总结" class="headerlink" title="MySQL语法总结"></a>MySQL语法总结</h1><h2 id="MySQL结构："><a href="#MySQL结构：" class="headerlink" title="MySQL结构："></a>MySQL结构：</h2><p>数据库中存放数据都是依托与一张张的数据表存在的，我们通过数据库可以高效的利用数据；而我们对数据的操作就是对数据库中的表的操作。</p>
<h2 id="SQL数据类型："><a href="#SQL数据类型：" class="headerlink" title="SQL数据类型："></a>SQL数据类型：</h2><p>字符型：<code>&lt;varchar&gt; VS &lt;char&gt;</code><br>文本型：<code>&lt;text&gt;</code><br>数值型：<code>&lt;int&gt; VS &lt;smallint&gt; VS &lt;tinyint&gt;</code><br>逻辑型：<code>&lt;bit&gt;</code><br>日期型：<code>&lt;datetime&gt; VS &lt;smalldatetime&gt;</code></p>
<h2 id="MySQL基本操作（格式）："><a href="#MySQL基本操作（格式）：" class="headerlink" title="MySQL基本操作（格式）："></a>MySQL基本操作（格式）：</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p><code>mysql -u root -p</code><br>默认没有密码，直接回车，也可以自行修改密码。<br>操作数据库中的表单时，一定要先<code>use &lt;数据库名&gt;</code>来进入该数据库</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li>查看数据库：<code>show databases;</code></li>
<li>查看某数据库中所有的表：<code>show tables;</code></li>
<li>查看表中某字段的数据：<code>select &lt;字段名一,字段名二....&gt; from &lt;表名&gt;;</code></li>
<li>查看某记录：<code>select &lt;字段一,字段二...&gt; from &lt;表名&gt; where &lt;查询条件&gt;;</code><ul>
<li>（多个）查询条件：<code>&lt;字段名&gt; =值 &amp;&amp; &lt;字段名&gt; =值</code></li>
</ul>
</li>
<li>查看表中的所有记录：<code>select * from &lt;表名&gt;;</code></li>
<li>查看表结构：<code>desc &lt;表名&gt;;</code></li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>创建数据库：<code>create databases &lt;数据库名&gt;;</code></li>
<li>创建表单：<code>create table &lt;表名&gt;;</code></li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>按照某字段升序排列：<code>select * from &lt;表名&gt; order by &lt;字段名&gt; limit &lt;待排列的记录数&gt;;</code></li>
<li>降序排列：<code>select * from &lt;表名&gt; order by &lt;字段名&gt; desc limit &lt;待排列的记录数&gt;;</code></li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>插入记录：<code>insert into &lt;表名&gt; values(&#39;...&#39;,&#39;&#39;,&#39;&#39;,....);</code></li>
<li>插入某一字段：<code>insert into &lt;表名&gt; &lt;字段名&gt;;</code></li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除数据库：<code>drop database &lt;数据库名&gt;;</code></li>
<li>删除未被外键关联的表：<code>drop table if exists &lt;表名&gt;;</code></li>
<li>删除已经外键关联的表：先删除子表再删除父表</li>
<li>删除表中的某一条记录：<code>delete from &lt;表名&gt; where &lt;字段=值&gt;;</code></li>
<li>删除表中的某一字段：<code>alter table &lt;表名&gt; drop &lt;字段名&gt;;</code></li>
<li>删除外键约束：<code>alter table &lt;表名&gt; drop foreign key &lt;外键名&gt;</code></li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>修改表名：<code>alter table &lt;旧表名&gt; rename to &lt;新表名&gt;;</code></li>
<li>修改表中的字段名：<code>alter table &lt;表名&gt; modify &lt;旧字段名&gt; &lt;新字段名&gt; &lt;数据类型&gt;;</code></li>
<li>修改表中字段的数据类型：<code>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;新数据类型&gt;;</code></li>
<li>修改表中字段的顺序：<code>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;数据类型&gt; first/after &lt;字段名&gt;;</code></li>
<li>修改表中某一记录某一字段的值：<code>update &lt;表名&gt; set &lt;字段名&gt;=&lt;新值&gt; where &lt;查询条件&gt;;</code></li>
</ul>
<h3 id="设置约束关系"><a href="#设置约束关系" class="headerlink" title="设置约束关系"></a>设置约束关系</h3><p><strong>主键</strong>，又称主码，主键约束就是作为主键的字段在记录中是唯一存在的，不可重复，并且也不许为空。就像我们每个人都有自己唯一的身份ID一样，唯一标识。利用这个特性，我们可以在数据库中快速的查询定位到一条记录。</p>
<ul>
<li>设置主键：创建表的时候，在定义字段以及数据类型的后面直接加上<code>primary key (默认值)</code>；或者在定义完所有的字段以及数据类型后，加上<code>primary key (&lt;字段名一,....&gt;)</code></li>
</ul>
<p><strong>外键</strong>，表中的一个或多个字段，可以不是本表的主键，但<strong>必须是另一个表的主键</strong>。外键用来在两个表中建立连接关系，对于有关联关系的两个表而言，相关联字段中主键所在的表为父表，外键所在的表为子表。</p>
<ul>
<li>设置外键：在表中所有字段都定义后（包括外键名），加上<code>constraint &lt;外键约束名&gt; foreign key(外键名) references&lt;关联的外表名(外表的字段名)&gt;;</code></li>
</ul>
<p><strong>注意的是，这里的外键约束名与外键名是不同的意思</strong><br><strong>同一个数据库中，外键约束名和外键名一定不可以重复！！！</strong> /(ㄒoㄒ)/~~</p>
<h3 id="添加注释-备注"><a href="#添加注释-备注" class="headerlink" title="添加注释/备注"></a>添加注释/备注</h3><ul>
<li>给表添加描述：<code>alter table &lt;表名&gt; comment=&#39;这里是表的注释&#39;</code></li>
<li>给列添加描述：<code>alter table &lt;表名&gt; modify &#39;&lt;字段名&gt;&#39; datetime default null comment &#39;字段描述&#39;</code></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p><strong>外键约束关系</strong>：<br>在两个相关联的表中，一个表的主键是另一个表的非主键字段，这个字段中的值可能有很多。就拿学生选课来说，某一个课程可能有很多学生选，学生的主键是学号，那么该课程的表中，学号这一外键就会有很多值，同时，也把课程的数据表和学生的数据表关联了起来。<br>呐，在这个例子中，课程的表就是子表，学生的数据表就是父表。倘若，父表的值改变了，那么一定需要修改子表的值，而子表想去修改外键的值是没有权限的；但是，子表可以删除带有外键值的记录。这之中就有一种很明显的约束关系。</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse编写jsp自动导入包]]></title>
      <url>http://yoursite.com/2017/02/27/Eclipse%E7%BC%96%E5%86%99jsp%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用eclipse我们会需要一个自动补全剩余代码的功能，这使得我们可以在输完一些变量或者方法甚至是包的时候，可以方便快捷的选择我们想要输入的内容。very convenient！~</p>
<p>这个关键性的组合按键就是：<br><code>alt + /</code></p>
<p>当然了，这个在写java程序的时候可以使用，在写jsp程序的时候，依然是这个组合键 QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中几个获取长度的方法区别]]></title>
      <url>http://yoursite.com/2017/02/27/java%E4%B8%AD%E5%87%A0%E4%B8%AA%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="length和length-和size"><a href="#length和length-和size" class="headerlink" title="length和length()和size()"></a>length和length()和size()</h1><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>length是数组的属性，直接使用<code>.</code>来进行访问，用来获取数组的长度。</p>
<h2 id="length-1"><a href="#length-1" class="headerlink" title="length()"></a>length()</h2><p>length()是一个方法，针对的是String类型，用来获取字符串的长度。</p>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>size()是方法，用于获取泛型集合的大小，以便了解其中的元素个数。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java线程]]></title>
      <url>http://yoursite.com/2017/02/27/java%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="java线程体会"><a href="#java线程体会" class="headerlink" title="java线程体会"></a>java线程体会</h1><h2 id="为什么需要使用线程："><a href="#为什么需要使用线程：" class="headerlink" title="为什么需要使用线程："></a>为什么需要使用线程：</h2><p>​    我们知道，一般程序都是以一个由上至下的运行方式运行的，不完成上一步的时候，是无法进入下一步的执行的。可是我们有时候需要在一个程序同时去做两个不同的任务，各自之间互不干涉，那么根据程序的执行过程，该如何解决呢？</p>
<p>​    答案就是使用<strong>线程</strong>，所谓线程，就是一个程序中最小的执行单元，一个程序在运行时就是一个进程，一个进程可以包含多个线程，这样就允许了一个程序同时去做不同的任务。所以总结的说，我们<strong>需要使用线程来让程序在同一时间做不同的事情，并且互不干涉。</strong></p>
<p>注：</p>
<ul>
<li><strong>程序</strong>是包含了所有执行文件、数据文件、图像文件以及各种文档的资源集合，存储在电脑磁盘里</li>
<li><strong>进程</strong>是一个程序在运行时所需要的所有资源集合，包含了代码、数据、堆栈、变量等，就像一台电脑。</li>
<li><strong>线程</strong>是进程的子集，每一个线程可以看作是进程中的一个执行单元，就像CPU。</li>
</ul>
<hr>
<h2 id="线程的基本特点："><a href="#线程的基本特点：" class="headerlink" title="线程的基本特点："></a>线程的基本特点：</h2><p>​    在不同的语言中，线程有不同的实现方式，但都有共同的基本特征：</p>
<ul>
<li>没有属于自己的内存空间，所有使用的空间都是由进程统一安排分配</li>
<li>​在线程中使用的数据会存放到属于自己的栈中，但栈中的数据我们是知道的，是不会保留下来的 :cry:</li>
<li>线程的上下文切换是比进程要快很多倍的，而且新建一个线锁需要的时间开销也是少于进程的；但有优点就一定会有缺点，线程的开销是很大的，每创建一个线程都至少要分配512KB甚至是1MB字节的内存，还有的线程及进程的区别可以去看有关操作系统的书</li>
</ul>
<hr>
<h2 id="使用线程的方法："><a href="#使用线程的方法：" class="headerlink" title="使用线程的方法："></a>使用线程的方法：</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ul>
<p>虽然都可以实现线程的控制，但是我们在实际中却用到第二种方法比较多，原因就是<strong>我们有时候需要继承不止一个类</strong>，这时如果我们不去实现Runnable接口，我们该如何使这个类编程线程类呢？:happy:</p>
<hr>
<h2 id="实现线程类需要注意的地方："><a href="#实现线程类需要注意的地方：" class="headerlink" title="实现线程类需要注意的地方："></a>实现线程类需要注意的地方：</h2><ul>
<li><p>我们想让线程去做的任务都写在run方法里</p>
</li>
<li><p>线程类创建后我们需要去启动线程，而不是调用run方法，不然就仍旧还是方法调用</p>
</li>
<li><p>启动线程的方法</p>
<p>   实现Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  <span class="keyword">new</span> Thread(ball).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   继承Thrad类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  ball.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用线程进行操作的时候注意添加异常操作</p>
</li>
</ul>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​    综上所述，线程的使用方法以及一些特点就在这里了。<strong>个人理解其使用的条件就是想让程序同时完成不同的任务时，使用多线程实现。</strong></p>
<p>​    多线程是java重要的的特点之一，利用多线程我们可以完成很多特殊的功能，比如：弹球游戏、坦克大战和聊天室等等。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[writeUTF学习]]></title>
      <url>http://yoursite.com/2017/02/27/writeUTF%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="流式输出对象的writeUTF-方法"><a href="#流式输出对象的writeUTF-方法" class="headerlink" title="流式输出对象的writeUTF()方法"></a>流式输出对象的writeUTF()方法</h1><p>记录如何使用字节数组来进行数据的传输</p>
<h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h2><p>作为所有输入输出流的父类，其方法read和write</p>
<h2 id="DataInputStream-DataOutputStream"><a href="#DataInputStream-DataOutputStream" class="headerlink" title="DataInputStream / DataOutputStream"></a>DataInputStream / DataOutputStream</h2><p>处理流，包含了很多对数据的处理方法readInt，readFully和writeInt，write。另外因为是处理流，需要套在节点流上使用，故构造方法需要一个参数InputStream / OutputStream</p>
<h2 id="InputStraemReader"><a href="#InputStraemReader" class="headerlink" title="InputStraemReader"></a>InputStraemReader</h2><p>该类一个接收System.in输入的内容</p>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>可以将InputStreamReader流中的内容当成字符串整行的读取出来</p>
<h2 id="flush-close"><a href="#flush-close" class="headerlink" title="flush() / close()"></a>flush() / close()</h2><p>所有的输出流在写完后最好都强制刷新一下缓冲flush，程序接收后把整个输入输出流关掉</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket通信字节流or字符流]]></title>
      <url>http://yoursite.com/2017/02/27/socket%E9%80%9A%E4%BF%A1%E5%AD%97%E8%8A%82%E6%B5%81or%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      <content type="html"><![CDATA[<h1 id="socket通信选择字节流还是字符流？"><a href="#socket通信选择字节流还是字符流？" class="headerlink" title="socket通信选择字节流还是字符流？"></a>socket通信选择字节流还是字符流？</h1><p>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。</p>
<p> 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列</p>
<p>1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串；<br>2.字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以</p>
<hr>
<p>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化。这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联，在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的 </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux终端配色方案]]></title>
      <url>http://yoursite.com/2017/02/27/linux%E7%BB%88%E7%AB%AF%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu终端配色"><a href="#Ubuntu终端配色" class="headerlink" title="Ubuntu终端配色"></a>Ubuntu终端配色</h1><p>骚年，看到单调的黑色背景的终端是不是感觉很乏味？<br>试试这个教程吧，可以使终端变的beautiful~</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>使用快捷键<code>ctrl + alt + T</code>打开终端<br>键入<code>gedit ~/.bashrc</code><br>会弹出一个编辑文本，复制粘贴下面的代码到<strong>文件的最后部分</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;35;01m\]\u\[\033[00;00;01m\]@\[\033[01;35;01m\]\h\[\033[00;31;01m\]:\[\033[00;00;01m\]\w \[\033[01;32;01m\]\$ \[\033[01;01;01m\]&apos;</div></pre></td></tr></table></figure></p>
<p><strong>注意代码两边的冒号<code>‘</code></strong>。<br>保存后退出即可。</p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>关闭终端后重新打开终端，可以看到，终端的配色方案已经有了变化。<br>然后，在终端中点击鼠标右键，选择下面的选项<br><img src="/2017/02/27/linux终端配色方案/caidan.png" alt="caidan"><br>然后选择<code>Background</code>标签，勾选上<code>Transparent background</code>选项，这是打开终端背景透明的选项。<br><img src="/2017/02/27/linux终端配色方案/caidan2.png" alt="caidan2"></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>设置后透明度之后，点击close即可，这时你的终端就会变的很好(炫)看(闪)了。<br><img src="/2017/02/27/linux终端配色方案/zhongduan.png" alt="zhongduan"></p>
]]></content>
      
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github上传项目]]></title>
      <url>http://yoursite.com/2017/02/27/github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>今天下午突发奇想，打开了小站，然后顺便打开了github，于是想上传曾经做过的项目，本来想按照之前传博客的方法去传项目，然后发现，好像哪里不太对劲，仔细一看教程，确实不太一样。<br>于是乎就去找github上传本地项目的方法，下面总结一下自己的试坑过程。</p>
<h2 id="First-创建本地仓库"><a href="#First-创建本地仓库" class="headerlink" title="First-创建本地仓库"></a>First-创建本地仓库</h2><p>首先要在自己的本地磁盘内创建一个文件夹，名字自己随便取，用来当作自己本地存放项目并且用来和github交互的仓库。<br><img src="/2017/02/27/github上传项目/wenjianjia.png" alt="wenjianjia"><br>我这里创建一个名为 mygit的文件夹。</p>
<h2 id="Second-在github上创建项目仓库"><a href="#Second-在github上创建项目仓库" class="headerlink" title="Second-在github上创建项目仓库"></a>Second-在github上创建项目仓库</h2><p>登陆自己的github，然后新建仓库，项目名字自己取，我这里取了<code>try</code>这个名字。<br><img src="/2017/02/27/github上传项目/chuangjiancangku.png" alt="chuangjiancangku"><br>勾选项和我的设置保持一致即可。</p>
<h2 id="Third-设置ssh密钥"><a href="#Third-设置ssh密钥" class="headerlink" title="Third-设置ssh密钥"></a>Third-设置ssh密钥</h2><p>git shell程序随便选一个安装，打开shell后，输入命令：<br><code>ssh-keygen -C &#39;your@email.address&#39; -t rsa</code><br>注意的是，这个 ‘ ‘ 中的内容就是你的github账号，因为一般是用邮箱注册的。<br>然后不需要管弹出什么内容，什么请输入密码啊什么的，联系按三个回车键，然后在你的电脑的用户目录下找一个名为<code>.ssh</code>的文件夹。<br><img src="/2017/02/27/github上传项目/ssh.png" alt="ssh"><br>打开其中的<code>id_rsa.pub</code>文件，然后复制全部的内容。<br>接着打开你github项目设置里面，左侧栏有一个选项<code>SSH and GPG Keys</code>，打开后，点击右上角的<code>new SSH key</code>按钮，title栏随便输入提示性，key栏把刚才复制的内容全部粘贴进去。确认后会显示一把绿色的小钥匙。</p>
<p>完成上述步骤后，在git shell中输入命令<code>ssg -T git@github.com</code>，注意，这里需要是大写的<code>-T</code>，不知道怎么回事，我输入小写的t就是不行。正确的显示结果如下：<br><img src="/2017/02/27/github上传项目/link.png" alt="link"><br>则表明已经成功连接至你的github库了。</p>
<h2 id="Fouth-“装填”项目文件"><a href="#Fouth-“装填”项目文件" class="headerlink" title="Fouth-“装填”项目文件"></a>Fouth-“装填”项目文件</h2><p>在git shell运行命令：<code>git clone https://github.com/your name/you program name.git</code><br>其实后面的链接就是你打开你的github项目中的仓库后，网页中网址链接，复制粘贴即可。<br>这个时候会在你本地仓库目录中生成文件夹，名字就是你的项目的名字，同时还会有一个隐藏的<code>.git</code>文件。在我举得这个例子中，这个文件夹就是<code>try</code>。<br>然后，只需要把想要上传到仓库中的项目文件全部放到这个文件夹中就好了，我的话就是把项目文件放入到<code>try</code>文件夹中就好。</p>
<p>然后，在git shell中输入以下命令：<br><code>git init</code><br><code>git add xxx</code>  （注意这个名字就是想上传文件夹的名字，没有<code>&#39; &#39;</code>）<br><code>git commit -m &#39;your-program-name&#39;</code>  （这里有<code>&#39; &#39;</code>，内容也是想上传文件夹的名字）<br>如果正确，会有类似的显示结果：<br><img src="/2017/02/27/github上传项目/gitinit.png" alt="gitinit"><br>然后继续输入<br><code>git remote add origin https://github.com/your-name/you-program-name.git</code><br><code>git pull origin master</code><br>这里会即进入Vi编辑器的界面，是需要你输入merge的理由，随便写，不会vim编辑器语法的我后面讲。<br><code>git push origin master</code><br>如果步骤都正确，会有这样的过程和结果：<br><img src="/2017/02/27/github上传项目/gitend.png" alt="gitend"></p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>这里简单说一下vim编辑器的使用吧，本次操作只需要两个命令即可：<br><code>i</code> 开始进行编辑内容<br><code>:wq</code> 编辑完成后，按<code>Esc</code>，进入命令界面，输入:wq，表示保存及退出</p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>到此为止，已经正确上传了项目到你自己的github中，以后也可以重复上面除了新建ssh密钥的步骤外别的操作来继续上传。当然了，如果只需要修改部分文件或者是上传部分文件，又或者是有其他github的操作，请自行移步git使用教程。<br>当然了，以后我自己也会进行某些内容更新。QvQ<br><img src="/2017/02/27/github上传项目/xiexie.jpg" alt="xiexie"></p>
]]></content>
      
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo生成博文插入图片]]></title>
      <url>http://yoursite.com/2017/02/26/hexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>十分痛苦，是因为突然发现上传的博客里面的图片居然显示不来，excuse me???<br><img src="/2017/02/26/hexo生成博文插入图片/juewang.jpg" alt="juewang.jpg"><br>笋干shabi了<br>怎么办，上网google解决之道，然后又试了很多坑…….<br><img src="/2017/02/26/hexo生成博文插入图片/zenmeban.jpg" alt="zenmeban.jpg"><br>更加绝望了…..<br>然后，看到了这个：<a href="http://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="external">dalao指导</a><br>hhhh，再试一次…..<img src="/2017/02/26/hexo生成博文插入图片/meibanfa.jpg" alt="更加juewang"></p>
<p>然而，居然可以了….excuse me??</p>
<p>好吧，总结一下这个牛批的解决办法：</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">dalao的git</a></p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个<strong>同名的文件夹</strong></p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<p><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<p><strong>注意：</strong>xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<h2 id="总结一下这个跳（试）坑的过程"><a href="#总结一下这个跳（试）坑的过程" class="headerlink" title="总结一下这个跳（试）坑的过程"></a>总结一下这个跳（试）坑的过程</h2><p>首先是有句mmp想讲，实在是有点坑</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/haoqi.jpg" alt="haoqi"></p>
<p>但是，似乎又多了一项学（zhuang）习（bi）技巧<img src="/2017/02/26/hexo生成博文插入图片/bang.jpg" alt="bang"></p>
<p>hhh，先到这里，后面还有一个坑就是，想引入某些dalao 的链接时，如果链接里包含中文，那么再写入md文件里生成网页后这个链接就打不开了…..</p>
<p>待老夫研究后再填坑，后面如果有时间，就把自己搭建网站的过程码一下。</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/xiexie.jpg" alt="xiexie"></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Final]]></title>
      <url>http://yoursite.com/2017/02/21/Final/</url>
      <content type="html"><![CDATA[<h1 id="第一天的总结"><a href="#第一天的总结" class="headerlink" title="第一天的总结"></a>第一天的总结</h1><p>差不多先折腾到这里吧，大概已有的功能呢，有添加博客和归档的标签，以后还会完成自己的个人简历 Q^Q</p>
<p>说到了这里，这两天自己摸索着使用github来搭建自己的个人网站确实受益良多，贴出大腿的指导书：</p>
<p><code>https://volc1605.github.io/2016/10/03/Hexo之NexT主题搭建博客详细过程</code></p>
<p>暂时的尝试先到此为止，明后天看看能不能再去抢个腾讯的服务器吧，fightting！骚年</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[f__k? this day]]></title>
      <url>http://yoursite.com/2017/02/21/fuck/</url>
      <content type="html"><![CDATA[<h1 id="Today"><a href="#Today" class="headerlink" title="Today"></a>Today</h1><p>今天是特别的一天，忙碌了一整天的时间来学习搭建个人网站博客。到现在为止，略有小成，先写下这一篇随笔，然后全当做实验了。 </p>
<p>ps:没有大腿抱确实一个人折腾好累<br>pss:折腾完又有种莫名的兴奋感……QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
