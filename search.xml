<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring-IoC依赖注入]]></title>
      <url>%2F2017%2F08%2F03%2FSpring-IoC%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[IoC依赖注入发生的时间首先需要明确的是在IoC容器初始化之后，IoC容器已经开始管理Bean了，但是这时还不一定对管理的Bean进行了依赖注入 第一次通过getBean()方法向IoC容器所要bean时，IoC容器触发依赖注入 当Bean配置文件的标签设置了lazy-init属性时，IoC容器在解析Bean定义时进行预实例化，触发依赖注入，也即是随着ApplicationContext文件的加载而触发依赖注入，这是默认情况 Bean的生命周期依赖注入发生的时间似乎可早可晚，这就不免让人思考一个问题，Spring中bean对象的生命周期问题，因为Spring的ApplicationContext容器在启动时会自动实例化所有singleton的Bean实例并缓存到容器中，那么这就开始了，接下来呢？ 其实这是一个好坑 依赖注入的步骤像上一篇IoC容器的初始化过程一样，涉及到了很多源码，这里只粘出总结出的步骤1234567891011121314151617IoC容器初始化完成 ↓AbstractBeanFactory通过getBean像IoC容器中获取bean，实际上是使用不同的模式来createBean：单例模式就是singleton的bean，原型模式就是不同的bean ↓createBeanInstance()生成bean的Java对象实例；populateBean()对bean属性的依赖关系进行注入 ↓bean对象使用工厂方法和自动装配特性来进行bean实例化： 参数匹配的构造方法或者相应的工厂方法进行实例化 默认无参的构造方法使用反射和CGLIB进行实例化，bean中的方法被覆盖了就使用反射，反之就是CGLIB ↓populateBean()方法对bean的属性开始注入 属性值类型不需要转换的直接调用set方法 属性值类型需要转换的，先解析在注入 ↓解析属性，各种List、Set、Map属性，解析成目标属性 ↓对于集合类型的属性，解析后注入属性；非集合类型的属性，使用大量反射和内省机制（缺省办法），使用get获取旧值，再使用set赋予新值 至此，完成了IoC依赖注入 一些细节再看很多博客时会注意到，大家对于IoC容器的初始化完成这个一点有不同的定义，有的是认为IoC容器加载解析注册完Bean配置之后就是完成了IoC容器的初始化，有的则还会包括接下来的Bean对象的依赖注入之后才是真正的完成了IoC容器的初始化从源码上来看，我个人更愿意倾向于第一种，Bean对象的依赖注入的代码与IoC加载解析注册的代码有明显的分为不同阶段，这里就统一一下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyCat多重规则哈希分片]]></title>
      <url>%2F2017%2F08%2F03%2FMyCat%E5%A4%9A%E9%87%8D%E8%A7%84%E5%88%99%E5%93%88%E5%B8%8C%E5%88%86%E7%89%87%2F</url>
      <content type="text"><![CDATA[MyCat分片规则MyCat自带的分片规则有很多种，而且支持自定义分片规则，灰常好用啊感觉巨佬整理的很细，容易理解 哈希取模分片：常见的分片方式，根据分片字段（一般是主键）的哈希值，再对分片个数取模运算，决定记录到哪个分片上；分片个数最好是2的n次方 路由约定分片：维护一个properties文件，针对不同的值设置不同的分片 范围路由约定分片：针对不同范围的值约定一个分片 哈希范围约定分片：分片字段值哈希取模后的范围约定分片 部分字段分片：截取某个字段的一部分作为分片依据，配合全局id生成器使用 多重规则分片：设置多种分片规则，比如一部分采用路由分片，一部分采用哈希范围分片 自定义分片规则MyCat支持自定义分片规则，自定义类需要继承AbstractPartitionAlgorithm类，然后实现calculate()或calculateRange()方法 源码这是看到了巨佬整理的博客，所幸自己也读懂了代码，忍不住自己也整理一下收获 AbstractPartitionAlgorithm源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractPartitionAlgorithm implements RuleAlgorithm &#123; @Override public void init() &#123; &#125; /** * 返回所有被路由到的节点的编号 * 返回长度为0的数组表示所有节点都被路由（默认） * 返回null表示没有节点被路由到 */ @Override public Integer[] calculateRange(String beginValue, String endValue) &#123; return new Integer[0]; &#125; /** * 对于存储数据按顺序存放的字段做范围路由，可以使用这个函数 * @param algorithm * @param beginValue * @param endValue * @return */ public static Integer[] calculateSequenceRange(AbstractPartitionAlgorithm algorithm, String beginValue, String endValue) &#123; Integer begin = 0, end = 0; begin = algorithm.calculate(beginValue); end = algorithm.calculate(endValue); if(begin == null || end == null)&#123; return new Integer[0]; &#125; if (end &gt;= begin) &#123; int len = end-begin+1; Integer [] re = new Integer[len]; for(int i =0;i&lt;len;i++)&#123; re[i]=begin+i; &#125; return re; &#125;else&#123; return null; &#125; &#125;&#125; PartitionByMod源码 12345678910111213141516private int count;@Overridepublic void init() &#123;&#125;public void setCount(int count) &#123; this.count = count;&#125;@Overridepublic Integer calculate(String columnValue) &#123; BigInteger bigNum = new BigInteger(columnValue).abs(); // 简单的对分片个数取模 // x mod (2^n) = x&amp;(2^n-1) return (bigNum.mod(BigInteger.valueOf(count))).intValue();&#125; 不带范围约定的符合规则分片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/*** 首先实现不带范围约定的复合规则，即配置文件中为：* 北京=0，1，2,3,4* 上海=10,11*/public class PartitionByRouteHash extends AbstractPartitionAlgorithm implements RuleAlgorithm &#123; protected String routeFile; // 注意使用map存储分片规则对应关系 private Map&lt;String, List&lt;Integer&gt;&gt; routeNodeMap; protected static final String DEFAULT_NODE = "DEFAULT_NODE"; protected int keyStartIndex; protected int keyEndIndex; protected int valueStartIndex; protected int valueEndIndex; public void setKeyStartIndex(int keyStartIndex) &#123; this.keyStartIndex = keyStartIndex; &#125; public void setKeyEndIndex(int keyEndIndex) &#123; this.keyEndIndex = keyEndIndex; &#125; public void setValueStartIndex(int valueStartIndex) &#123; this.valueStartIndex = valueStartIndex; &#125; public void setValueEndIndex(int valueEndIndex) &#123; this.valueEndIndex = valueEndIndex; &#125; public void setRouteFile(String routeFile) &#123; this.routeFile = routeFile; &#125; @Override public void init() &#123; initialize(); &#125; @Override // 参数值一般就是等号的左值 public Integer calculate(String columnValue) &#123; String key = columnValue.substring(keyStartIndex,keyEndIndex); String value = columnValue.substring(valueStartIndex,valueEndIndex); List&lt;Integer&gt; nodes = routeNodeMap.get(key); if(nodes == null) nodes = routeNodeMap.get(DEFAULT_NODE); // 先进性哈希 BigInteger bigNum = new BigInteger(""+value.hashCode()); // 再对分片个数取模 return nodes.get((bigNum.mod(BigInteger.valueOf(nodes.size()))).intValue()); &#125; // 读取文件，创建哈希表保存对应关系 private void initialize() &#123; BufferedReader in = null; try &#123; InputStream fin = this.getClass().getClassLoader() .getResourceAsStream(routeFile); if (fin == null) &#123; throw new RuntimeException("can't find class resource file " + routeFile); &#125; // 准备逐行读取 in = new BufferedReader(new InputStreamReader(fin)); routeNodeMap = new HashMap&lt;String, List&lt;Integer&gt;&gt;(); for (String line = null; (line = in.readLine()) != null;) &#123; line = line.trim(); if (line.startsWith("#") || line.startsWith("//")) continue; int ind = line.indexOf('='); if (ind &lt; 0) continue; try &#123; String key = line.substring(0, ind).trim(); String value = line.substring(ind+1).trim(); String []nodes = value.split(","); // values是各个分片节点，采用整型队列存储 List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;(); for(int i = 0 ; i&lt; nodes.length ; i++)&#123; values.add(Integer.parseInt(nodes[i].trim())); &#125; // 将对应关系存储下来 routeNodeMap.put(key,values); &#125; catch (Exception e) &#123; System.out.println("something wrong in the route hash configuration!"); &#125; &#125; &#125; catch (Exception e) &#123; if (e instanceof RuntimeException) &#123; throw (RuntimeException) e; &#125; else &#123; throw new RuntimeException(e); &#125; &#125; finally &#123; try &#123; in.close(); &#125; catch (Exception e2) &#123; &#125; &#125; &#125;&#125; 带范围约定的复合规则分片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/*** 实现范围约定的复合规则* 上海（A00000-A100000）= 2,5,6* 北京（B00000-B100000）= 3,8,9*/public class PartitionByScalableRouteHash extends PartitionByRouteHash &#123; // 注意使用字段值的左半部分当作routeNodeMap的key，右半部分当作value的key，分片节点存储的队列当作value的value private Map&lt;String,Map&lt;String[],List&lt;Integer&gt;&gt;&gt; routeNodeMap; @Override public void init() &#123; initialize(); &#125; @Override public Integer calculate(String columnValue) &#123; String key = columnValue.substring(keyStartIndex,keyEndIndex); String value = columnValue.substring(valueStartIndex,valueEndIndex); Map&lt;String[],List&lt;Integer&gt;&gt; scaleMap = routeNodeMap.get(key); if(scaleMap==null)&#123; scaleMap = routeNodeMap.get(this.DEFAULT_NODE); &#125; String []ranges = new String[1]; // 遍历routerMap的value的key，取得范围的上下界的值，进行比对 for(String []range:scaleMap.keySet())&#123; if(range[0].equals(this.DEFAULT_NODE)) continue; if(range[0].compareTo(value)&lt;0&amp;&amp;range[1].compareTo(value)&gt;0) ranges = range; &#125; if(ranges.length==1) &#123; for(String []range:scaleMap.keySet())&#123; if(range[0].equals(this.DEFAULT_NODE))&#123; ranges = range; break; &#125; &#125; &#125; List&lt;Integer&gt; nodes = scaleMap.get(ranges); // 这里的value是传入的字段值中的范围，进行哈希 BigInteger bigNum = new BigInteger(""+value.hashCode()); // 将范围在进行取模 return nodes.get((bigNum.mod(BigInteger.valueOf(nodes.size()))).intValue()); &#125; private void initialize()&#123; BufferedReader in = null; try &#123; InputStream fin = this.getClass().getClassLoader() .getResourceAsStream(routeFile); if (fin == null) &#123; throw new RuntimeException("can't find class resource file " + routeFile); &#125; in = new BufferedReader(new InputStreamReader(fin)); routeNodeMap = new HashMap&lt;String, Map&lt;String[], List&lt;Integer&gt;&gt;&gt;(); for (String line = null; (line = in.readLine()) != null;) &#123; line = line.trim(); if (line.startsWith("#") || line.startsWith("//")) continue; int lb = line.indexOf('('),rb = line.indexOf(')'),mb = line.indexOf(':'); int ind = line.indexOf('='); if((lb!=-1&amp;&amp;rb!=-1&amp;&amp;mb!=-1)&amp;&amp;(mb&lt;lb||mb&gt;rb||lb&gt;rb||rb&gt;ind))&#123; throw new RuntimeException("Wrong format! Error use of (),:,=!"); &#125; if (ind &lt; 0) continue; try &#123; String key = line.substring(0, lb&lt;0?ind:lb).trim(); Map&lt;String[],List&lt;Integer&gt;&gt; scaleMap = routeNodeMap.get(key); if(scaleMap == null)&#123; scaleMap = new HashMap&lt;String[],List&lt;Integer&gt;&gt;(); routeNodeMap.put(key,scaleMap); &#125; String[] valueRange = new String[2]; if(lb!=-1&amp;&amp;rb!=-1&amp;&amp;mb!=-1) &#123; // 解析范围的上下届值，使用String数组存储 String minValue = line.substring(lb + 1, mb).trim(); String maxValue = line.substring(mb + 1, rb).trim(); if (minValue.length() != maxValue.length() || minValue.compareTo(maxValue) &gt;= 0) &#123; throw new RuntimeException("Wrong value range! "); &#125; valueRange[0] = minValue; valueRange[1] = maxValue; &#125; else &#123; valueRange[0] = this.DEFAULT_NODE; &#125; String value = line.substring(ind+1).trim(); String []nodes = value.split(","); List&lt;Integer&gt; node = new ArrayList&lt;Integer&gt;(); for(int i = 0 ; i&lt; nodes.length ; i++)&#123; node.add(Integer.parseInt(nodes[i].trim())); &#125; // 存储范围与分片节点的对应关系 scaleMap.put(valueRange,node); &#125; catch (Exception e) &#123; System.out.println("something wrong in the route hash configuration!"); &#125; &#125; &#125; catch (Exception e) &#123; if (e instanceof RuntimeException) &#123; throw (RuntimeException) e; &#125; else &#123; throw new RuntimeException(e); &#125; &#125; finally &#123; try &#123; in.close(); &#125; catch (Exception e2) &#123; &#125; &#125; &#125;&#125; 当然上述的两个方法是需要设置rule.xml配置文件的：12345678910111213&lt;tableRule name="scalable-route-hash"&gt; &lt;rule&gt; &lt;columns&gt;order_id&lt;/columns&gt; &lt;algorithm&gt;scalable-route-hash&lt;/algorithm&gt; &lt;/rule&gt; &lt;/tableRule&gt; &lt;function name="scalable-route-hash" class="org.opencloudb.route.function.PartitionByRouteHash"&gt; &lt;property name="routeFile"&gt;scalable-route-hash.txt&lt;/property&gt; &lt;property name="keyStartIndex"&gt;0&lt;/property&gt; &lt;property name="keyEndIndex"&gt;5&lt;/property&gt; &lt;property name="valueStartIndex"&gt;5&lt;/property&gt; &lt;property name="valueEndIndex"&gt;11&lt;/property&gt; &lt;/function&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring配置Mybatis执行原生SQL语句]]></title>
      <url>%2F2017%2F08%2F03%2FSpring%E9%85%8D%E7%BD%AEMybatis%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[为什么要怎么做有这么一个应用场景：需要在Mybatis框架上进行多个连接池的配置，然后进行多种SQL语句的测试，因为有些SQL语句的结构比较复杂，有些会涉及到很多group by、join操作还有一些聚集函数的使用，同时数据量又较大。在这种情况下，常规的Mybatis面对对象进行操作的办法就不再试适用，查看Mybatis官方手册，提供了SQL构造器的办法也会有较的工作量，所以选择直接执行SQL语句（那为啥不用JDBC呢？笑） 遇到的坑凭我记忆中对Mybatis的用法，似乎并没有这么用的，去网上搜，居然真的存在这种用法，但是讲的大多含糊其辞，晕了一下午也没让我找到正确的做法（真心给跪） 将SQL当作SqlSession执行的参数：使用SqlSession的selectList()方法，传入的参数是SQL，当然需要在Bean的mapper xml配置文件中修改parameterType类型为String，同时因为String不支持getter和setter操作，手动封装一个包装类SQLAdapter 虽然看起来似乎可以，但是还是会存在坑的，即“SqlSession对象如何调用selectList()方法来传入SQL语句？”。一开始是直接12// sql 是原生SQL语句list = sqlSession.selectList("selectList",sql); 这样还是会提示String没有setter方法而报出异常 其实还有一个坑是关于在xml映射文件中 &lt;select&gt; 语句的返回值问题，有的查询语句是返回集合，而有的是返回整型值，直接设置resultType = &quot;XXX&quot;肯定是会报错的 第三个坑是解决了上述问题后报出的org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()异常，上网一搜，是mybatis-spring的版本问题 成功的做法试了整整一上午，反复踩坑跳坑，终于让我找到了一条正确的道路 按照上面提到的解决步骤先进行设置，重点放在执行查询的时候，sqlSession执行方法时传入的参数要注意不能是String类型的SQL，而需要是封装类SQLAdapter对象1list = sqlSession.selectList("selectList",new SQLAdapter(sql)); 即可解决第一个问题，可以执行部分语句 第二个问题说白了就是针对查询的返回值类型要有合适的“容器”来接收，不能是某个具体的类型，那么直接采用超类java.lang.Object来最为resultType的值 最后一个问题就好解决了，mybatis-spring的版本设置为3.4.0即可（原来是3.2.2），总之版本要高一些 一点想法其实自己学东西的时候肯定会遇到很多坑，有时比问题还坑的是网上的某些“指导”，总是会经历过心态崩溃的时候，只是希望自己不要成为误导别人的人ps：遇到不会的还是要多关注官方文档啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring-IoC容器初始化]]></title>
      <url>%2F2017%2F08%2F02%2FSpring-IoC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Spring Ioc容器IoC容器最主要是对Bean对象的创建和依赖管里注入，是整个Spring IoC功能的核心 基本结构Spring IoC结构很复杂，多个类继承实现关系混乱，但最基础的有三个 BeanFactory，对IoC容器的基本行为做出了定义 BeanDefinition，在IOC中可识别Bean资源文件的描述 BeanDefinitionReader，加载Bean资源文件 Ioc容器初始化过程这里举两个简单的例子 XmlBeanFactory容器一个较为低级的IoC容器，实现了最基本的功能12345678//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息 ClassPathResource resource =new ClassPathResource("application-context.xml");//创建DefaultListableBeanFactory DefaultListableBeanFactory factory =new DefaultListableBeanFactory();//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory XmlBeanDefinitionReader reader =new XmlBeanDefinitionReader(factory);//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用 reader.loadBeanDefinitions(resource); ApplicationContext容器更为高级的IoC容器，除基本功能外，还支持信息源，可以实现国际化、访问资源和支持应用事件因具体涉及的源代码很多，原理也较难解释清除，故只列出最基本的流程 1234567891011121314151617181920212223ApplicationContext application = new FileSystemXmlApplicationContext(xmlPath); ↓父类AbastractRefreshableConfigApplicationContext为容器设置Bean资源加载器 ↓资源加载器resourceLoader被赋值，设置资源文件路径，然后对资源文件路径进行解析 ↓调用refresh()方法，这是IoC容器初始化的入口 ↓创建IoC容器，子类启动载入过程；ConfigurableListableBeanFactory beanFactory = obtainBeanFactory(); ↓创建DefaultListableBeanFactory对象，装载beanFactory对象loadBeanDefinitions(beanFactory) ↓新建Xml Bean读取器XmlBeanDefinitionReader对象，加载Bean资源文件 ↓resourceLoader.getSource(Location)获取资源 ↓加载Bean配置文件，对xml进行解析成Document对象 ↓按照Spring IoC识别的Bean规则在DefaultDefinitionDocumentReader中对Document对象进行解析 ↓解析文件的&lt;Import&gt;、&lt;Alias&gt;、&lt;property&gt;、&lt;List&gt;、&lt;Set&gt;等元素，Bean资源文件最终被解析成BeanDefinition对象，是资源原件在IoC中的映射 ↓BeanDefinition在IoC容器中进行注册 至此，Bean资源文件中配置的bean被解析成可以被IoC容器识别的对象且被注册管理起来，IoC容器可以进行索引、查询以及操作；被IoC容器管理起来后，也真正完成了IoC容器的初始化 注意IoC容器中的注册就是维护了一个HashMap，保存了BeanDefinition对象，方便了后续的管理 困了Orz从开始看到现在，四个多小时了，中间还喝了半瓶红葡萄酒，算是对Spring IoC容器的初始化了解了，明天再看AOP，现在真是困了…睡觉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring加载方式及原理]]></title>
      <url>%2F2017%2F08%2F02%2FSpring%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[拆分因为这个是更早建立的，当时没有想到这个部分深入到源码时会这么的多，后面只能分开来看，当然了，也就分开总结吧，这里给出链接 Spring IoC容器初始化Spring IoC依赖注入Spring AOP感悟这个部分差不多花了好几个夜晚，从摸索着研究到开始上手，整理清除思路之后又做笔记写博客，感觉Spring的代码写的很棒，运用到了Java的特性非常之多以及如此精准，同时运用了大量的设计模式，确实是含金量很高的框架，值得我们去看看学学它的源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM内存分配与GC]]></title>
      <url>%2F2017%2F05%2F29%2FJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8EGC%2F</url>
      <content type="text"><![CDATA[=_=本来这部分是不想写的，后面想想还是算了，毕竟是最早开始研究又算是相对了解的地方，这次就顺便总结一下看书的心得吧 JVM内存区域JVM提程序员管理了内存区域，免去了不少麻烦，但我们还是需要去了解的。这个内存区域分为了两大类五个区：方法区与Java堆、虚拟机栈与本地方法栈与程序计数器。具体的解释在很久之前研究String常量池的位置时已经有解释过了，不再赘述 JVM内存分配说到内存分配，还是得先了解一下JVM内存的分代管理，很久之前的一次面试有提到过这个分代机制，不过当时是懵逼的。 JVM的分代机制为了方便管理Java内存中的对象，JVM采用了分代管理的机制，即把整个内存区分为了年轻代、年老代和永久代 年轻代（young gen）：这里的Java对象存活时间非常短，属于经常发生GC的区域 年老代（old gen）：这里的对象是占用内存较大或者是存活时间很长的，一般这里发生的GC就是内存空间真的不足了 永久代（perm gen）：其实这部分内存空间就是JVM内存区域中的方法区，里面存放了类的加载信息、静态变量、常量以及代码等信息，这里一般不会发生GC（不代表没有），一般我们所说的GC是不考虑这个区域的 GC垃圾回收，这部分是JVM关键又重要的一个部分，虽然不需要我们直接参与管理，但一个Java程序员不懂垃圾回收是说不过去的，况且我们可以自由的设置JVM的GC来更好的提高程序运行的性能 什么时候开始GC如何开始GC是我刚开始了解GC到一定程度时考虑的东西，毕竟说是说当内存空间不足时JVM便自动开始GC并回收内存区域，但如何得知JVM内存空间够不够呢？查阅资料得知原来JVM对每个对象都有监视对象的监视器，用来监视对象的地址、大小以及使用情况，当该对象已死后，便会对该对象进行回收呐，总结一下发生GC的条件： 内存空间不足，又创建新对象并分配内存时 主动调用方法来控制GC 系统配置的某些参数改变，例如系统内存空间不足 主动触发GC的方法 对象调用finalize()方法，不保证该方法一定会执行，且最多执行一次 调用System.gc()方法，会触发Full GC Runtime.gc() 如何判断对象“已死”如何判断对象“已死”是一个值得说道的地方，正确判断对象是否存货是开始GC的关键。按照常规定义，我们认为一个没有引用指向的对象便是一个已经死去的对象。这里一般有两种方法来判断对象是否还有引用指向： 引用计数法：每有一个引用指向该对象，则其引用计数就加一 可达性分析：从GC Roots为起始点开始向下遍历，从引用链搜索引用对象（由JVM自己的监视器来负责） 主流的商用语言都采用可达性分析的方法来判断对象是否存活，其实这有一个相对详细的过程，JVM会在对象被会收前进行两次标记，两次标记完成后，该对象才是真正意义上的死亡。 两次标记与对象的复活JVM宣告一个对象真正死亡是需要对其进行两次标记的：如果对象经历过可达性分析后没有与GC Roots相连接的引用链，便会对其进行第一次标记，并根据其是否需要执行finalize()方法为条件进行筛选，如果需要执行便会调用finalize()方法，便会被放到一个F-Queue队列中，排队准备执行；如果不需要执行，直接进行第二次标记。 说到执行finalize()方法，这就是对象复活的最后一个机会，只要在执行的方法中重新建立一个引用关联即可。否则会被当作死亡对象进行第二次标记。但JVM不保证finalize()方法执行完毕，所以最好不用这个方法来进行GC，交给JVM管理就好 综上猜想，finalize()方法就是给该对象进行第二次标记并通知JVM回收 可作为GC Roots的对象阿里的一次面试问到了这里，但当时没有记清楚，所有没有答好 虚拟机栈（线程私有栈）中引用的对象 方法区中类的静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 OopMap这个地方也是面试时提到了，但是当时把它跟GC Roots的知识点记混了，尴尬，小哥很nice的说那我们不说这个了（尬笑 HotSot在使用GC Roots的理念时，采用了新的实现方式，因为原来的方式一是任务量大而是GC时间长，因而使用OopMap数据结构来记录栈上不同位置上对象的情况，其本身不存在与栈中，但是保有栈中对象的使用信息。JVM通过查询OopMap就可以得知对象的存活情况 GC使用的算法简单说就三种：标记-清理、复制算法和标记-整理算法 GC的回收器年轻代：Serial、ParNew和Parallel Scavenge年老代：Serial Old、Parallel Old和CMSJDK1.8正式投入商用的G1 GC的种类上面讲过的JVM内存分配机制只是泛泛而谈，算是一个引入，这里再结合内存分配机制与GC来看一下更为具体的内存分配机制 monitor GC：发生在新生代长的GC，（具体的GC过程日后再补 Full GC：发生在新生代和年老代中的GC，算是对整个活动内存的清理 发生Full GC的条件In The End处理完这个，JVM的垃圾回收机制和内存分配机制就差不多了，本来这个是很久之前就应该写的，现在才补上，主要是觉得blog中JVM这个板块的东西有点少且有一点细节记混了，趁着端午放假，正好把JVM剩下的类加载和并发也都处理处理吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小识字符编码]]></title>
      <url>%2F2017%2F05%2F17%2F%E5%B0%8F%E8%AF%86%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[罗罗嗦的复制粘贴以下内容全部来自百度百科 字符编码字符编码也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。 ASCII码：美国(国家)信息交换标准(代)码，一种使用7个或8个二进制位进行编码的方案，最多可以给256个字符(包括字母、数字、标点符号、控制字符及其他符号)分配(或指定)数值。西文字符集。基本的ASCII 字符集共有 128 个字符，其中有 96 个可打印字符，包括常用的字母、数字、标点符号等，另外还有 32 个控制字符。ASCII码使用7位2进制数表示一个字符，7位2进制数可以表示出2的7次方个字符，共128个字符。后期扩展的ASCII码使用8位二进制码，最高位为1。 MBCS码：为了扩充ASCII编码，以用于显示本国的语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码。 #GB2312码：ANSI编码里的一种，GB 2312是一个简体中文字符集，由6763个常用汉字和682个全角的非汉字字符组成。GB2312编码用两个字节(8位2进制)表示一个汉字，所以理论上最多可以表示256×256=65536个汉字。 GBK码：GBK即汉字内码扩展规范，K为扩展的汉语拼音中“扩”字的声母。GBK编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。GB2312码是中华人民共和国国家汉字信息交换用编码，全称《信息交换用汉字编码字符集——基本集》，采用双字节编码。 Unicode码：将世界上所有的符号都纳入其中，无论是英文、日文、还是中文等，大家都使用这个编码表，就不会出现编码不匹配现象。每个符号对应一个唯一的编码，乱码问题就不存在了。这就是Unicode编码。现在的规模可以容纳100多万个符号。有的Unicode编码衍生码使用四字节编码，很浪费资源。 UTF-8码：为了提高Unicode的编码效率，于是就出现了UTF-8编码。UTF-8可以根据不同的符号自动选择编码的长短。英文字母只需要一个字节即可。 Based64码：电子邮件系统中对于汉字的传输有时候会有乱码问题，为了能让邮件系统正常的收发邮件，需要把由其他编码存储的符号转换成ASCII码来传输，最后接收者也通过转换得到了没有乱码的邮件。比如，在一端发送GB2312编码－&gt;根据Base64规则－&gt;转换成ASCII码，接收端收到ASCII码－&gt;根据Base64规则－&gt;还原到GB2312编码。 PS：Java8正式引入Base64编码作为类库的标准]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zpencheng]]></title>
      <url>%2F2017%2F05%2F15%2Fzpencheng%2F</url>
      <content type="text"><![CDATA[声明这是一篇关于PengCheng的自省，如果是误打误撞的就不用看了，基本是废话，以及一些醉话，或者是不知所言的胡言乱语 前言什么叫做“有趣”我想成为什么样的人？我想过什么样的生活？好吧我错了，我真的真的真的真的真的真的真的真的很想很想很想很想变的牛逼，变得引起别人的注意再装作丝毫不在意的样子去说这不是我想要的，但我现在真的真的真的真的真的很像变强，变的更强，变得更牛逼。至于在那之前说出的我不愿意我不想，都是lowB的我自作矫情而又自我安慰自欺欺人的吱呀。那是我的目标。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring学习笔记-基础]]></title>
      <url>%2F2017%2F05%2F08%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[Spring介绍spring是一个开源的轻量级JavaEE框架，使用分层架构，主要部分是面向切面编程（AOP）和控制反转（IOC）容器代码的实现。提高复用性和松耦合，具有动态可扩展性 Eclipse和IDEA的项目构建Eclipse普遍比Idea要好配置的多 Eclipse 新建一个Project，都可以 导入外部的Jar包，组成新的Libraries 如果是Java Web项目还需要把所有的Jar包复制进web/WEB-INF/lib目录下 在src目录下创建applicationContext.xml文件 Idea 创建Java项目，从右边栏中选择Spring4，然后勾上对号 在下方选择Use Libraries，然后选择所需要的Jar包导入成Libraries 一路自由设置 进入项目后在src目录下创建applicationContext.xml文件 为项目配置合适的Artifact、Facets和Modules，就是选选文件配置路径什么的，如果哪里不对或缺失，右下方会有提示，点击fixed就会自动调整了 配置文件的组装一般来说，xml文件内容配置成这样就通用了1234567891011121314151617181920212223&lt;?xmlversion="1.0"encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.1.xsd"&gt; &lt;beans&gt; IOC/DIIOC：控制反转，有的时候也称为DI，也即依赖注入。可以这样理解： IOC容器就是为了管理Bean，创建Bean的一个内存区，在这个内存区中可以将操作Bean的代码以面向接口的方式进行开发。这样基于接口的多态性，程序结构的分层就更加灵活化，维护和扩展也很方便。IOC概念从技术上来讲就是将接口和实现相分离 IOC容器通过IOC容器可以完全管理JavaBean，包括创建、销毁，还可以对数据库的JavaBean进行自动化的事务处理，还支持一些企业级的应用。Spring的IOC容器完全脱离了平台，用最简单的JavaBean技术实现接口与实现的分离，并对组件的调配提供很好的支持 下面开始操作： 先准备一个JavaBean1234567891011121314151617public class CategoryBean &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 注意经过实验发现，如果变量的getter和setter方法命名不规范，在程序运行时会出错。所以建议遵守set+Variale_name和get+Variable_name来命名getter和setter方法 再在applicationContext.xml文件中添加Bean配置12345&lt;beans ....&gt; &lt;bean name="cate" class="pojo.Category"&gt; &lt;property name="name" value="hellosocra" /&gt; &lt;/bean&gt;&lt;/beans&gt; 这里需要讲解一下配置的细节： 首先是标签中的name属性，这里就是创建一个名为cate的CategoryBean对象 xml配置文件中标签的id属性和name属性基本上没有什么区别，但是使用id会更加符合规范，因为xml中id要求是唯一的 class属性的值就是CategoryBean.java的路径，要加上包名 标签是为了给对象cate中的属性赋值的，这里会自动调用变量的getter和setter方法进行赋值，如果命名不规范，就无法赋值 name对应着cate的属性名，value就是赋值，本例赋予了name属性的值是hellosocra 中还可以使用ref来给属性值进行链接，然后使用链接处的值，这也是注入值的过程 使用注入的对象既然已经添加了注入对象的配置，现在看看如何使用注入的对象12345678910111213public class TestSpring &#123; public static void main(String[] args) &#123; // 1.必备的语句，可以定义为全局变量 ApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; "applicationContext.xml" &#125;); // 2.开始使用IOC的getBean()方法来获取对象，但要主要强制类型转换 Category cate = (Category) context.getBean("cate"); // 3.使用Bean对象的方法 System.out.println(cate.getName()); &#125;&#125; 注解方式配置IOC如同在学习Servlet时使用注解配置一样，这里也可使用注解配置，有下面两种 针对“注入对象行为”的注解下面说的这种方式都是主要针对其中一个JavaBean是另一个JavaBean的属性时的注入 注释之前对对象的属性的注入的配置（配置对象是注入，给对象的属性赋值同样是注入） 添加&lt;context:annotation-config/&gt;表示spring要采用注解的方式进行配置 在要注入对象的对应属性前加上@Autowired注解，或者在对应属性的setter方法前加上@Autowired注解 在要注入对象中的属性（另外的JavaBean充当该bean的属性）前加上@Resource(xxx=xxx)注解，举个例子123456789101112class ABean&#123; String name ; int id; // ....getter和setter方法&#125;class BBean&#123; @Resource(name="socra",id=5) A a; // A作为B的属性 int no; // ....getter和setter方法&#125; 针对“Bean”的注解同样的，下面说的这种方式都是主要针对其中一个JavaBean是另一个JavaBean的属性时的注入 在xml文件中把标签中所有的标签都注释掉 添加&lt;context:componment-scan base-backage=&quot;JavaBean所在的包以及Bean名&quot;&gt;，表示spring所需要的Bean都在该路径下 再在该包下所有的Bean类定义之前加上@Compent(&quot;name&quot;)，表名该类是Bean，name是要被注入的该Bean类的对象名 若有一个类是另一个类的属性，则在该属性前加上@Autowired注解 其余的属性可以自由赋值 IOC原理传统的创建对象的方式：通过new关键字来创建一个对象IOC方式：对象的声明周期由Spring来管理，直接从Spring那里获取一个对对象。IOC是反转控制，意即本来对象的控制权在使用者手里，现在反过来交给了Spring 打个比喻：传统方式：相当于你自己去菜市场new 了一直鸡，但是是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。IOC：相当于去馆子(Spring)点了一直 鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。 解释的生动传神，（滑稽 AOPAOP：面向切面编程，意即面向一小段代码编程。AOP把功能分为核心功能和周边功能，而周边功能在Spring的AOP思想里就被定义为切面Aspect。这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程。所谓AOP思想就是两种功能分别独立开发，然后再“编织”在一起 AOP可以在不改变原始代码的基础上做一些功能性的增强 需要额外的Jar包：aspect.jar和aopliance.jar 准备一个核心业务Bean和切面辅助Bean12345678/** * 作为核心业务Bean */public class ProductService&#123; public void dosomeService()&#123; System.out.println("dosomeService"); &#125; &#125; 1234567891011121314151617/** * 作为切面辅助Bean */public class LoggerAspect &#123; public Object log(ProceedingJoinPoint joinPoint)&#123; Object obj = null; System.out.println("start log: " + joinPoint.getSignature().getName()); try &#123; obj = joinPoint.proceed();// 继续执行，本例指执行dosomeService() &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("end log: " + joinPoint.getSignature().getName()); return obj; &#125; &#125; 添加配置1234567891011121314151617&lt;beans ....&gt; &lt;!-- 1.声明核心业务对象 --&gt; &lt;bean id="s" class="service.ProductService"&gt;&lt;/bean&gt; &lt;!-- 2.声明辅助日志切面 --&gt; &lt;bean id="loggerAspect" class="aspect.LoggerAspect"&gt;&lt;/bean&gt; &lt;!-- 5.通过aop:config把业务对象与辅助功能编制在一起 --&gt; &lt;aop:config&gt; &lt;!-- 3.指定核心业务功能 --&gt; &lt;aop:pointcut id="loggerCutpoint" expression= "execution(* service.ProductService.*(..))"/&gt; &lt;!-- 4.指定辅助功能 --&gt; &lt;aop:aspect id="logAspect" ref="loggerAspect"&gt; &lt;aop:around pointcut-ref="loggerCutpoint" method="log"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 首先要规定好核心业务Bean还有切面辅助Bean，设置好它们的对象名以及路径 标签有指定好核心业务和切面辅助入口，id属性都是对象名 中的expression属性的一般值为execution(* package_name.Bean_name.*(..))，表示核心业务Bean中的方法入口（核心业务中可以不止一个方法） 标签中id被注入了值，pointcut-ref属性指定了辅助切面辅助的对象，method是调用辅助切面中的辅助方法 至此已经设置好了切面辅助，当从上到下，先执行核心业务功能后执行辅助业务 使用因为使用AOP，使用时和没有加入切面时的步骤是一样的，正因为如此也体现了AOP的优越特性123456789101112public class TestAspect &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ApplicationContext apc = new ClassPathXmlApplicationContext("applicationContext.xml"); ProductService s = (ProductService)apc.getBean("s"); s.dosomeService(); &#125;&#125; AOP更高级的用法本来是想直接在这次写上的，但是，还是下次和IOC的高级用法写在一起吧，算偷个懒挖个坑。哦，当然了，AOP的注释写法也下次再写好了233333 久违了准备了很久的JavaEE学习，现在终于提上了日程，随便也要把之前遗漏的Servlet和Jsp准备准备填坑了 呐现在挖坑：Servlet学习总结笔记、Jsp总结笔记、Spring更为高级的用法etc PS：首先还是总结这几个框架任意组合的配置方法，idea配置起来真的麻烦啊….F__k]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet与JSP-JavaWeb项目食用指南]]></title>
      <url>%2F2017%2F04%2F10%2FServlet%E4%B8%8EJSP-JavaWeb%E9%A1%B9%E7%9B%AE%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[SocraWeb食用指南项目简介本项目是基于Servlet+JSP+DataBase实现的一个商品管理系统，主要目的是学习JavaWeb入门的知识：Servlet、JSP以及EL表达式、Ajax和JSON。完成这个项目主要还是巩固练习JavaWeb的基础知识，为后面的JavaEE框架的学习做铺垫。所以以本人的学习经验来看，这是一个很好的上手Web的练习项目 Github连接项目存储于：https://github.com/SocraHat/SocraWeb.git 环境配置 MySQL数据库：本人的版本是Server version: 5.7.11 MySQL Community Server (GPL) JDK：版本java version “1.8.0_112” Tomcat：apache-tomcat-7.0.73 JDBC-jar包：mysql-connector-java-5.1.40-bin.jar JSTL-jar包：jstl.jar 开发环境：EclipseEE版本 数据库表单创建 首先确认连接MySQL数据库的用户名是root，密码是123456 创建名为web_manage的数据库 再在该数据下创建名为user，manager，goods和goodsInformation的四个数据表 user的SQL语句为：存储注册用户信息 12345CREATE TABLE user( uid varchar(16) PRIMARY KEY, upsd varchar(16) NOT NULL, uname varchar(16) ); manager的SQL语句为：存储管理员信息 12345CREATE TABLE manager( mid varchar(16) PRIMARY KEY, mpsd varchar(10) , mname varchar(16) ); goods的SQL语句为：存储管理商品的信息 123456CREATE TABLE goods( gid int(11) PRIMARY KEY, gname varchar(50), gprice float, gintroduce varchar(50),); goodsInformation的SQL语句为：商品信息的补充 1234CREATE TABLE goodsInformation( gid int(11) PRIMARY KEY, gintroduce varchar(255),); 功能整个项目主要的功能是增删改查 用户的注册登陆以及退出 主页商品的查看和查询商品 用户信息的修改 管理员登陆修改自己的信息 管理员修改商品信息 增加、删除商品信息 过滤器对于没有权限的访问不予通过 操作说明具体的导入工程（Eclipse或者是IDEA）请自行百度，在导入项目后启动Tomcat服务器后就可以直接食用了。但是有几点需要再注意下 用户需要登陆才能查看商品详细信息（权限设置） 只有管理员才有权限去更改商品的各个信息 可能在程序中设置有session的存活时间，所以长时间不对页面操作而导致登陆状态消失时请重新登录 修改商品信息、用户信息、管理员信息时一定注意不能是空值null，另外在新增商品时注意商品的编号不能是0 其余的基本操作可以自己去尝试，和一般的网页处理事务的顺序原理相似 项目总结项目前后历时还是有个个把月的，但主要还是最后的这两天完成实现了大部分功能，虽然只是一个初级的小项目，但是内心还是充满了欢喜的。这部分知识不敢说全部掌握，起码也有个六七八了，后面的细节，再做补充。 难点感觉项目中比较棘手的地方： 页面的合理设计：追求一定美观合适，也使用了BootStrap 前后台数据的交互：有时需要用到Servlet到JSP或是Servlet的转发，有时需要用到Session，有时需要用到JS的跳转，错综复杂，但是编码问题，调用的方法，需要后续再补充一篇细节总结 使用JS来获取页面的表格中的数据并使用Ajax传递到后台 登陆后的登出以及验证问题 程序和数据库交互问题：如何正确又高效的查询 初步尝试MVC（Servlet+JSP+JavaBean）模式，虽然分了层，但是感觉还是不够清晰简洁 使用过滤器实现权限的判断和页面的跳转 责任声明本项目纯属个人项目，因为本人能力问题，可能某些地方的处理不合适或是有误，欢迎大家提出宝贵意见。若是对您学习造成了误导，本人表示十分抱歉。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM中String常量池与运行时常量池]]></title>
      <url>%2F2017%2F03%2F29%2FJVM%E4%B8%ADString%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[Start with JVM周志明先生著-《深入理解Java虚拟机》，书买回来好几天了，但是最近才准备开始搞一搞了（哭瞎…..）。首先是第一章的Java以及JVM发展历史，大概知道了现行的应用最广泛的Java虚拟机是HotSpot，当然一些商业公司也有使用自己的虚拟机。 JVM运行时数据区这是放在Java内存区域与内存溢出异常里面的必备知识，描述了Java虚拟机在运行时的数据区域↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓私有 程序计数器：记录当前线程所执行字节码的行号指示器 虚拟机栈：存放了当前线程调用方法的局部变量表、操作数栈、动态链接、方法返回值等信息（可以理解为线程的栈） 本地方法栈：为虚拟机使用的Native方法提供服务，后多与JVM Stack合并为一起 共享 Java堆：占据了虚拟机管理内存中最大的一块（没想到吧），唯一目的就是存放对象实例（与引用是两个概念），也是垃圾回收器主要管理的地方，故又称GC堆。先开坑，后面讲垃圾回收机制再详述 方法区：存储加载的类信息、常量区、静态变量、JIT（即时编译器）处理后的数据等，类的信息包含类的版本、字段、方法、接口等信息。需要注意是常量池就在方法区中，也是我们这次需要关注的地方。 提一下这个Native方法指得就是Java程序调用了非Java代码，算是一种引入其它语言程序的接口 看一下方法区方法区因为总是存放不会轻易改变的内容，故又被称之为“永久代”。HotSpot也选择把GC分代收集扩展至方法区，但也容易遇到内存溢出问题。可以选择不实现垃圾回收，但如果回收就主要涉及常量池的回收和类的卸载（这里开坑，后续补上链接） 运行时常量池回归本次讨论正题，主要是在看Java和C++的一些原理时，老是有“常量池”这个我一知半解的讨厌的字词，烦的一批，今天我就来探一探究竟。 JVM中运行时常量池在方法区中，因为是建立在JDK1.7/1.8的基础上来研究这个，所以我先认为String常量池在堆中。Class文件中除了类的版本、字段、方法、接口等描述信息，还有常量池，用于存放编译期生成的各种字面量和符号引用 运行时常量池与Class文件常量池区别 JVM对Class文件中每一部分的格式都有严格的要求，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行；但运行时常量池没有这些限制，除了保存Class文件中描述的符号引用，还会把翻译出来的直接引用也存储在运行时常量区 相较于Class文件常量池，运行时常量池更具动态性，在运行期间也可以将新的变量放入常量池中，而不是一定要在编译时确定的常量才能放入。最主要的运用便是String类的intern()方法 在方法区中，常量池有运行时常量池和Class文件常量池；但其中的内容是否完全不同，暂时还未得知 String.intern()检查字符串常量池中是否存在String并返回池里的字符串引用；若池中不存在，则将其加入池中，并返回其引用。这样做主要是为了避免在堆中不断地创建新的字符串对象 那class常量池呢？具体的等分析到Class文件格式再来填这个坑，先来看常量池中的内容：看一下dalao的博客Class文件中常量池详解 看一看String常量池（的特殊姿势）吧在研究这个的时候我也上网看了别人的博客，有的人做出了实验，我也试一下 实验一123456public class Test&#123; public static String a = "a"; public static void main()&#123; String b = "b"; &#125;&#125; 使用Java自带的反编译工具反编译一下，编译后输入javap -verbose Test.class 可以发现两个静态String变量都放入了常量池中 实验二12345public class Test2&#123; public static String str = "laji" + "MySQL"; public static void main()&#123; &#125;&#125; 在编译前先分析一波，按理说，既然是静态String常量，那么理应出现在常量池（Constant Pool）中，但 来看看进阶版的Test2_212345678public class Test2_2&#123; public static void main(String[] args)&#123; String string1 = "laji"; String string2 = "MySQL"; String string3 = string1+string2; String string4 = string1+"C"; &#125;&#125; 这个的结果就更有意思了↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓总商量个实验，可以看出 对于直接做+运算的两个字符串（字面量）常量，并不会放入String常量池中，而是直接把运算后的结果放入常量池中 对于先声明的字符串字面量常量，会放入常量池，但是若使用字面量的引用进行运算就不会把运算后的结果放入常量池中了 总结一下就是JVM会对String常量的运算进行优化，未声明的，只放结果；已经声明的，只放声明 实验三123456789public class Test3&#123; public static void main(String[] args)&#123; String str = "laji"; String str2 = new String("MySQL"); String str3 = new String("laji"); System.out.println(str==str3);// 运行后结果为false &#125;&#125; 结果为：这个实验三包含了很多内容，首先是new一个对象时，明明是在堆中实例化一个对象，怎么会出现常量池中？ 这里的&quot;MySQL&quot;并不是字符串常量出现在常量池中的，而是以字面量出现的，实例化操作（new的过程）是在运行时才执行的，编译时并没有在堆中生成相应的对象 最后输出的结果之所以是false，就是因为str指向的”laji”是存放在常量池中的，而str3指向的”laji”是存放在堆中的，==比较的是引用（地址），当然是false 实验四主要是为了解释一下intern()方法的用处1234567891011public class Test4&#123; public static void main(String[] args)&#123; String str = "laji"; String str2 = new String("laji"); String str3 = null; System.out.println(str==str2);// 运行后结果为false str3 = str2.intern(); System.out.println(str==str3);// 运行后结果为true &#125;&#125; 显然，str3在初始化的时候是从字符串常量池中获取到的值 String常量池随JDK的改变JDK1.7中JVM把String常量区从方法区中移除了；JDK1.8中JVM把String常量池移入了堆中，同时取消了“永久代”，改用元空间代替（Metaspace）12345678910111213141516171819202122import java.util.ArrayList;public class TestString &#123; public static void main(String[] args) &#123; String str = "abc"; char[] array = &#123;'a', 'b', 'c'&#125;; String str2 = new String(array); //使用intern()将str2字符串内容放入常量池 str2 = str2.intern(); //这个比较用来说明字符串字面常量和我们使用intern处理后的字符串是在同一个地方 System.out.println(str == str2); //那好，下面我们就拼命的intern吧 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000000; i++) &#123; String temp = String.valueOf(i).intern(); list.add(temp); &#125; &#125;&#125; 这个实验最早是2014年有人实验过的，ta得出的结论是Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space，然而时至今日，我自己按照ta的代码跑了一遍，并没有出现上述的错误，虽然一段时间内内存资源占用呈上升状态。猜想：所使用JDK版本不同，对于String常量池存放的位置已经发生了改变；或者是两者的电脑硬件不同实验出处 然后，我又看到了这个新的实验证明String常量池的位置，JVM参数设置：-Xmx5m -XX:MaxPermSize=5m1234567891011121314import java.util.ArrayList;import java.util.List;public class TestString2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while(true)&#123; list.add(String.valueOf(i++).intern()); &#125; &#125;&#125; 因为JDK版本不同的原因，我无法按照上述的代码得出原博文相同的结果，这是我自己运行出的结果 sun官方说明：并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。 对照着结果以及上面的博客可以得知，这显然是在堆中的垃圾回收发生了异常所致。在内存满后，会进行垃圾回收，但又会intern新的字符串到String常量池中，那么就会导致垃圾回收器一直不停的干着没有意义的活，时间一久，自然报错。同时原文中所提及的这一句话我觉得需要注意一下： 另外一点值得注意的是，虽然String.intern()的返回值永远等于字符串常量。但这并不代表在系统的每时每刻，相同的字符串的intern()返回都会是一样的（虽然在95%以上的情况下，都是相同的）。因为存在这么一种可能：在一次intern()调用之后，该字符串在某一个时刻被回收，之后，再进行一次intern()调用，那么字面量相同的字符串重新被加入常量池，但是引用位置已经不同。 综上，虽自己没有太多的明确结果证明，但是我想这已经能够印证JDK版本变化导致的String常量池位置的改变。 日常summary这个本来是今天计划打算进行的一部分，结果好像进入牛角尖了，一定要深入一下…..，结果垃圾回收也没有看多少，明天继续。但终于算是把这一块搞的一清二楚了，😜 吐槽一下第一次听说垃圾分代时是懵逼的，分袋？还用分袋装垃圾？这是真的吗？现在了解了才发现自己的想法真是666]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三月中]]></title>
      <url>%2F2017%2F03%2F12%2F%E4%B8%89%E6%9C%88%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[几句随谈前几天听胡哥讲课（正经课），理所当然的提到了鸡汤（这不是日常吗），本着我就静静的看着的心态突然某些话还是触动了什么…遇到不会的解决不了的怎么办？看书上网查资料，还是不会呢？问有经验的人，要还是解决不了呢？ 解决问题而不是解释问题，总想着等我把这个学完了再开始弄这个，什么时候是个头？ 买书！买什么书？酸透了的爱情文学？《二十岁的青春》？愤世嫉俗的批判分析？熟悉人情掌控全局的厚黑学？买了你看了吗？为什么坚持一定要买？ 突然明白了什么其实，有时候努力钻研但是举步维艰而心生退意很正常，我花了这么多时间，回报呢？受益呢？别人这么久都又敲了那么多代码，看了那么厚的书，然而，自己还是没有把问题解决…….可是，看书不会问人，问人再不会再看书，周而复始，没有一点点进步吗？没有一点点收获吗？每一天只要不虚度踏实的学习，不管在干什么，这不都是收获吗？ 总想着不会，不敢，想着先大概了解一下内容，然后再用，再看，确实很低效，但是没有办法，有时候，就是想知道为什么，就是不想稀里糊涂的完成了，这是一种感觉是一种情怀，没有为什么，没有不敢、怂，可是确实和内心的想法有矛盾？ 买书好，一定要花钱，不然不心疼，花钱是一种享受，买了可以不看，太多了的时候可以扔，扔的时候会有一个筛选的过程，尽管可能是不自知的，但一直都认为，提高生活质量的最有效方式就是定期扔东西，something and sometimes，同理 心态本来几天前就该写的，因为周一下午接到了面试电话，约到了周二晚上，怀着忐忑的心准备了，并等待着，等到了电脑没电，等到了深夜，电话没有打来……第一次经历这样的事情（说不清楚心理变化），唯一能想得就只有继续前进，满满的压力，来自四面八方，羡慕dalao，只是希望到自己面对社会时，能感到，还好我做到了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Servlet重定向与转发区别]]></title>
      <url>%2F2017%2F03%2F02%2FServlet%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[RTservlet在对客户端请求的数据处理之后，会向客户端返回相应的响应结果。这个响应结果可以是由当前servlet对象的PrintWriter输出流直接输出到页面上的信息，也可以是一个新的URL地址对应的信息。在servlet中通过两种方式完成对新URL地址的转向：重定向和请求转发。 URL与URI区别一图胜千言系列 ↓↓↓ 重定向由原请求地址重新定位到某个新地址，原有的请求失效，客户端看到的是新的请求返回的响应结果，客户端浏览器地址栏变为新的请求地址。其中第二次请求是由客户端浏览器自动发出。 请求转发请求转发是将请求再转发到其他地址，转发过程中使用的是同一个请求，转发后浏览器地址栏内容不变。 区别 转发只能将请求转发给同一个web应用（项目工程）中的其他组件（servlet程序）；重定向可以重定向到任意的地址，网络地址或是文件地址（跨项目文件夹） 重定向访问结束后，浏览器地址栏URL发生变化，变成了重定向后的URL；转发则不变 重定向对浏览器的请求直接做出响应，结果就是告诉浏览器去重新发出另一个新的URL访问请求；请求转发在服务器端内部将请求转发给另一个资源，浏览器不知道服务器程序内部发生了转发过程 请求转发调用者与被调用者之间共享相同的请求对象，属于同一个请求和响应过程；重定向则是不同的请求和响应过程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[alter和update以及drop和delete区别]]></title>
      <url>%2F2017%2F02%2F28%2Falter%E5%92%8Cupdate%E4%BB%A5%E5%8F%8Adrop%E5%92%8Cdelete%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[RT使用MySQL时，很多语法相似，容易记浑，比如alter和update，比如drop和delete。 alter和update区别 alter是对表的结构进行的操作，比如增加删除表的字段，或者是修改字段的顺序 update是对表中的数据进行的操作，比如依据某个字段修改当前记录中另一个字段的值 drop和delete区别 drop是对表本体进行的操作，比如删除整张表。如果需要对表的结构进行增删，使用alter delete是对表的数据进行的操作，比如删除某一条记录 总的来说，如果你不想要这张表了，用drop，如果你还想用这张表，只是删除一些数据，用delete]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL使用手册]]></title>
      <url>%2F2017%2F02%2F28%2FMySQL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[MySQL语法总结MySQL结构：数据库中存放数据都是依托与一张张的数据表存在的，我们通过数据库可以高效的利用数据；而我们对数据的操作就是对数据库中的表的操作。 SQL数据类型：字符型：&lt;varchar&gt; VS &lt;char&gt;文本型：&lt;text&gt;数值型：&lt;int&gt; VS &lt;smallint&gt; VS &lt;tinyint&gt;浮点型：&lt;float&gt; VS &lt;decinal&gt;逻辑型：&lt;bit&gt;日期型：&lt;datetime&gt; VS &lt;smalldatetime&gt; MySQL基本操作（格式）：登陆mysql -u root -p默认没有密码，直接回车，也可以自行修改密码。操作数据库中的表单时，一定要先USE &lt;数据库名&gt;来进入该数据库 创建 创建数据库：CREATE databases &lt;数据库名&gt;; 创建表单：CREATE table &lt;表名&gt;; 查询单表查询：123SELECT &lt;字段名一，字段名二，...&gt;FROM &lt;表名&gt;WHERE &lt;查询条件&gt;; 查询所有数据库：SHOW DATABASE; 选中某个数据库进行操作：USE &lt;数据库名&gt; 查询某数据库中所有的表：SHOW TABLES; 查询表中某字段的数据：SELECT &lt;字段名一,字段名二....&gt; FROM &lt;表名&gt;; 查询某记录：SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;; （多个）查询条件：&lt;字段名&gt; =值 &amp;&amp; &lt;字段名&gt; =值 查询表中的所有记录：SELECT * FROM &lt;表名&gt;; 查询表结构字段名（不包含外键）：DESC &lt;表名&gt;; 查询表创建时（修改后）的SQL语句：SHOW CREATE TABLE &lt;表名&gt;;可以用来查看外键信息 查询从指定位置开始、一定数量的记录：SELECT &lt;列名&gt; FROM &lt;表名&gt; LIMIT &lt;查询数量&gt; OFFSET &lt;开始位置&gt; ; 连接查询：可以使用表的别名（eg：table1 A） 内连接-等值连接：指使用等号”=”比较两个表的连接列的值，相当于两表执行笛卡尔后，取两表连结列值相等的记录-SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; INNER JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt;; 内连接-非等值连接：SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; INNER JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; &gt;(或者&lt;) &lt;表名B.字段名&gt;; 外连接-左外连接：指将左表的所有记录与右表符合条件的记录匹配，返回的结果除内连接的结果，同时如果有左表不符合条件的记录，就在右表相应列中填NULL-SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; LEFT JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt; 外连接-右外连接：SELECT &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; FROM &lt;表名A&gt; RIGHT JOIN &lt;表名B&gt; ON &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt; 自然连接：MySQL中的自然连接是自动将两个表中相同名称的列进行记录匹配SELECT &lt;表名A.字段名&gt;,&lt;表名B.字段名&gt; FROM &lt;表名A&gt; NATURAL JOIN &lt;表名B&gt;; 自连接：用别的表实现自身表的连接-SELECT &lt;表名B.字段名(*)&gt; FROM &lt;表名A.字段名(*)&gt;,&lt;表名B.字段名(*)&gt; WHERE &lt;表名A.字段名&gt; = &lt;表名B.字段名&gt; AND &lt;查询条件&gt;; 嵌套查询：将一个查询块嵌套在另一个查询块的WHERE子句或者HAVING短语的条件中的查询 含IN的子查询：可以多层嵌套-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; IN (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;); 含ANY的子查询：查询的条件符合另一个查询结果的任一个即可-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; &lt;ANY(或者是&gt;ANY、=ANY) (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;) 含EXISTS的子查询：EXISTS代表存在量词∃。带有EXISTS谓词的子查询不返回任何数据，只产生逻辑值true或者false-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;字段名&gt; EXISTS (SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;) 集合查询：SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作主要包括并操作UNION、交操作INTERSECT、差操作EXCEPT，在MySQL替换过来就是OR、AND、EXISTS/IN 集合并查询：实质上是进行两次查询操作然后将结果取并集-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; UNION SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt;，可以使用语句取代-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; OR &lt;查询条件&gt; 集合交查询：MySQL不支持直接的交集查询，使用替代语句-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; AND &lt;查询条件&gt; 集合差查询：MySQL不支持直接的差集查询-SELECT &lt;字段一,字段二...&gt; FROM &lt;表名&gt; WHERE &lt;查询条件&gt; AND &lt;查询条件&gt;，具体使用时逻辑符号会变。或者使用IN或者EXISTS 排序 按照某字段升序排列：SELECT * FROM &lt;表名&gt; ORDER BY &lt;字段名&gt; LIMIT &lt;待排列的记录数&gt;; 降序排列：SELECT * FROM &lt;表名&gt; ORDER BY &lt;字段名&gt; DESC LIMIT &lt;待排列的记录数&gt;; 插入 插入记录：INSERT INTO &lt;表名&gt; VALUES(&#39;...&#39;,&#39;&#39;,&#39;&#39;,....); 插入某一字段：ALTER TABLE &lt;表名&gt; ADD &lt;字段名&gt; &lt;字段类型&gt; ; 删除 删除数据库：DROP DATABASE &lt;数据库名&gt;; 删除未被外键关联的表：DROP TABLE IF EXISTS &lt;表名&gt;; 删除已经外键关联的表：先删除子表再删除父表 删除表中的某一条记录：DELETE FROM &lt;表名&gt; WHERE &lt;字段=值&gt;; 删除表中的某一字段：ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;; 删除外键约束：ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键名&gt; 修改 修改表名：ALTER TABLE &lt;旧表名&gt; RENAME TO &lt;新表名&gt;; 修改表中的字段名：ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;数据类型&gt;; 修改表中字段的数据类型：ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;新数据类型&gt;; 修改表中字段的顺序：ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt; FIRST/AFTER &lt;字段名&gt;; 修改表中某一记录某一字段的值：UPDATE &lt;表名&gt; SET &lt;字段名&gt;=&lt;新值&gt; WHERE &lt;查询条件&gt;; 在表都创建之后添加外键：ALTER TABLE &lt;需要添加外键的表名&gt; ADD CONSTRAINT &lt;外键名&gt; FOREIGN KEY(&lt;需添加外键的表的字段名&gt;) REFERENCES &lt;被作为外键的表名&gt; (&lt;被作为外键的字段名&gt;); 索引index索引可以有重复的值，而unique和primary key索引列中的值时唯一的 ALTER创建索引（可同时添加多个表的索引列） ALTER TABLE &lt;表名&gt; ADD INDEX &lt;索引名（可省缺）&gt;(索引字段名); ALTER TABLE &lt;表名&gt; ADD UNIQUE(&lt;索引字段名&gt;); ALTER TABLE &lt;表名&gt; ADD PRIMARY KEY(&lt;索引字段名&gt;); CREATE增加索引 CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;索引字段名&gt;); CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;索引字段名&gt;); 查询索引：SHOW INDEX FROM &lt;表名&gt;;或者SHOW KEYS FROM &lt;表名&gt;; 删除索引：DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;;或者ALTER TABLE &lt;表名&gt; DROP INDEX &lt;索引名&gt;或者ALTER TABLE &lt;表名&gt; DROP PRIMARY KEY; 设置约束关系主键，又称主码，主键约束就是作为主键的字段在记录中是唯一存在的，不可重复，并且也不许为空。就像我们每个人都有自己唯一的身份ID一样，唯一标识。利用这个特性，我们可以在数据库中快速的查询定位到一条记录。 设置主键：创建表的时候，在定义字段以及数据类型的后面直接加上PRIMARY KEY (默认值)；或者在定义完所有的字段以及数据类型后，加上PRIMARY KEY (&lt;字段名一,....&gt;) 外键，表中的一个或多个字段，可以不是本表的主键，但必须是另一个表的主键。外键用来在两个表中建立连接关系，对于有关联关系的两个表而言，相关联字段中主键所在的表为父表，外键所在的表为子表。 设置外键：在表中所有字段都定义后（包括外键名），加上CONSTRAINT &lt;外键约束名&gt; FOREIGN KEY(外键名) REFERENCES &lt;关联的外表名(外表的字段名)&gt;; 注意的是，这里的外键约束名与外键名是不同的意思同一个数据库中，外键约束名和外键名一定不可以重复！！！ /(ㄒoㄒ)/~~ 视图视图包含行和列，其中的字段来自一个或多个数据库中的真实的表中的字段，一起组合成一个类似真实的表。可以像基本表一样，进行增删改查的操作。记录进行改动后，视图与基本表都会更新 创建视图： 1234CREATE VIEW &lt;视图名&gt;(视图字段名一,字段名二,...(可选)) AS &lt;子查询语句&gt;SELECT &lt;字段名一,字段名二,...&gt;FROM &lt;表名&gt;WHERE &lt;查询条件&gt;; 删除视图：DROP VIEW &lt;视图名&gt;; 查询视图：SELECT * FROM &lt;视图名&gt;;或者SLECT &lt;字段名&gt; FROM &lt;视图名&gt;; 修改视图：可以向上述修改字段/记录的方式一样来修改视图，并且修改结果各个实际的表也会生效，也可以按下面的方法修改↓↓↓↓↓1234CREATE OR REPLACE VIEW &lt;视图名&gt;(视图字段名一,字段名二,...(可选)) AS &lt;子查询语句&gt;SELECT &lt;字段名一,字段名二,...&gt;FROM &lt;表名&gt;WHERE &lt;查询条件&gt;; 某些情况下可以缺省视图的字段名，MySQL会自动补全。但是当SELECT后面的字段有来自函数查询的结果时，不可以缺省。 添加注释/备注 给表添加描述：ALTER TABLE &lt;表名&gt; COMMENT=&#39;这里是表的注释&#39; 给列添加描述：ALTER TABLE &lt;表名&gt; MODIFY &#39;&lt;字段名&gt;&#39; DATETIME DEFAULT NULL COMMENT &#39;字段描述&#39; 心得谈一谈外键约束关系：在两个相关联的表中，一个表的主键是另一个表的非主键字段，这个字段中的值可能有很多。就拿学生选课来说，某一个课程可能有很多学生选，学生的主键是学号，那么该课程的表中，学号这一外键就会有很多值，同时，也把课程的数据表和学生的数据表关联了起来。呐，在这个例子中，课程的表就是子表，学生的数据表就是父表。倘若，父表的值改变了，那么一定需要修改子表的值，而子表想去修改外键的值是没有权限的；但是，子表可以删除带有外键值的记录。这之中就有一种很明显的约束关系。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse编写jsp自动导入包]]></title>
      <url>%2F2017%2F02%2F27%2FEclipse%E7%BC%96%E5%86%99jsp%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%2F</url>
      <content type="text"><![CDATA[RT使用eclipse我们会需要一个自动补全剩余代码的功能，这使得我们可以在输完一些变量或者方法甚至是包的时候，可以方便快捷的选择我们想要输入的内容。very convenient！~ 这个关键性的组合按键就是：alt + / 当然了，这个在写java程序的时候可以使用，在写jsp程序的时候，依然是这个组合键 QvQ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux终端配色方案]]></title>
      <url>%2F2017%2F02%2F27%2Flinux%E7%BB%88%E7%AB%AF%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[Ubuntu终端配色骚年，看到单调的黑色背景的终端是不是感觉很乏味？试试这个教程吧，可以使终端变的beautiful~ First使用快捷键ctrl + alt + T打开终端键入gedit ~/.bashrc会弹出一个编辑文本，复制粘贴下面的代码到文件的最后部分：1PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;35;01m\]\u\[\033[00;00;01m\]@\[\033[01;35;01m\]\h\[\033[00;31;01m\]:\[\033[00;00;01m\]\w \[\033[01;32;01m\]\$ \[\033[01;01;01m\]&apos; 注意代码两边的冒号‘。保存后退出即可。 Second关闭终端后重新打开终端，可以看到，终端的配色方案已经有了变化。然后，在终端中点击鼠标右键，选择下面的选项然后选择Background标签，勾选上Transparent background选项，这是打开终端背景透明的选项。 Final设置后透明度之后，点击close即可，这时你的终端就会变的很好(炫)看(闪)了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[github上传项目]]></title>
      <url>%2F2017%2F02%2F27%2Fgithub%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[RT今天下午突发奇想，打开了小站，然后顺便打开了github，于是想上传曾经做过的项目，本来想按照之前传博客的方法去传项目，然后发现，好像哪里不太对劲，仔细一看教程，确实不太一样。于是乎就去找github上传本地项目的方法，下面总结一下自己的试坑过程。 First-创建本地仓库首先要在自己的本地磁盘内创建一个文件夹，名字自己随便取，用来当作自己本地存放项目并且用来和github交互的仓库。我这里创建一个名为 mygit的文件夹。 Second-在github上创建项目仓库登陆自己的github，然后新建仓库，项目名字自己取，我这里取了try这个名字。勾选项和我的设置保持一致即可。 Third-设置ssh密钥git shell程序随便选一个安装，打开shell后，输入命令：ssh-keygen -C &#39;your@email.address&#39; -t rsa注意的是，这个 ‘ ‘ 中的内容就是你的github账号，因为一般是用邮箱注册的。然后不需要管弹出什么内容，什么请输入密码啊什么的，联系按三个回车键，然后在你的电脑的用户目录下找一个名为.ssh的文件夹。打开其中的id_rsa.pub文件，然后复制全部的内容。接着打开你github项目设置里面，左侧栏有一个选项SSH and GPG Keys，打开后，点击右上角的new SSH key按钮，title栏随便输入提示性，key栏把刚才复制的内容全部粘贴进去。确认后会显示一把绿色的小钥匙。 完成上述步骤后，在git shell中输入命令ssg -T git@github.com，注意，这里需要是大写的-T，不知道怎么回事，我输入小写的t就是不行。正确的显示结果如下：则表明已经成功连接至你的github库了。 Fouth-“装填”项目文件在git shell运行命令：git clone https://github.com/your name/you program name.git其实后面的链接就是你打开你的github项目中的仓库后，网页中网址链接，复制粘贴即可。这个时候会在你本地仓库目录中生成文件夹，名字就是你的项目的名字，同时还会有一个隐藏的.git文件。在我举的这个例子中，这个文件夹就是try。然后，只需要把想要上传到仓库中的项目文件全部放到这个文件夹中就好了，我的话就是把项目文件放入到try文件夹中就好。 然后，在git shell中输入以下命令：git initgit add xxx （注意这个名字就是想上传文件夹的名字，没有&#39; &#39;）git commit -m &#39;your-program-name&#39; （这里有&#39; &#39;，内容也是想上传文件夹的名字），一定注意要先add文件注意这里可能会有错误，↓↓↓↓↓↓↓↓↓↓↓↓↓↓那就使用git commit -am &quot;your-program-name&quot;这条命令再继续 如果正确，会有类似的显示结果：然后继续输入git remote add origin https://github.com/your-name/you-program-name.git这里可能会出现错误↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓那就使用git remote rm origin，在继续下一步thengit pull origin master这里会即进入Vi编辑器的界面，是需要你输入merge的理由，随便写，不会vim编辑器语法的我后面讲。git push origin master如果步骤都正确，会有这样的过程和结果： 总结上述步骤有些复杂，一般情况下可以使用更为简单的12345git add xxxgit commit -m &quot;这次提交的备注信息&quot;git push -u origin master Attention这里简单说一下vim编辑器的使用吧，本次操作只需要两个命令即可：i 开始进行编辑内容:wq 编辑完成后，按Esc，进入命令界面，输入:wq，表示保存及退出 Final到此为止，已经正确上传了项目到你自己的github中，以后也可以重复上面除了新建ssh密钥的步骤外别的操作来继续上传。当然了，如果只需要修改部分文件或者是上传部分文件，又或者是有其他github的操作，请自行移步git使用教程。当然了，以后我自己也会进行某些内容更新。QvQ2017.04.09补充：Github桌面版简化了很多步骤，方便的一批]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo生成博文插入图片]]></title>
      <url>%2F2017%2F02%2F26%2Fhexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[RT十分痛苦，是因为突然发现上传的博客里面的图片居然显示不来，excuse me???笋干shabi了怎么办，上网google解决之道，然后又试了很多坑…….更加绝望了…..然后，看到了这个：dalao指导hhhh，再试一次….. 然而，居然可以了….excuse me?? 好吧，总结一下这个牛批的解决办法： First1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 3 等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 Second4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 注意：xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 总结一下这个跳（试）坑的过程首先是有句mmp想讲，实在是有点坑 但是，似乎又多了一项学（zhuang）习（bi）技巧 hhh，先到这里，后面还有一个坑就是，想引入某些dalao 的链接时，如果链接里包含中文，那么再写入md文件里生成网页后这个链接就打不开了….. 待老夫研究后再填坑，后面如果有时间，就把自己搭建网站的过程码一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Final]]></title>
      <url>%2F2017%2F02%2F21%2FFinal%2F</url>
      <content type="text"><![CDATA[第一天的总结差不多先折腾到这里吧，大概已有的功能呢，有添加博客和归档的标签，以后还会完成自己的个人简历 Q^Q 说到了这里，这两天自己摸索着使用github来搭建自己的个人网站确实受益良多，贴出大腿的指导书： https://volc1605.github.io/2016/10/03/Hexo之NexT主题搭建博客详细过程 暂时的尝试先到此为止，明后天看看能不能再去抢个腾讯的服务器吧，fightting！骚年]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[f__k? this day]]></title>
      <url>%2F2017%2F02%2F21%2Ffuck%2F</url>
      <content type="text"><![CDATA[Today今天是特别的一天，忙碌了一整天的时间来学习搭建个人网站博客。到现在为止，略有小成，先写下这一篇随笔，然后全当做实验了。 ps:没有大腿抱确实一个人折腾好累pss:折腾完又有种莫名的兴奋感……QvQ]]></content>
    </entry>

    
  
  
</search>
