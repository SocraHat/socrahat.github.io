<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java反射之Class初级用法]]></title>
      <url>http://yoursite.com/2017/03/10/java%E5%8F%8D%E5%B0%84%E4%B9%8BClass%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>Class类的实例表示java应用运行时的类或接口（每个java类在运行的时候都会在JVM里表现为一个Class对象，可以通过<code>类名.Class</code>，<code>类型.getClass()</code>，<code>Class.forName(&quot;包.类名&quot;)</code>等方法获取Class对象）</p>
<h2 id="Class类的特点"><a href="#Class类的特点" class="headerlink" title="Class类的特点"></a>Class类的特点</h2><p>Class类的父类是Object，事实上，任何java类，不管是jdk里面的还是自定义的，都是Class类的对象，同时，所有的数据类型、关键字、方法等等，一切的一切都是Class类的对象。这是前提，很关键</p>
<h2 id="Class类的运行原理"><a href="#Class类的运行原理" class="headerlink" title="Class类的运行原理"></a>Class类的运行原理</h2><p>java种创建对象时不是通过类直接创建的，一个类的对象被创建之前，首先JVM会加载该类的字节码文件（.class文件），也就是编译后的java程序文件；加载完成后，JVM会自动的为该类创建自己的Class对象，再通过Class对象创建目标对象</p>
<h1 id="使用Class的目的"><a href="#使用Class的目的" class="headerlink" title="使用Class的目的"></a>使用Class的目的</h1><p>很简单的一句话，可以利用反射机制重新获取到Object对象，这个是动态加载类以及对象的，是在程序运行时才会发生的动作，至于反射机制的具体应用，先挖个坑，以后填</p>
<h1 id="API文档的仿制"><a href="#API文档的仿制" class="headerlink" title="API文档的仿制"></a>API文档的仿制</h1><p>按照Class类的特性，java种的一切都是Class类的对象，我们可以获取到这些“对象”的信息，比如任意类的属性、构造方法、所有方法等等信息，诚然，我们甚至可以做出一个API文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</div><div class="line">		<span class="comment">// 1.返回与带有给定字符串名的类或接口相关联的 Class 对象，直接导致该类被初始化</span></div><div class="line">		Class testClass = Class.forName(<span class="string">"java.lang.Class"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">// 2. 获取该类的实例化对象</span></div><div class="line">		Class testClass2 =  Class.class;</div><div class="line">		</div><div class="line">		<span class="comment">// 3.获取该类的实例化Class对象</span></div><div class="line">		Class testClass3 = <span class="keyword">new</span> Test().getClass();</div><div class="line">		</div><div class="line">		String target = <span class="string">"([a-zA-Z_-]+)\\."</span>; <span class="comment">// 需要匹配的正则表达式，表示了形如“字母+.”的模式，这样便去除了某个类的包名前缀</span></div><div class="line">		</div><div class="line">		Class&lt;? <span class="keyword">super</span> Object&gt; superC = testClass.getSuperclass();</div><div class="line">		String name = superC.getName();</div><div class="line">		System.out.print(<span class="string">"Class的父类是："</span> + name.replaceAll(target, <span class="string">""</span>) + <span class="string">"\n"</span>);</div><div class="line">		</div><div class="line">		Constructor&lt;Class&gt;[] consClass = testClass.getDeclaredConstructors();</div><div class="line">		System.out.println(<span class="string">"Class的构造方法有："</span>);</div><div class="line">		<span class="keyword">for</span>(Constructor con : consClass)&#123;</div><div class="line">			name = con.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Class&lt;Class&gt;[] classes = testClass.getClasses();</div><div class="line">		System.out.println(<span class="string">"Clsass所有的成员的公共类和接口："</span>);</div><div class="line">		<span class="keyword">if</span>(classes.length==<span class="number">0</span>)</div><div class="line">			System.out.println(<span class="string">"null"</span>);</div><div class="line">		<span class="keyword">for</span>(Class cla : classes)&#123;</div><div class="line">			name = cla.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"Class的属性是："</span>);</div><div class="line">		Field[] fields = testClass.getDeclaredFields();</div><div class="line">		<span class="keyword">for</span>(Field f : fields)&#123;</div><div class="line">			name = f.toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Method[] methods = testClass.getMethods();</div><div class="line">		System.out.println(<span class="string">"Class的所有方法是："</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;methods.length; i++)&#123;</div><div class="line">			name = methods[i].toString();</div><div class="line">			name = name.replaceAll(target, <span class="string">""</span>);</div><div class="line">			System.out.println(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		ClassLoader loader = testClass.getClassLoader();<span class="comment">// 如果对象是基本类型或者是void，则返回null</span></div><div class="line">		System.out.println(<span class="string">"Class的类加载器是："</span> + loader);</div></pre></td></tr></table></figure></p>
<p>这只是一个简单的思路介绍，重要的是从0到1的过程，至于怎么从1到n，这需要更多的努力。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解HashMap]]></title>
      <url>http://yoursite.com/2017/03/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      <content type="html"><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>哈希，译作散列，或哈希。就是把任意长度的输入，通过散列算法（hash算法），变换成固定长度的输出，这个输出的值就是哈希值。显然这是一个映射的过程。</p>
<h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><p>再来看一看HashCode，这是一个方法，该方法返回一个特殊的值，在java中会返回一个整数，用来判断是否是两个相同的对象，和equals方法有紧密的联系：</p>
<ul>
<li>HashCode主要用于提供快捷的查找，在HashTable和HashMap中都有使用，HashCode是用来在散列存储结构中确定对象的存储地址的</li>
<li>如果使用equals(Objetc)方法，两个对象相等，那么这两个对象调用hashCode方法返回的值一定是相等的</li>
<li>如果两个对象中的equals方法被重写了，那么一定也要按照同样的方法来重写hashCode方法（这是为了保持hashCode方法的常规协定，规定了相等对象必须有相同的hashCode值）</li>
<li>借用网上看来的文章的一句话：两个对象的hashCode相同，不代表就是同一个对象/两个对象相同，在hash存储结构中，这只说明了两个对象发生了冲突，被分配在了同一个桶里面。java判断两个对象是否相同还会判断对象引用中存储的地址是否相同（默认）</li>
</ul>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>hash函数，用来计算出哈希值的函数，通常情况下，每一个对象都有自己单独的哈希值，通过hash函数计算出后，可以做到唯一识别。虽然有可能会有冲突的情况出现，出现了同一个hash值，但概率是微乎其微再来n个微乎其微…..<br>hash函数的用途有这么几个：可以这么说，hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<ul>
<li>文件校验：通过对文件摘要，可以对文件进行校验，一定程度上能检测并纠正数据传输中的信道误码，但不能防止对数据的恶意破坏</li>
<li>数字签名：在数字签名协议中，用的最多的单向散列函数可以产生一个机构的数字签名</li>
<li>数据结构中提供快速查找的功能：常用的数据结构HashMap和HashTable会使用到Hash函数来产生hash值，是组成HashMap优越性能必不可少的一环</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>在分析这个HashMap之前我们先来看一看数组和链表，我们都知道，数组提供了很好的查找性能，因为数组空间是连续的，查找起来很方便，但是在数据的插入和删除时，性能就不佳了；再看链表，它的存储空间是离散的，所以在数据的插入删除时，性能很高，但是当论到查找时，其性能就不行了。<br>综上所述，我们总是在面对问题时，根据自己的需求来使用不同的数据结构，这是权衡和妥协的结果。那么我们如果能使用到一种数据结构，它提供良好的查找性能，又可以很方便的插入删除。于是乎，把这两种数据结构组合起来就有了我们这个HashTable。<br>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<br><img src="/2017/03/05/深入理解HashMap/hash.png" alt="hash"><br>从图中可以看出，这是由数组和链表组成的数据结构，在数组中每个元素存储的是一个链表的头指针，把一个个数据存放到相应的位置，就需要由hash函数来计算了，一般是采用<strong>hash(value)%length计算出元素应该放到对应下标的数组中的位置</strong>。比如，如果value为5，数组长度为10，则计算出的下标位置就是5%10=5，这个值应该放到下标为5的元素中。当然了，如果俩个值计算出存放的位置相同了，就<strong>以后存入的值为头节点，以链表的形式存入，以此类推</strong></p>
<p>现在回过头来看看HashMap，它其实也是一个线性的数组实现的，所以可以理解为其存储的数据结构就是一个线性数组。但是有一点我们需要注意的就是，HashMap是按照键值对来存取数据的，这一点怎么可能通过数组或是链表来实现呢？</p>
<p>深入到HashMap的源码中去看，对照着资料，发现在HashMap中存取数据的关键有一个叫做Map.Entry的内部接口很是关键，再去看Entry，发现它被定义为<code>Entry&lt;Key,Value&gt;</code>，而<strong>Map.Entry<k,v>就是一个键值对的实体</k,v></strong>。如果说HashMap是依靠于数组存储，那么这个数据就是Entry[]，Map存储的内容都在Entry[]里面</p>
<h2 id="HashMap存取的实现"><a href="#HashMap存取的实现" class="headerlink" title="HashMap存取的实现"></a>HashMap存取的实现</h2><p>在“线性数组”的基础上如何做到随机存储呢：重点是确定键值对的存储位置，这里是希望HashMap里面的元素尽量离散分布，使每个位置上的元素只有一个。当使用hash算法求出这个位置时，马上就可以获取对应位置的值，而不用取遍历链表。也与hash方法的离散性能密切相关<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hash jdk1.8</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单说起来，这里的Hash算法本质上就是三步：<strong>取key的hashCode的值、高位运算、取模运算</strong><br>对于任意对象，只要hashCode返回值相同，那么程序调用方法所计算的Hash码时一样的，把hash值对数组的长度取模运算，这样元素的分布相对来说是比较均匀的。在上面的方法中，通过<strong>把hashCode返回值高16位和低16位与计算，达到了hashCode返回值取模数组长度的效果</strong>。因为在HashMap底层数组中，length总是2的n次方（不够的用null填充），此时<strong>使用hashCode返回值与数组长度进行与运算</strong>依然达到了上述的效果，这是jdk1.7中的实现方法，在1.8中高16位与低16位进行与运算是优化的算法，能保证在hashCode返回值很大时，高低Bit都会参与到hash运算中，并且不会产生较大的开销</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>我们知道HashMap中<strong>键 Key</strong>一定是唯一的，那么当再次往HashMap中存入键相同的键值对时，上一次存入的键值对就会被<strong>覆盖</strong>。但是如果两个键值对的index值一样时，HashMap会把先存入的值放入链表的尾部，<strong>最新加入的值则是该线性数组中每个下标对应的链表的首元素</strong>，以此类推。<br><strong>需要注意到的是，jdk1.8新增了HashMap链表中节点的个数对于8个时，转为红黑树的存储方式</strong><br>查看HashMap中的put方法源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> 		<span class="comment">// 进行hash运算</span></div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">// 判断键值对数组table是否为空或null，否则进行resize扩容</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        <span class="comment">// 根据键值key计算hash得到插入位置的索引</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">// 判断键值对中key是否存在（相同），存在直接覆盖，相同指hashCode和equals</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            <span class="comment">// 判断是否为树，是的话直接插入新结点</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">// 链表</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 如果链表的长度大于8就 转化为红黑树处理</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// key已经存在，直接覆盖</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">// 插入成功判断是否超出了最大容量，是就进行扩容</span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>reszie的源码是将原来数组的容量扩大一倍，<strong>这个过程是一个十分消耗性能的过程，所以在使用中最好定一个预定的最大值，避免HashMap进行频繁的扩容</strong>。默认的负载因子是0.75</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 先检查链表中的首结点</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first; <span class="comment">// 判断出了与key相同（hashCode和equals）</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            	<span class="comment">// 继续根据hash查找</span></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="comment">// 不在首结点，不在红黑树，只能遍历链表</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>我们总是希望整个HashMap是一个尽量离散的优秀结构，用尽量少的空间存储尽量多的数据，且其查找增删的性能依据很高效。这个是一个复杂的平衡过程，和负载因子相关，和解决hash冲突的办法相关：hash冲突是指两个key被分配到了同一个桶中</p>
<ul>
<li>开放定址法（线性探查再散列、二次探查再散列、为随机探查再散列）</li>
<li>再哈希法</li>
<li>链地址法（拉链法）</li>
<li>建立一个公共的溢出桶<br><strong>java中的HashMap使用的就是拉链法，如前面图所示</strong></li>
</ul>
<h2 id="再散列过程-rehash"><a href="#再散列过程-rehash" class="headerlink" title="再散列过程 rehash"></a>再散列过程 rehash</h2><p>当哈希表的容量超过默认的大小时，就需要将所有的元素换一个新的“桶”来存储，这个新的桶中的键值对存放的位置会发生改变，需要重新根据新桶的大小来重新计算各个键值对的索引位置，这个过程就叫做rehash</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此次深入探究java中的HashMap查阅了不少资料和源码，感谢先行者的指引，这里仅是个人愚见，如有异议，欢迎联系<br><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="external">HahsMap实现原理分析</a><br><a href="http://www.importnew.com/20386.html" target="_blank" rel="external">java8重新认识HahsMap</a></p>
<p><img src="/2017/03/05/深入理解HashMap/lianhong.jpg" alt="lianhong"></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet重定向与转发区别]]></title>
      <url>http://yoursite.com/2017/03/02/Servlet%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>servlet在对客户端请求的数据处理之后，会向客户端返回相应的响应结果。这个响应结果可以是由当前servlet对象的PrintWriter输出流直接输出到页面上的信息，也可以是一个新的URL地址对应的信息。<br>在servlet中通过两种方式完成对新URL地址的转向：重定向和请求转发。</p>
<h2 id="URL与URI区别"><a href="#URL与URI区别" class="headerlink" title="URL与URI区别"></a>URL与URI区别</h2><p>一图胜千言系列  ↓↓↓<br><img src="/2017/03/02/Servlet重定向与转发区别/url.png" alt="url"></p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>由原请求地址重新定位到某个新地址，原有的请求失效，客户端看到的是新的请求返回的响应结果，客户端浏览器地址栏变为新的请求地址。其中第二次请求是由客户端浏览器自动发出。<br><img src="/2017/03/02/Servlet重定向与转发区别/redirect.png" alt="redirect"></p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>请求转发是将请求再转发到其他地址，转发过程中使用的是同一个请求，转发后浏览器地址栏内容不变。<br><img src="/2017/03/02/Servlet重定向与转发区别/dispatcher.png" alt="dispatcher"></p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>转发只能将请求转发给同一个web应用（项目工程）中的其他组件（servlet程序）；重定向可以重定向到任意的地址，网络地址或是文件地址（跨项目文件夹）</li>
<li>重定向访问结束后，浏览器地址栏URL发生变化，变成了重定向后的URL；转发则不变</li>
<li>重定向对浏览器的请求直接做出响应，结果就是告诉浏览器去重新发出另一个新的URL访问请求；请求转发在服务器端内部将请求转发给另一个资源，浏览器不知道服务器程序内部发生了转发过程</li>
<li>请求转发调用者与被调用者之间共享相同的请求对象，属于同一个请求和响应过程；重定向则是不同的请求和响应过程</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[alter和update以及drop和delete区别]]></title>
      <url>http://yoursite.com/2017/02/28/alter%E5%92%8Cupdate%E4%BB%A5%E5%8F%8Adrop%E5%92%8Cdelete%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用MySQL时，很多语法相似，容易记浑，比如alter和update，比如drop和delete。</p>
<h1 id="alter和update区别"><a href="#alter和update区别" class="headerlink" title="alter和update区别"></a>alter和update区别</h1><ul>
<li>alter是对表的结构进行的操作，比如增加删除表的字段，或者是修改字段的顺序</li>
<li>update是对表中的数据进行的操作，比如依据某个字段修改当前记录中另一个字段的值</li>
</ul>
<h1 id="drop和delete区别"><a href="#drop和delete区别" class="headerlink" title="drop和delete区别"></a>drop和delete区别</h1><ul>
<li>drop是对表本体进行的操作，比如删除整张表。如果需要对表的结构进行增删，使用alter</li>
<li>delete是对表的数据进行的操作，比如删除某一条记录</li>
</ul>
<p>总的来说，如果你不想要这张表了，用drop，如果你还想用这张表，只是删除一些数据，用delete</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL使用手册]]></title>
      <url>http://yoursite.com/2017/02/28/MySQL%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h1 id="MySQL语法总结"><a href="#MySQL语法总结" class="headerlink" title="MySQL语法总结"></a>MySQL语法总结</h1><h2 id="MySQL结构："><a href="#MySQL结构：" class="headerlink" title="MySQL结构："></a>MySQL结构：</h2><p>数据库中存放数据都是依托与一张张的数据表存在的，我们通过数据库可以高效的利用数据；而我们对数据的操作就是对数据库中的表的操作。</p>
<h2 id="SQL数据类型："><a href="#SQL数据类型：" class="headerlink" title="SQL数据类型："></a>SQL数据类型：</h2><p>字符型：<code>&lt;varchar&gt; VS &lt;char&gt;</code><br>文本型：<code>&lt;text&gt;</code><br>数值型：<code>&lt;int&gt; VS &lt;smallint&gt; VS &lt;tinyint&gt;</code><br>逻辑型：<code>&lt;bit&gt;</code><br>日期型：<code>&lt;datetime&gt; VS &lt;smalldatetime&gt;</code></p>
<h2 id="MySQL基本操作（格式）："><a href="#MySQL基本操作（格式）：" class="headerlink" title="MySQL基本操作（格式）："></a>MySQL基本操作（格式）：</h2><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p><code>mysql -u root -p</code><br>默认没有密码，直接回车，也可以自行修改密码。<br>操作数据库中的表单时，一定要先<code>use &lt;数据库名&gt;</code>来进入该数据库</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li>查看数据库：<code>show databases;</code></li>
<li>查看某数据库中所有的表：<code>show tables;</code></li>
<li>查看表中某字段的数据：<code>select &lt;字段名一,字段名二....&gt; from &lt;表名&gt;;</code></li>
<li>查看某记录：<code>select &lt;字段一,字段二...&gt; from &lt;表名&gt; where &lt;查询条件&gt;;</code><ul>
<li>（多个）查询条件：<code>&lt;字段名&gt; =值 &amp;&amp; &lt;字段名&gt; =值</code></li>
</ul>
</li>
<li>查看表结构：<code>desc &lt;表名&gt;;</code></li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>创建数据库：<code>create databases &lt;数据库名&gt;;</code></li>
<li>创建表单：<code>create table &lt;表名&gt;;</code></li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>按照某字段升序排列：<code>select * from &lt;表名&gt; order by &lt;字段名&gt; limit &lt;待排列的记录数&gt;;</code></li>
<li>降序排列：<code>select * from &lt;表名&gt; order by &lt;字段名&gt; desc limit &lt;待排列的记录数&gt;;</code></li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>插入记录：<code>insert into &lt;表名&gt; values(&#39;&#39;,&#39;&#39;,&#39;&#39;,....);</code></li>
<li>插入某一字段：<code>insert into &lt;表名&gt; &lt;字段名&gt;;</code></li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除未被外键关联的表：<code>drop table if exists &lt;表名&gt;;</code></li>
<li>删除已经外键关联的表：先删除子表再删除父表</li>
<li>删除表中的某一条记录：<code>delete from &lt;表名&gt; where &lt;字段=值&gt;;</code></li>
<li>删除表中的某一字段：<code>alter table &lt;表名&gt; drop &lt;字段名&gt;;</code></li>
<li>删除外键约束：<code>alter table &lt;表名&gt; drop foreign key &lt;外键名&gt;</code></li>
</ul>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul>
<li>修改表名：<code>alter table &lt;旧表名&gt; rename to &lt;新表名&gt;;</code></li>
<li>修改表中的字段名：<code>alter table &lt;表名&gt; modify &lt;旧字段名&gt; &lt;新字段名&gt; &lt;数据类型&gt;;</code></li>
<li>修改表中字段的数据类型：<code>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;新数据类型&gt;;</code></li>
<li>修改表中字段的顺序：<code>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;数据类型&gt; first/after &lt;字段名&gt;;</code></li>
<li>修改表中某一记录某一字段的值：<code>update &lt;表名&gt; set &lt;字段名&gt;=&lt;新值&gt; where &lt;查询条件&gt;;</code></li>
</ul>
<h3 id="设置约束关系"><a href="#设置约束关系" class="headerlink" title="设置约束关系"></a>设置约束关系</h3><p><strong>主键</strong>，又称主码，主键约束就是作为主键的字段在记录中是唯一存在的，不可重复，并且也不许为空。就像我们每个人都有自己唯一的身份ID一样，唯一标识。利用这个特性，我们可以在数据库中快速的查询定位到一条记录。</p>
<ul>
<li>设置主键：创建表的时候，在定义字段以及数据类型的后面直接加上<code>primary key (默认值)</code>；或者在定义完所有的字段以及数据类型后，加上<code>primary key (&lt;字段名一,....&gt;)</code></li>
</ul>
<p><strong>外键</strong>，表中的一个或多个字段，可以不是本表的主键，但<strong>必须是另一个表的主键</strong>。外键用来在两个表中建立连接关系，对于有关联关系的两个表而言，相关联字段中主键所在的表为父表，外键所在的表为子表。</p>
<ul>
<li>设置外键：在表中所有字段都定义后（包括外键名），加上<code>constraint &lt;外键约束名&gt; foreign key(外键名) references&lt;关联的外表名(外表的字段名)&gt;;</code></li>
</ul>
<p><strong>注意的是，这里的外键约束名与外键名是不同的意思</strong><br><strong>同一个数据库中，外键约束名和外键名一定不可以重复！！！</strong> /(ㄒoㄒ)/~~</p>
<h3 id="添加注释-备注"><a href="#添加注释-备注" class="headerlink" title="添加注释/备注"></a>添加注释/备注</h3><ul>
<li>给表添加描述：<code>alter table &lt;表名&gt; comment=&#39;这里是表的注释&#39;</code></li>
<li>给列添加描述：<code>alter table &lt;表名&gt; modify &#39;&lt;字段名&gt;&#39; datetime default null comment &#39;字段描述&#39;</code></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p><strong>外键约束关系</strong>：<br>在两个相关联的表中，一个表的主键是另一个表的非主键字段，这个字段中的值可能有很多。就拿学生选课来说，某一个课程可能有很多学生选，学生的主键是学号，那么该课程的表中，学号这一外键就会有很多值，同时，也把课程的数据表和学生的数据表关联了起来。<br>呐，在这个例子中，课程的表就是子表，学生的数据表就是父表。倘若，父表的值改变了，那么一定需要修改子表的值，而子表想去修改外键的值是没有权限的；但是，子表可以删除带有外键值的记录。这之中就有一种很明显的约束关系。</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse编写jsp自动导入包]]></title>
      <url>http://yoursite.com/2017/02/27/Eclipse%E7%BC%96%E5%86%99jsp%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>使用eclipse我们会需要一个自动补全剩余代码的功能，这使得我们可以在输完一些变量或者方法甚至是包的时候，可以方便快捷的选择我们想要输入的内容。very convenient！~</p>
<p>这个关键性的组合按键就是：<br><code>alt + /</code></p>
<p>当然了，这个在写java程序的时候可以使用，在写jsp程序的时候，依然是这个组合键 QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中几个获取长度的方法区别]]></title>
      <url>http://yoursite.com/2017/02/27/java%E4%B8%AD%E5%87%A0%E4%B8%AA%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="length和length-和size"><a href="#length和length-和size" class="headerlink" title="length和length()和size()"></a>length和length()和size()</h1><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>length是数组的属性，直接使用<code>.</code>来进行访问，用来获取数组的长度。</p>
<h2 id="length-1"><a href="#length-1" class="headerlink" title="length()"></a>length()</h2><p>length()是一个方法，针对的是String类型，用来获取字符串的长度。</p>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>size()是方法，用于获取泛型集合的大小，以便了解其中的元素个数。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java线程]]></title>
      <url>http://yoursite.com/2017/02/27/java%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="java线程体会"><a href="#java线程体会" class="headerlink" title="java线程体会"></a>java线程体会</h1><h2 id="为什么需要使用线程："><a href="#为什么需要使用线程：" class="headerlink" title="为什么需要使用线程："></a>为什么需要使用线程：</h2><p>​    我们知道，一般程序都是以一个由上至下的运行方式运行的，不完成上一步的时候，是无法进入下一步的执行的。可是我们有时候需要在一个程序同时去做两个不同的任务，各自之间互不干涉，那么根据程序的执行过程，该如何解决呢？</p>
<p>​    答案就是使用<strong>线程</strong>，所谓线程，就是一个程序中最小的执行单元，一个程序在运行时就是一个进程，一个进程可以包含多个线程，这样就允许了一个程序同时去做不同的任务。所以总结的说，我们<strong>需要使用线程来让程序在同一时间做不同的事情，并且互不干涉。</strong></p>
<p>注：</p>
<ul>
<li><strong>程序</strong>是包含了所有执行文件、数据文件、图像文件以及各种文档的资源集合，存储在电脑磁盘里</li>
<li><strong>进程</strong>是一个程序在运行时所需要的所有资源集合，包含了代码、数据、堆栈、变量等，就像一台电脑。</li>
<li><strong>线程</strong>是进程的子集，每一个线程可以看作是进程中的一个执行单元，就像CPU。</li>
</ul>
<hr>
<h2 id="线程的基本特点："><a href="#线程的基本特点：" class="headerlink" title="线程的基本特点："></a>线程的基本特点：</h2><p>​    在不同的语言中，线程有不同的实现方式，但都有共同的基本特征：</p>
<ul>
<li>没有属于自己的内存空间，所有使用的空间都是由进程统一安排分配</li>
<li>​在线程中使用的数据会存放到属于自己的栈中，但栈中的数据我们是知道的，是不会保留下来的 :cry:</li>
<li>线程的上下文切换是比进程要快很多倍的，而且新建一个线锁需要的时间开销也是少于进程的；但有优点就一定会有缺点，线程的开销是很大的，每创建一个线程都至少要分配512KB甚至是1MB字节的内存，还有的线程及进程的区别可以去看有关操作系统的书</li>
</ul>
<hr>
<h2 id="使用线程的方法："><a href="#使用线程的方法：" class="headerlink" title="使用线程的方法："></a>使用线程的方法：</h2><ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ul>
<p>虽然都可以实现线程的控制，但是我们在实际中却用到第二种方法比较多，原因就是<strong>我们有时候需要继承不止一个类</strong>，这时如果我们不去实现Runnable接口，我们该如何使这个类编程线程类呢？:happy:</p>
<hr>
<h2 id="实现线程类需要注意的地方："><a href="#实现线程类需要注意的地方：" class="headerlink" title="实现线程类需要注意的地方："></a>实现线程类需要注意的地方：</h2><ul>
<li><p>我们想让线程去做的任务都写在run方法里</p>
</li>
<li><p>线程类创建后我们需要去启动线程，而不是调用run方法，不然就仍旧还是方法调用</p>
</li>
<li><p>启动线程的方法</p>
<p>   实现Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  <span class="keyword">new</span> Thread(ball).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   继承Thrad类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"hello thread"</span>);</div><div class="line">    <span class="comment">//我们想使用多线程实现的内容</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseBall</span> </span>&#123;</div><div class="line">  Ball ball = <span class="keyword">new</span> Ball();</div><div class="line">  ball.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用线程进行操作的时候注意添加异常操作</p>
</li>
</ul>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​    综上所述，线程的使用方法以及一些特点就在这里了。<strong>个人理解其使用的条件就是想让程序同时完成不同的任务时，使用多线程实现。</strong></p>
<p>​    多线程是java重要的的特点之一，利用多线程我们可以完成很多特殊的功能，比如：弹球游戏、坦克大战和聊天室等等。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[writeUTF学习]]></title>
      <url>http://yoursite.com/2017/02/27/writeUTF%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="流式输出对象的writeUTF-方法"><a href="#流式输出对象的writeUTF-方法" class="headerlink" title="流式输出对象的writeUTF()方法"></a>流式输出对象的writeUTF()方法</h1><p>记录如何使用字节数组来进行数据的传输</p>
<h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h2><p>作为所有输入输出流的父类，其方法read和write</p>
<h2 id="DataInputStream-DataOutputStream"><a href="#DataInputStream-DataOutputStream" class="headerlink" title="DataInputStream / DataOutputStream"></a>DataInputStream / DataOutputStream</h2><p>处理流，包含了很多对数据的处理方法readInt，readFully和writeInt，write。另外因为是处理流，需要套在节点流上使用，故构造方法需要一个参数InputStream / OutputStream</p>
<h2 id="InputStraemReader"><a href="#InputStraemReader" class="headerlink" title="InputStraemReader"></a>InputStraemReader</h2><p>该类一个接收System.in输入的内容</p>
<h2 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><p>可以将InputStreamReader流中的内容当成字符串整行的读取出来</p>
<h2 id="flush-close"><a href="#flush-close" class="headerlink" title="flush() / close()"></a>flush() / close()</h2><p>所有的输出流在写完后最好都强制刷新一下缓冲flush，程序接收后把整个输入输出流关掉</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket通信字节流or字符流]]></title>
      <url>http://yoursite.com/2017/02/27/socket%E9%80%9A%E4%BF%A1%E5%AD%97%E8%8A%82%E6%B5%81or%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      <content type="html"><![CDATA[<h1 id="socket通信选择字节流还是字符流？"><a href="#socket通信选择字节流还是字符流？" class="headerlink" title="socket通信选择字节流还是字符流？"></a>socket通信选择字节流还是字符流？</h1><p>字符流处理的单元为2个字节的Unicode字符，分别操作字符、字符数组或字符串，而字节流处理单元为1个字节，操作字节和字节数组。所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性比较好！如果是音频文件、图片、歌曲，就用字节流好点，如果是关系到中文（文本）的，用字符流好点。</p>
<p> 所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列</p>
<p>1.字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串；<br>2.字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以</p>
<hr>
<p>字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的 但实际中很多的数据是文本，又提出了字符流的概念，它是按虚拟机的encode来处理，也就是要进行字符集的转化。这两个之间通过 InputStreamReader,OutputStreamWriter来关联，实际上是通过byte[]和String来关联，在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的 </p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux终端配色方案]]></title>
      <url>http://yoursite.com/2017/02/27/linux%E7%BB%88%E7%AB%AF%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h1 id="Ubuntu终端配色"><a href="#Ubuntu终端配色" class="headerlink" title="Ubuntu终端配色"></a>Ubuntu终端配色</h1><p>骚年，看到单调的黑色背景的终端是不是感觉很乏味？<br>试试这个教程吧，可以使终端变的beautiful~</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>使用快捷键<code>ctrl + alt + T</code>打开终端<br>键入<code>gedit ~/.bashrc</code><br>会弹出一个编辑文本，复制粘贴下面的代码到<strong>文件的最后部分</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;35;01m\]\u\[\033[00;00;01m\]@\[\033[01;35;01m\]\h\[\033[00;31;01m\]:\[\033[00;00;01m\]\w \[\033[01;32;01m\]\$ \[\033[01;01;01m\]&apos;</div></pre></td></tr></table></figure></p>
<p><strong>注意代码两边的冒号<code>‘</code></strong>。<br>保存后退出即可。</p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>关闭终端后重新打开终端，可以看到，终端的配色方案已经有了变化。<br>然后，在终端中点击鼠标右键，选择下面的选项<br><img src="/2017/02/27/linux终端配色方案/caidan.png" alt="caidan"><br>然后选择<code>Background</code>标签，勾选上<code>Transparent background</code>选项，这是打开终端背景透明的选项。<br><img src="/2017/02/27/linux终端配色方案/caidan2.png" alt="caidan2"></p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>设置后透明度之后，点击close即可，这时你的终端就会变的很好(炫)看(闪)了。<br><img src="/2017/02/27/linux终端配色方案/zhongduan.png" alt="zhongduan"></p>
]]></content>
      
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github上传项目]]></title>
      <url>http://yoursite.com/2017/02/27/github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>今天下午突发奇想，打开了小站，然后顺便打开了github，于是想上传曾经做过的项目，本来想按照之前传博客的方法去传项目，然后发现，好像哪里不太对劲，仔细一看教程，确实不太一样。<br>于是乎就去找github上传本地项目的方法，下面总结一下自己的试坑过程。</p>
<h2 id="First-创建本地仓库"><a href="#First-创建本地仓库" class="headerlink" title="First-创建本地仓库"></a>First-创建本地仓库</h2><p>首先要在自己的本地磁盘内创建一个文件夹，名字自己随便取，用来当作自己本地存放项目并且用来和github交互的仓库。<br><img src="/2017/02/27/github上传项目/wenjianjia.png" alt="wenjianjia"><br>我这里创建一个名为 mygit的文件夹。</p>
<h2 id="Second-在github上创建项目仓库"><a href="#Second-在github上创建项目仓库" class="headerlink" title="Second-在github上创建项目仓库"></a>Second-在github上创建项目仓库</h2><p>登陆自己的github，然后新建仓库，项目名字自己取，我这里取了<code>try</code>这个名字。<br><img src="/2017/02/27/github上传项目/chuangjiancangku.png" alt="chuangjiancangku"><br>勾选项和我的设置保持一致即可。</p>
<h2 id="Third-设置ssh密钥"><a href="#Third-设置ssh密钥" class="headerlink" title="Third-设置ssh密钥"></a>Third-设置ssh密钥</h2><p>git shell程序随便选一个安装，打开shell后，输入命令：<br><code>ssh-keygen -C &#39;your@email.address&#39; -t rsa</code><br>注意的是，这个 ‘ ‘ 中的内容就是你的github账号，因为一般是用邮箱注册的。<br>然后不需要管弹出什么内容，什么请输入密码啊什么的，联系按三个回车键，然后在你的电脑的用户目录下找一个名为<code>.ssh</code>的文件夹。<br><img src="/2017/02/27/github上传项目/ssh.png" alt="ssh"><br>打开其中的<code>id_rsa.pub</code>文件，然后复制全部的内容。<br>接着打开你github项目设置里面，左侧栏有一个选项<code>SSH and GPG Keys</code>，打开后，点击右上角的<code>new SSH key</code>按钮，title栏随便输入提示性，key栏把刚才复制的内容全部粘贴进去。确认后会显示一把绿色的小钥匙。</p>
<p>完成上述步骤后，在git shell中输入命令<code>ssg -T git@github.com</code>，注意，这里需要是大写的<code>-T</code>，不知道怎么回事，我输入小写的t就是不行。正确的显示结果如下：<br><img src="/2017/02/27/github上传项目/link.png" alt="link"><br>则表明已经成功连接至你的github库了。</p>
<h2 id="Fouth-“装填”项目文件"><a href="#Fouth-“装填”项目文件" class="headerlink" title="Fouth-“装填”项目文件"></a>Fouth-“装填”项目文件</h2><p>在git shell运行命令：<code>git clone https://github.com/your name/you program name.git</code><br>其实后面的链接就是你打开你的github项目中的仓库后，网页中网址链接，复制粘贴即可。<br>这个时候会在你本地仓库目录中生成文件夹，名字就是你的项目的名字，同时还会有一个隐藏的<code>.git</code>文件。在我举得这个例子中，这个文件夹就是<code>try</code>。<br>然后，只需要把想要上传到仓库中的项目文件全部放到这个文件夹中就好了，我的话就是把项目文件放入到<code>try</code>文件夹中就好。</p>
<p>然后，在git shell中输入以下命令：<br><code>git init</code><br><code>git add xxx</code>  （注意这个名字就是想上传文件夹的名字，没有<code>&#39; &#39;</code>）<br><code>git commit -m &#39;your-program-name&#39;</code>  （这里有<code>&#39; &#39;</code>，内容也是想上传文件夹的名字）<br>如果正确，会有类似的显示结果：<br><img src="/2017/02/27/github上传项目/gitinit.png" alt="gitinit"><br>然后继续输入<br><code>git remote add origin https://github.com/your-name/you-program-name.git</code><br><code>git pull origin master</code><br>这里会即进入Vi编辑器的界面，是需要你输入merge的理由，随便写，不会vim编辑器语法的我后面讲。<br><code>git push origin master</code><br>如果步骤都正确，会有这样的过程和结果：<br><img src="/2017/02/27/github上传项目/gitend.png" alt="gitend"></p>
<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><p>这里简单说一下vim编辑器的使用吧，本次操作只需要两个命令即可：<br><code>i</code> 开始进行编辑内容<br><code>:wq</code> 编辑完成后，按<code>Esc</code>，进入命令界面，输入:wq，表示保存及退出</p>
<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>到此为止，已经正确上传了项目到你自己的github中，以后也可以重复上面除了新建ssh密钥的步骤外别的操作来继续上传。当然了，如果只需要修改部分文件或者是上传部分文件，又或者是有其他github的操作，请自行移步git使用教程。<br>当然了，以后我自己也会进行某些内容更新。QvQ<br><img src="/2017/02/27/github上传项目/xiexie.jpg" alt="xiexie"></p>
]]></content>
      
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo生成博文插入图片]]></title>
      <url>http://yoursite.com/2017/02/26/hexo%E7%94%9F%E6%88%90%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>十分痛苦，是因为突然发现上传的博客里面的图片居然显示不来，excuse me???<br><img src="/2017/02/26/hexo生成博文插入图片/juewang.jpg" alt="juewang.jpg"><br>笋干shabi了<br>怎么办，上网google解决之道，然后又试了很多坑…….<br><img src="/2017/02/26/hexo生成博文插入图片/zenmeban.jpg" alt="zenmeban.jpg"><br>更加绝望了…..<br>然后，看到了这个：<a href="http://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="external">dalao指导</a><br>hhhh，再试一次…..<img src="/2017/02/26/hexo生成博文插入图片/meibanfa.jpg" alt="更加juewang"></p>
<p>然而，居然可以了….excuse me??</p>
<p>好吧，总结一下这个牛批的解决办法：</p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">dalao的git</a></p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个<strong>同名的文件夹</strong></p>
<h2 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h2><p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<p><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<p><strong>注意：</strong>xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<h2 id="总结一下这个跳（试）坑的过程"><a href="#总结一下这个跳（试）坑的过程" class="headerlink" title="总结一下这个跳（试）坑的过程"></a>总结一下这个跳（试）坑的过程</h2><p>首先是有句mmp想讲，实在是有点坑</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/haoqi.jpg" alt="haoqi"></p>
<p>但是，似乎又多了一项学（zhuang）习（bi）技巧<img src="/2017/02/26/hexo生成博文插入图片/bang.jpg" alt="bang"></p>
<p>hhh，先到这里，后面还有一个坑就是，想引入某些dalao 的链接时，如果链接里包含中文，那么再写入md文件里生成网页后这个链接就打不开了…..</p>
<p>待老夫研究后再填坑，后面如果有时间，就把自己搭建网站的过程码一下。</p>
<p><img src="/2017/02/26/hexo生成博文插入图片/xiexie.jpg" alt="xiexie"></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Final]]></title>
      <url>http://yoursite.com/2017/02/21/Final/</url>
      <content type="html"><![CDATA[<h1 id="第一天的总结"><a href="#第一天的总结" class="headerlink" title="第一天的总结"></a>第一天的总结</h1><p>差不多先折腾到这里吧，大概已有的功能呢，有添加博客和归档的标签，以后还会完成自己的个人简历 Q^Q</p>
<p>说到了这里，这两天自己摸索着使用github来搭建自己的个人网站确实受益良多，贴出大腿的指导书：</p>
<p><code>https://volc1605.github.io/2016/10/03/Hexo之NexT主题搭建博客详细过程</code></p>
<p>暂时的尝试先到此为止，明后天看看能不能再去抢个腾讯的服务器吧，fightting！骚年</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[f__k? this day]]></title>
      <url>http://yoursite.com/2017/02/21/fuck/</url>
      <content type="html"><![CDATA[<h1 id="Today"><a href="#Today" class="headerlink" title="Today"></a>Today</h1><p>今天是特别的一天，忙碌了一整天的时间来学习搭建个人网站博客。到现在为止，略有小成，先写下这一篇随笔，然后全当做实验了。 </p>
<p>ps:没有大腿抱确实一个人折腾好累<br>pss:折腾完又有种莫名的兴奋感……QvQ</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
